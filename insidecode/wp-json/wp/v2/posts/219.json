{"id":219,"date":"2013-02-21T21:00:12","date_gmt":"2013-02-21T20:00:12","guid":{"rendered":"http:\/\/insidecode.it\/?p=219"},"modified":"2013-10-13T21:28:29","modified_gmt":"2013-10-13T19:28:29","slug":"arduino-gameboy-cart-readerwriter","status":"publish","type":"post","link":"http:\/\/insidecode.it\/arduino-gameboy-cart-readerwriter\/","title":{"rendered":"Arduino GameBoy cart Reader\/Writer"},"content":{"rendered":"<h2>Introduzione:<\/h2>\n<p>Recentemente, rispolverando la mia collezione di <strong>retro games Nintendo<\/strong>, ho notato con mio grande dispiacere che alcune cartucce di gioco (ferme da pi\u00f9 di dieci anni) risultavano completamente vuote, prive dei dati di gioco collezionati in et\u00e0 puerile. (all&#8217;interno delle cartucce di gioco \u00e8 presente una batteria tampone che ha lo scopo di mantenere in memoria il salvataggio;\u00a0quando la batteria si esaurisce, inevitabilmente si perde il salvataggio).<\/p>\n<p>A quel punto sorse spontanea la domanda: <strong>come posso fare un backup dei salvataggi dei miei vecchi giochi?<\/strong><\/p>\n<p>Certo, esistono gi\u00e0 dei lettori di cartucce, ma sono difficili da reperire, e spesso molto costosi&#8230; cos\u00ec ho optato per una soluzione pi\u00f9 economica e amatoriale:<\/p>\n<figure id=\"attachment_221\" aria-describedby=\"caption-attachment-221\" style=\"width: 294px\" class=\"wp-caption aligncenter\"><a href=\"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/03022012094.jpg\"><img data-attachment-id=\"221\" data-permalink=\"http:\/\/insidecode.it\/arduino-gameboy-cart-readerwriter\/attachment\/03022012094\/\" data-orig-file=\"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/03022012094.jpg?fit=2592%2C1944\" data-orig-size=\"2592,1944\" data-comments-opened=\"1\" data-image-meta=\"{&quot;aperture&quot;:&quot;2.8&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;N97 mini&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;1328283941&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;5.2&quot;,&quot;iso&quot;:&quot;200&quot;,&quot;shutter_speed&quot;:&quot;0.05&quot;,&quot;title&quot;:&quot;&quot;}\" data-image-title=\"03022012094\" data-image-description=\"\" data-medium-file=\"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/03022012094.jpg?fit=250%2C187\" data-large-file=\"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/03022012094.jpg?fit=700%2C525\" loading=\"lazy\" class=\"wp-image-221 \" title=\"Arduino gameboy dumper\" alt=\"Arduino GameBoy cart reader\/writer\" src=\"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/03022012094.jpg?resize=294%2C221\" width=\"294\" height=\"221\" srcset=\"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/03022012094.jpg?resize=700%2C525 700w, https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/03022012094.jpg?resize=250%2C187 250w, https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/03022012094.jpg?resize=125%2C93 125w, https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/03022012094.jpg?resize=220%2C165 220w, https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/03022012094.jpg?w=1906 1906w\" sizes=\"(max-width: 294px) 100vw, 294px\" data-recalc-dims=\"1\" \/><\/a><figcaption id=\"caption-attachment-221\" class=\"wp-caption-text\">Arduino GameBoy cart reader\/writer<\/figcaption><\/figure>\n<p><strong>Arduino<\/strong> sembrava essere l&#8217;ideale per questo tipo di progetto, cos\u00ec tentai di costruire un mio proprio prototipo di lettore di cartucce per <strong>GameBoy<\/strong>.<\/p>\n<h2>Analisi del progetto<\/h2>\n<p>[ssbluelist]<\/p>\n<ul>\n<li>Il <a href=\"#first\">primo passo<\/a> verso la realizzazione del progetto \u00e8 quello di aprire una cartuccia di gioco per analizzarne la struttura interna;<\/li>\n<li><a href=\"#second\">Secondo passo<\/a>: estrapolare il Pinout e capire come interfacciare la cartuccia di gioco e la nostra board Arduino;<\/li>\n<li><a href=\"#third\">Terzo passo<\/a>: realizzare la prima interfaccia hardware e software;<\/li>\n<li><a href=\"#fourth\">Quarto passo<\/a>: riguarda il lato software: riuscire a leggere i dati dalla cartuccia;<\/li>\n<li><a href=\"#fiveth\">Quindo passo<\/a>: realizzare l&#8217;interfaccia software dal lato pc in modo da salvare i dati letti dal nostro Arduino;<\/li>\n<li>Sesto passo consiste nel scrivere i dati salvati precedentemente nel computer nella cartuccia di gioco;<\/li>\n<li><a href=\"#sixth\">Conclusioni<\/a>.<\/li>\n<\/ul>\n<p>[\/ssbluelist]<\/p>\n<h2 id=\"first\">Primo passo: Inside the Gameboy<\/h2>\n<p>Per prima cosa diamo uno sguardo all&#8217;interno della cartuccia di gioco per analizzarne la struttura:<\/p>\n<figure id=\"attachment_235\" aria-describedby=\"caption-attachment-235\" style=\"width: 250px\" class=\"wp-caption aligncenter\"><a href=\"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridge.jpg\"><img data-attachment-id=\"235\" data-permalink=\"http:\/\/insidecode.it\/arduino-gameboy-cart-readerwriter\/cartridge\/\" data-orig-file=\"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridge.jpg?fit=719%2C400\" data-orig-size=\"719,400\" data-comments-opened=\"1\" data-image-meta=\"{&quot;aperture&quot;:&quot;7.1&quot;,&quot;credit&quot;:&quot;unknown&quot;,&quot;camera&quot;:&quot;Canon EOS 350D DIGITAL&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;1300620656&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;45&quot;,&quot;iso&quot;:&quot;400&quot;,&quot;shutter_speed&quot;:&quot;0.005&quot;,&quot;title&quot;:&quot;&quot;}\" data-image-title=\"gameboy cartridge\" data-image-description=\"\" data-medium-file=\"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridge.jpg?fit=250%2C139\" data-large-file=\"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridge.jpg?fit=700%2C389\" loading=\"lazy\" class=\"size-medium wp-image-235 \" title=\"gameboy internal cartridge\" alt=\"Interno della cartuccia\" src=\"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridge.jpg?resize=250%2C139\" width=\"250\" height=\"139\" srcset=\"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridge.jpg?resize=250%2C139 250w, https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridge.jpg?resize=700%2C389 700w, https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridge.jpg?resize=125%2C69 125w, https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridge.jpg?resize=220%2C122 220w, https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridge.jpg?w=719 719w\" sizes=\"(max-width: 250px) 100vw, 250px\" data-recalc-dims=\"1\" \/><\/a><figcaption id=\"caption-attachment-235\" class=\"wp-caption-text\">Interno della cartuccia<\/figcaption><\/figure>\n<p>[sstoggles] [sstoggle title=&#8221;Componenti&#8221;]<strong>ROM<\/strong> dove sono contenuti i dati del gioco<\/p>\n<p><strong>RAM<\/strong> dove \u00e8 contenuto il salvataggio del gioco<\/p>\n<p><strong>MBC<\/strong> controllo dei banchi di memoria, gestisce e alloca grandi spazi di memoria<\/p>\n<p><strong>Timer Chip<\/strong> mantiente la data e l&#8217;ora (presente solo in alcune cartucce)<\/p>\n<p><strong>Batteria<\/strong>[\/sstoggle][\/sstoggles]<\/p>\n<h2 id=\"second\">Secondo passo: Cartridge Pinout<\/h2>\n<p>La cartuccia di gioco presenta un&#8217;interfaccia a 32 <em>Pin<\/em>:<\/p>\n<figure id=\"attachment_236\" aria-describedby=\"caption-attachment-236\" style=\"width: 250px\" class=\"wp-caption aligncenter\"><a href=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridgepin.jpg\"><img data-attachment-id=\"236\" data-permalink=\"http:\/\/insidecode.it\/arduino-gameboy-cart-readerwriter\/cartridgepin\/\" data-orig-file=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridgepin.jpg?fit=300%2C109\" data-orig-size=\"300,109\" data-comments-opened=\"1\" data-image-meta=\"{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;}\" data-image-title=\"cartridgepin\" data-image-description=\"\" data-medium-file=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridgepin.jpg?fit=250%2C90\" data-large-file=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridgepin.jpg?fit=300%2C109\" loading=\"lazy\" class=\"size-medium wp-image-236 \" title=\"gameboy cartridge pinout\" alt=\"cartridgepin\" src=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridgepin.jpg?resize=250%2C90\" width=\"250\" height=\"90\" srcset=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridgepin.jpg?resize=250%2C90 250w, https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridgepin.jpg?resize=125%2C45 125w, https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridgepin.jpg?resize=220%2C79 220w, https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/cartridgepin.jpg?w=300 300w\" sizes=\"(max-width: 250px) 100vw, 250px\" data-recalc-dims=\"1\" \/><\/a><figcaption id=\"caption-attachment-236\" class=\"wp-caption-text\">Cartridge pinout<\/figcaption><\/figure>\n<p>[sstoggles] [sstoggle title=&#8221;PinOut&#8221;]<strong>VCC<\/strong> &#8211; Alimentazione (5 volts)<\/p>\n<p><strong>CLK<\/strong> &#8211; Clock<\/p>\n<p><strong>~WR<\/strong> &#8211; se <em>Low<\/em> AND RD <em>Low<\/em>, possiamo scrivere sulla <strong>SRAM<\/strong><\/p>\n<p><strong>~RD<\/strong> &#8211; se <em>low<\/em> AND WR <em>High<\/em>, possiamo leggere la <strong>ROM<\/strong> e la <strong>SRAM<\/strong><\/p>\n<p><strong>CS_SRAM<\/strong> &#8211; se abilitato, seleziona la <em>SRAM\u00a0<\/em>in scrittura<\/p>\n<p><strong>A0 &#8211; A15<\/strong> &#8211; 16 linee di indirizzo della\u00a0<strong>ROM\u00a0<\/strong>(a seconda della configurazione anche della SRAM ed altri componenti)<\/p>\n<p><strong>D0 &#8211; D7<\/strong> &#8211; le 8 linee dati attraverso le quali leggiamo\/scriviamo la <strong>ROM<\/strong>\/<strong>SRAM<\/strong>.<\/p>\n<p><strong>Reset<\/strong> &#8211; provoca un Reset dei componenti (abilitato <em>Low<\/em>)<\/p>\n<p><strong>Audio in<\/strong> &#8211; (non in uso)<\/p>\n<p><strong>GND<\/strong> &#8211; Massa<br \/>\n[\/sstoggle][\/sstoggles]<\/p>\n<h2 id=\"third\">Terzo passo: Arduino Interface<\/h2>\n<p>Analizzando la struttura della cartuccia e il suo pinout abbiamo visto come il GameBoy possa allocare solamente indirizzi dati a 16 bit (ricordiamo le 16 linee dati A0-A15). Questo significa (in teoria, ma vedremo che in realt\u00e0 non \u00e8 cos\u00ec) che la capacit\u00e0 massima di allocamento \u00e8 2^16 byte = <strong>65,536 bytes<\/strong><\/p>\n<p>Dal momento che questi 16 indirizzi controllano anche l&#8217;accesso alla sRAM e a tutti gli altri componenti della cartuccia, in realt\u00e0 solamente gli indirizzi compresi tra <strong>0x0000<\/strong> e <strong>0x777f<\/strong> sono dedicati alla ROM \u00a0(gli indirizzi sono espressi base esadecimale), per un totale di 32,767 bytes su cui lavorare.<\/p>\n<p>Il primo gioco per GameBoy mai realizzato fu &#8220;<strong>Tetris<\/strong>&#8220;, la cartuccia era provvista solamente di una ROM da\u00a032,767 bytes, una quantit\u00e0 di spazio pi\u00f9 che sufficiente per i giochi dell&#8217;epoca (lontano 1989).<\/p>\n<p>Il GameBoy prende piede nel vecchio e nel nuovo continente, la tecnologia avanza, e 32kbyte di spazio cominciano ad essere pochi: la Nintendo introduce un nuovo chip nei suoi progetti, L&#8217; <strong>MBC<\/strong> (<em>Memory Bank Controller<\/em>). Questo chip risolse totalmente il problema di spazio all&#8217;interno delle cartucce (uno standard mantenuto fino all&#8217;avvento del <strong>GameBoy Color<\/strong>): come ci suggerisce il nome, infatti, il circuito integrato funge da controllore di banchi di memoria; con opportuni accorgimenti e collegamenti, \u00e8 in grado di pilotare ROM con <strong>21<\/strong> linee di indirizzo, allocando fino a <strong>8Megabytes<\/strong>! (ultima versione MBC5)<\/p>\n<p>Quello che ci rimane da fare ora \u00e8 creare un collegamento tra la cartuccia e il nostro Arduino:<\/p>\n<figure id=\"attachment_252\" aria-describedby=\"caption-attachment-252\" style=\"width: 250px\" class=\"wp-caption aligncenter\"><a href=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/testboard.jpg\"><img data-attachment-id=\"252\" data-permalink=\"http:\/\/insidecode.it\/arduino-gameboy-cart-readerwriter\/testboard\/\" data-orig-file=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/testboard.jpg?fit=600%2C450\" data-orig-size=\"600,450\" data-comments-opened=\"1\" data-image-meta=\"{&quot;aperture&quot;:&quot;2.8&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;N97 mini&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;1327596489&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;5.2&quot;,&quot;iso&quot;:&quot;187&quot;,&quot;shutter_speed&quot;:&quot;0.05&quot;,&quot;title&quot;:&quot;&quot;}\" data-image-title=\"testboard\" data-image-description=\"\" data-medium-file=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/testboard.jpg?fit=250%2C187\" data-large-file=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/testboard.jpg?fit=600%2C450\" loading=\"lazy\" class=\"size-medium wp-image-252 \" title=\"test board\" alt=\"testboard\" src=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/testboard.jpg?resize=250%2C187\" width=\"250\" height=\"187\" srcset=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/testboard.jpg?resize=250%2C187 250w, https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/testboard.jpg?resize=125%2C93 125w, https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/testboard.jpg?resize=220%2C165 220w, https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/testboard.jpg?w=600 600w\" sizes=\"(max-width: 250px) 100vw, 250px\" data-recalc-dims=\"1\" \/><\/a><figcaption id=\"caption-attachment-252\" class=\"wp-caption-text\">Prototipo su BreadBoard<\/figcaption><\/figure>\n<p>Il problema pi\u00f9 grande che ho dovuto affrontare \u00e8 stato quello della mancanza dei pin: la cartuccia, come abbiamo visto, \u00e8 provvista di 32 pin, mentre Arduino possiede solamente 13 pin digitali (di cui 2 usati per la trasmissione seriale) e 5 analogici, come risolvete tale problema? <strong>Shift Registers!<\/strong><\/p>\n<p>[ideabox]Usando due <em>ShiftRegisters<\/em><strong> 74LS595N<\/strong> collegati in serie serie, siamo in grado di pilotare fino a 16 uscite digitali utilizzando solamente 2 pin digitali del nostro Arduino (<strong>i2c bus<\/strong>).[\/ideabox]<\/p>\n<h2 id=\"fifht\">Quarto passo: Arduino Software<\/h2>\n<p>Ecco forse la parte pi\u00f9 difficile, realizzare il software Arduino: prima di tutto schematizziamo il funzionamento del nostro programma e cosa ci interessa che faccia.<\/p>\n<ol>\n<li>Arduino attende l&#8217;inserimento della cartuccia.<\/li>\n<li>Una volta rilevata la cartuccia procede verificando il <b><i>Checksum<\/i><\/b>, per decretarne la validit\u00e0 e il corretto inserimento<\/li>\n<li>\u00a0Arduino legge tutti gli attributi dell&#8217;<b><i>Header<\/i><\/b> (tutte le informazioni peculiari della cartuccia: nome gioco, grandezza rom, ram etc.) e le invia al computer.<\/li>\n<li>Il software attende in risposta dal computer uno dei seguenti comandi: <b>Leggi ROM<\/b>, <b>Leggi sRAM<\/b>, <b>Scrivi sRam<\/b><\/li>\n<li>Ricomincia il ciclo del programma.<\/li>\n<\/ol>\n<p>Qui un estratto dell&#8217;algoritmo usato per il Checksum (situato all&#8217;indirizzo 0x014d della ROM):<\/p>\n<p>original source from TheNintendoGameboy:<\/p>\n<pre> x=0:FOR i=0134h TO 014Ch:x=x-MEM[i]-1:NEXT\r\n\r\n from my Arduino software:\r\n \/\/ Wait for serial input\r\n while (Serial.available() &lt;= 0) {\r\n \/\/coltrollo cartuccia inserita correttamente (checksum)\r\n int checksum = readbank0Address(0x014D) ;\r\n int x = 0;\r\n for (int addr = 0x0134; addr &lt;= 0x014C; addr++) {\r\n x = x - readbank0Address(addr) - 1 ; \r\n }\r\n if ((x &amp; 0xFF) == checksum) { digitalWrite(greenled, HIGH);  }\r\n else digitalWrite(redled, HIGH);\r\n delay (50) ;<\/pre>\n<p>Qui in <a href=\"\/docs\/arduino_gb_dumper.ino\" target=\"_blank\">Allegato<\/a> il <b>codice sorgente completo<\/b>.<\/p>\n<h2>Quinto passo: Computer Software<\/h2>\n<p>Analizzato il lato Arduino, passiamo ora al lato <b>Computer<\/b>:<\/p>\n<p>Ho realizzato il software computer in <b><i>Phyton<\/i><\/b> basandomi su quello realizzato da <a href=\"http:\/\/www.insidegadgets.com\" target=\"_blank\"><b>InsideGadgets<\/b><\/a>, ampliandolo, adattandolo alla mia board Arduino e perfezionandolo.<\/p>\n<p>Il software funziona nel seguente modo:<\/p>\n<ol>\n<li>Il software attende la riposta dalla board Arduino.<\/li>\n<li>Una volta rilevata la Board Arduino, il software invia la richiesta dell&#8217;Header della cartuccia e stampa a schermo la risposta.<\/li>\n<li>A questo punto l&#8217;utente pu\u00f2 scegliere tra varie opzioni: <b>Leggi ROM &#8211; Leggi sRAM &#8211; Scrivi sRAM &#8211; Ricomincia loop programma<\/b>.<\/li>\n<li>Il software invia il comando ad Arduino e salva i dati con il nome di intestazione del gioco della cartuccia<\/li>\n<li>Ricomincia il ciclo del programma.<\/li>\n<\/ol>\n<p>Qui uno screenshoot del programma in esecuzione:<\/p>\n<p style=\"text-align: center\"><a href=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/screenshot.jpg\"><img data-attachment-id=\"256\" data-permalink=\"http:\/\/insidecode.it\/arduino-gameboy-cart-readerwriter\/screenshot\/\" data-orig-file=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/screenshot.jpg?fit=1024%2C600\" data-orig-size=\"1024,600\" data-comments-opened=\"1\" data-image-meta=\"{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;}\" data-image-title=\"screenshot\" data-image-description=\"\" data-medium-file=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/screenshot.jpg?fit=250%2C146\" data-large-file=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/screenshot.jpg?fit=700%2C410\" loading=\"lazy\" class=\"size-medium wp-image-256 aligncenter\" alt=\"screenshot\" src=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/screenshot.jpg?resize=250%2C146\" width=\"250\" height=\"146\" srcset=\"https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/screenshot.jpg?resize=250%2C146 250w, https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/screenshot.jpg?resize=700%2C410 700w, https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/screenshot.jpg?resize=125%2C73 125w, https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/screenshot.jpg?resize=220%2C128 220w, https:\/\/i2.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/02\/screenshot.jpg?w=1024 1024w\" sizes=\"(max-width: 250px) 100vw, 250px\" data-recalc-dims=\"1\" \/><\/a><\/p>\n<p>[ssbluelist]<br \/>\nIl necessario:<\/p>\n<ol>\n<li>Interprete python: <a title=\"Download python\" href=\"http:\/\/www.python.org\/getit\/\"><b>Download<\/b><\/a><\/li>\n<li>Plugin python serial 2.6: <a title=\"Download python serial 2.6\" href=\"http:\/\/pyserial.sourceforge.net\/pyserial.html\"><b>Download<\/b><\/a><\/li>\n<li>Sorgente completa del programma per computer: <a title=\"Download sorgenti complete\" href=\"\/docs\/Arduino%20Parallel%20programmer%20v1.3a%20win.py\"><b>Download<\/b><\/a><\/li>\n<\/ol>\n<p>[\/ssbluelist]<\/p>\n<h2>Conclusioni:<\/h2>\n<p>Fonti e ispiratori:<\/p>\n<div><a href=\"http:\/\/www.ziegler.desaign.de\/\">www.ziegler.desaign.de<\/a><\/div>\n<div><a href=\"http:\/\/www.insidegadgets.com\">www.insidegadgets.com<\/a><\/div>\n<p>Per qualunqu dubbio o domanda non esitate a commentare \ud83d\ude09<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Introduzione: Recentemente, rispolverando la mia collezione di retro games Nintendo, ho notato con mio grande dispiacere che alcune cartucce di gioco (ferme da pi\u00f9 di dieci anni) risultavano completamente vuote, prive dei dati di gioco collezionati in et\u00e0 puerile. (all&#8217;interno delle cartucce di gioco \u00e8 presente una batteria tampone che ha lo scopo di mantenere [&hellip;]<\/p>\n","protected":false},"author":2,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"spay_email":"","jetpack_publicize_message":"","jetpack_is_tweetstorm":false},"categories":[2],"tags":[73,18,17,16],"aioseo_notices":[],"jetpack_featured_media_url":"","jetpack_publicize_connections":[],"jetpack_shortlink":"https:\/\/wp.me\/p3csTP-3x","jetpack_sharing_enabled":true,"jetpack_likes_enabled":true,"jetpack-related-posts":[{"id":603,"url":"http:\/\/insidecode.it\/homemade-gameboy-flashcart-prototypes\/","url_meta":{"origin":219,"position":0},"title":"Homemade GameBoy FlashCart prototypes","date":"21 Settembre 2013","format":false,"excerpt":"Dopo avervi presentato il mio GameBoy Cartridge Reader\/Writer, oggi vi mostrer\u00f2 un video dimostrativo di due prototipi di FlashCard realizzati da me per gameboy. Queste cartucce, una volta programmate con l'Arduino Cartridge Reader\/Writer, permettono di eseguire codice propetario e non (Homebrew) su un game boy reale; di fatto si rivelano\u2026","rel":"","context":"In &quot;Arduino&quot;","img":{"alt_text":"","src":"","width":0,"height":0},"classes":[]},{"id":561,"url":"http:\/\/insidecode.it\/bomberchap-disponibile-online-su-insidecode-it\/","url_meta":{"origin":219,"position":1},"title":"BomberChap disponibile online su insidecode.it","date":"19 Settembre 2013","format":false,"excerpt":"Sicuramente vi ricorderete del progetto SaGa di cui vi ho parlato Qui, come avevo anticipato e promesso sono finalmente riuscito a completarlo e renderlo disponibile in Html5. Non fatevi ingannare dal nome, il gioco \u00e8 sempre l'unico e inimitabile! :D Il gioco \u00e8 disponibile a questo indirizzo, in maniera del\u2026","rel":"","context":"In &quot;Games&quot;","img":{"alt_text":"","src":"","width":0,"height":0},"classes":[]},{"id":270,"url":"http:\/\/insidecode.it\/masterclass-tolta-2012-arduino-processing-csound-osc\/","url_meta":{"origin":219,"position":2},"title":"Masterclass Tolta 2012: Arduino, Processing, CSound, OSC","date":"2 Aprile 2013","format":false,"excerpt":"Arduino, Processing, Csound, OSC: un mix portentoso! Nell'agosto del 2012 ho partecipato a una Masterclass di composizione e nuove tecnologie organizzata e tenuta dal comune di Tolfa. Obiettivo di tale corso approfondire e studiare nuove possibilit\u00e0 compositive, in accordo con nuove tecnologie, interfacciando l'utente con il mondo del computer music.\u2026","rel":"","context":"In &quot;Arduino&quot;","img":{"alt_text":"","src":"https:\/\/i1.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/04\/IMG_20121023_2118311.jpg?fit=1000%2C343&resize=350%2C200","width":350,"height":200},"classes":[]},{"id":432,"url":"http:\/\/insidecode.it\/ars-electronika-update2-recording\/","url_meta":{"origin":219,"position":3},"title":"Ars Electronika Update2 : recording","date":"11 Maggio 2013","format":false,"excerpt":"Oggi presso l'associazione culturale Spazio Musica si terr\u00e0 la registrazione della performance in tempo reale presentata al Circolo della Soda il 21 aprile. Al pi\u00f9 presto foto e filmati!","rel":"","context":"In &quot;Arduino&quot;","img":{"alt_text":"","src":"https:\/\/i0.wp.com\/insidecode.it\/wp-content\/uploads\/2013\/05\/SavedPicture-2013511164510.jpg?resize=350%2C200","width":350,"height":200},"classes":[]},{"id":499,"url":"http:\/\/insidecode.it\/olinuxino-development-boards\/","url_meta":{"origin":219,"position":4},"title":"OLinuXino - Development Boards","date":"18 Agosto 2013","format":false,"excerpt":"L'ultimo arrivato a casa InsideCode a far compagnia alla coppia di Arduino UNO e Arduino DUE \u00e8 una fiammante OlinuXino A13 wifi board della casa Bulgara Olimex. Questa Board supporta, oltre alla programmazione diretta Bare Metal (no OS), varie distribuzioni di linux come Ubuntu, Fedora e Debian ed il sistema\u2026","rel":"","context":"In &quot;Arduino&quot;","img":{"alt_text":"","src":"","width":0,"height":0},"classes":[]},{"id":425,"url":"http:\/\/insidecode.it\/conferenza-gruppo-ars-electronika-updates\/","url_meta":{"origin":219,"position":5},"title":"Conferenza gruppo Ars Electronika - updates","date":"24 Aprile 2013","format":false,"excerpt":"Chi ha seguito il mio blog nelle ultime settimane sapr\u00e0 che domenica il gruppo Ars Electronika si \u00e9 esibito al Circolo della Soda a Civitavecchia presentando una conferenza e due performance dal vivo. Ci stiamo impegnando in questo giorni a raccogliere video e foto dell'evento, nonch\u00e9 a preparare una registrazione\u2026","rel":"","context":"In &quot;Arduino&quot;","img":{"alt_text":"","src":"","width":0,"height":0},"classes":[]}],"_links":{"self":[{"href":"http:\/\/insidecode.it\/wp-json\/wp\/v2\/posts\/219"}],"collection":[{"href":"http:\/\/insidecode.it\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/insidecode.it\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/insidecode.it\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/insidecode.it\/wp-json\/wp\/v2\/comments?post=219"}],"version-history":[{"count":38,"href":"http:\/\/insidecode.it\/wp-json\/wp\/v2\/posts\/219\/revisions"}],"predecessor-version":[{"id":626,"href":"http:\/\/insidecode.it\/wp-json\/wp\/v2\/posts\/219\/revisions\/626"}],"wp:attachment":[{"href":"http:\/\/insidecode.it\/wp-json\/wp\/v2\/media?parent=219"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/insidecode.it\/wp-json\/wp\/v2\/categories?post=219"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/insidecode.it\/wp-json\/wp\/v2\/tags?post=219"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}