<html>
<head><meta charset="UTF-8" /><script>
var $gwt_version = "2.5.0";
var $wnd = parent;
var $doc = $wnd.document;
var $moduleName, $moduleBase;
var $strongName = 'B5A3EC7152FD514DB8FEE5888E022F6A';
var $stats = $wnd.__gwtStatsEvent ? function(a) {return $wnd.__gwtStatsEvent(a);} : null,
$sessionId = $wnd.__gwtStatsSessionId ? $wnd.__gwtStatsSessionId : null;
$stats && $stats({moduleName:'bomberman',sessionId:$sessionId,subSystem:'startup',evtGroup:'moduleStartup',millis:(new Date()).getTime(),type:'moduleEvalStart'});
</script></head>
<body>
<script><!--
var _, N8000000000000000_longLit = {l:0, m:0, h:524288}, N10000000000000_longLit = {l:0, m:0, h:1048320}, P0_longLit = {l:0, m:0, h:0}, P3e8_longLit = {l:1000, m:0, h:0}, P3ff_longLit = {l:1023, m:0, h:0}, P7ff_longLit = {l:2047, m:0, h:0}, P80000000_longLit = {l:0, m:512, h:0}, Pfffffffffffff_longLit = {l:4194303, m:4194303, h:255}, P7ff0000000000000_longLit = {l:0, m:0, h:524032}, P7ff8000000000000_longLit = {l:0, m:0, h:524160}, seedTable = {}, Q$Object = 0, Q$String = 1, Q$Block = 2, Q$Block_$1 = 3, Q$Bomb = 4, Q$Bomber = 5, Q$BrickBlock = 6, Q$Direction = 7, Q$DynamicPhysicsEntity = 8, Q$Entity = 9, Q$FireEntity = 10, Q$FreeBlock = 11, Q$PhysicsEntity = 12, Q$PhysicsEntity$HasContactListener = 13, Q$PhysicsEntity_$1 = 14, Q$Enemy = 15, Q$Door = 16, Q$PowerUp = 17, Q$PowerUpBomb = 18, Q$PowerUpBombKick = 19, Q$PowerUpBombPass = 20, Q$PowerUpBombRangeDown = 21, Q$PowerUpBombRangeUp = 22, Q$PowerUpEnum = 23, Q$PowerUpLife = 24, Q$PowerUpSkull = 25, Q$PowerUpSpeedDown = 26, Q$PowerUpSpeedUp = 27, Q$PowerUpTimeDown = 28, Q$PowerUpTimeUp = 29, Q$UIScreen = 30, Q$Vector2 = 31, Q$Sound$LoadState = 32, Q$SoundController$MimeTypeSupport = 33, Q$SoundType = 34, Q$Context2d$LineCap = 35, Q$Context2d$LineJoin = 36, Q$Context2d$Repetition = 37, Q$Context2d$TextBaseline = 38, Q$JavaScriptException = 39, Q$Style$FontStyle = 40, Q$Style$FontWeight = 41, Q$Style$HasCssName = 42, Q$Style$Overflow = 43, Q$Style$Position = 44, Q$Style$Unit = 45, Q$Style$Visibility = 46, Q$HasAttachHandlers = 47, Q$HasHandlers = 48, Q$LongLibBase$LongEmul = 49, Q$EventListener = 50, Q$HasVisibility = 51, Q$IsWidget = 52, Q$UIObject = 53, Q$Widget = 54, Q$UmbrellaException = 55, Q$Serializable = 56, Q$CharSequence = 57, Q$Comparable = 58, Q$Enum = 59, Q$Exception = 60, Q$Integer = 61, Q$Number = 62, Q$Object_$1 = 63, Q$RuntimeException = 64, Q$StackTraceElement = 65, Q$Throwable = 66, Q$ByteBuffer = 67, Q$FloatBuffer = 68, Q$ShortBuffer = 69, Q$Date = 70, Q$List = 71, Q$Map = 72, Q$Map$Entry = 73, Q$NoSuchElementException = 74, Q$Set = 75, Q$Collision$ClipVertex = 76, Q$Collision$EPAxis$Type = 77, Q$Distance$SimplexVertex = 78, Q$Manifold$ManifoldType = 79, Q$ManifoldPoint = 80, Q$TimeOfImpact$TOIOutputState = 81, Q$Type = 82, Q$DynamicTreeNode = 83, Q$Pair = 84, Q$ShapeType = 85, Q$Vec2 = 86, Q$Body = 87, Q$BodyType = 88, Q$FixtureProxy = 89, Q$Contact = 90, Q$ContactPositionConstraint = 91, Q$ContactRegister = 92, Q$ContactRegister_$1 = 93, Q$ContactVelocityConstraint = 94, Q$ContactVelocityConstraint$VelocityConstraintPoint = 95, Q$Position = 96, Q$Velocity = 97, Q$Joint = 98, Q$AbstractFont = 99, Q$AbstractLayer = 100, Q$AbstractLayer$Flag = 101, Q$Events$Input = 102, Q$Events$Input$Impl = 103, Q$Events$Position = 104, Q$Events$Position$Impl = 105, Q$Font$Style = 106, Q$Key = 107, Q$Keyboard$Listener = 108, Q$Layer = 109, Q$Pointer$Listener = 110, Q$TextFormat = 111, Q$TextFormat$Alignment = 112, Q$Touch$Event = 113, Q$Touch$Event$Impl = 114, Q$Touch$Listener = 115, Q$HasArrayBufferView = 116, Q$HtmlGL20$VertexAttribArrayState = 117, Q$HtmlGL20$WebGLObjectType = 118, Q$AbstractPoint = 119, Q$AbstractVector = 120, Q$NoninvertibleTransformException = 121, CM$ = {};
function newSeed(id){
  return new seedTable[id];
}

function defineSeed(id, superSeed, castableTypeMap){
  var seed = seedTable[id];
  if (seed && !seed.___clazz$) {
    _ = seed.prototype;
  }
   else {
    !seed && (seed = seedTable[id] = function(){
    }
    );
    _ = seed.prototype = superSeed < 0?{}:newSeed(superSeed);
    _.castableTypeMap$ = castableTypeMap;
  }
  for (var i = 3; i < arguments.length; ++i) {
    arguments[i].prototype = _;
  }
  if (seed.___clazz$) {
    _.___clazz$ = seed.___clazz$;
    seed.___clazz$ = null;
  }
}

function makeCastMap(a){
  var result = {};
  for (var i = 0, c = a.length; i < c; ++i) {
    result[a[i]] = 1;
  }
  return result;
}

function nullMethod(){
}

defineSeed(1, -1, CM$);
_.equals$ = function equals(other){
  return this === other;
}
;
_.getClass$ = function getClass_0(){
  return this.___clazz$;
}
;
_.hashCode$ = function hashCode_0(){
  return getHashCode(this);
}
;
_.toString$ = function toString_0(){
  return this.___clazz$.typeName + '@' + toPowerOfTwoString(this.hashCode$());
}
;
_.toString = function(){
  return this.toString$();
}
;
_.typeMarker$ = nullMethod;
function $tick(this$static, elapsed){
  var alpha, nextUpdate, updateRate, updates;
  nextUpdate = this$static.nextUpdate;
  updateRate = this$static.updateRate;
  updates = 0;
  while (elapsed >= nextUpdate) {
    nextUpdate += updateRate;
    ++updates;
  }
  if (updates > 0) {
    this$static.delegate.update(updates * updateRate);
    elapsed = $tick_0(platform_1);
  }
  alpha = 1 - (nextUpdate - elapsed) / updateRate;
  this$static.delegate.paint(alpha);
  this$static.nextUpdate = nextUpdate;
}

defineSeed(4, 1, {});
_.nextUpdate = 0;
_.updateRate = 0;
function $lose(this$static){
  $stop_0(this$static.roundSound);
  $show_2(this$static.loseScreen);
  this$static.delegate = this$static.loseScreen;
}

function $onKeyDown(this$static, event_0){
  this$static.delegate.onKeyDown(event_0);
}

function $onKeyTyped(this$static, event_0){
  this$static.delegate.onKeyTyped(event_0);
}

function $onKeyUp(this$static, event_0){
  this$static.delegate.onKeyUp(event_0);
}

function $onPointerDrag(this$static, event_0){
  this$static.delegate.onPointerDrag(event_0);
}

function $onPointerEnd(this$static, event_0){
  this$static.delegate.onPointerEnd(event_0);
}

function $onPointerStart(this$static, event_0){
  this$static.delegate.onPointerStart(event_0);
}

function $onTouchEnd(this$static, touches){
  this$static.delegate.onTouchEnd(touches);
}

function $onTouchMove(this$static, touches){
  this$static.delegate.onTouchMove(touches);
}

function $onTouchStart(this$static, touches){
  this$static.delegate.onTouchStart(touches);
}

function $pause(this$static){
  $stop_0(this$static.roundSound);
  $show_3(this$static.pauseScreen);
  this$static.delegate = this$static.pauseScreen;
}

function $resume(this$static){
  $hide_0(this$static.pauseScreen);
  this$static.delegate = this$static.gameScreen;
  $play_0(this$static.roundSound);
}

function $showInstructions(this$static){
  $stop_0(this$static.startSound);
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).overlayLayer.clear_0();
  $show_1(this$static.instructionScreen);
  this$static.delegate = this$static.instructionScreen;
}

function $start(this$static){
  clear();
  $show_4(this$static.startScreen);
  this$static.delegate = this$static.startScreen;
  $play_0(this$static.startSound);
}

function $startNewRound(this$static, newLevel){
  $startNewRandomRound(this$static.gameScreen, newLevel);
  $stop_0(this$static.startSound);
  clear();
  $show_0(this$static.gameScreen);
  this$static.delegate = this$static.gameScreen;
  $play_0(this$static.roundSound);
}

function $win(this$static){
  $stop_0(this$static.roundSound);
  $show_5(this$static.winScreen);
  this$static.delegate = this$static.winScreen;
}

function BomberMan_0(){
  this.updateRate = 33;
}

defineSeed(3, 4, makeCastMap([Q$Keyboard$Listener, Q$Pointer$Listener, Q$Touch$Listener]), BomberMan_0);
_.onKeyDown = function onKeyDown(event_0){
  $onKeyDown(this, event_0);
}
;
_.onKeyTyped = function onKeyTyped(event_0){
  $onKeyTyped(this, event_0);
}
;
_.onKeyUp = function onKeyUp(event_0){
  $onKeyUp(this, event_0);
}
;
_.onPointerDrag = function onPointerDrag(event_0){
  $onPointerDrag(this, event_0);
}
;
_.onPointerEnd = function onPointerEnd(event_0){
  $onPointerEnd(this, event_0);
}
;
_.onPointerStart = function onPointerStart(event_0){
  $onPointerStart(this, event_0);
}
;
_.onTouchEnd = function onTouchEnd(touches){
  $onTouchEnd(this, touches);
}
;
_.onTouchMove = function onTouchMove(touches){
  $onTouchMove(this, touches);
}
;
_.onTouchStart = function onTouchStart(touches){
  $onTouchStart(this, touches);
}
;
_.delegate = null;
_.gameScreen = null;
_.immediateLayer = null;
_.instructionScreen = null;
_.loadScreen = null;
_.loseScreen = null;
_.pauseScreen = null;
_.roundSound = null;
_.startScreen = null;
_.startSound = null;
_.winScreen = null;
function $onSuccess(this$static){
  $loadAssets_1(this$static.this$0.loadScreen);
  this$static.this$0.roundSound = $getSound(platform_1.assets, $get_4((!instance && (instance = new PropertiesManager_0(null)) , instance).settings, 'roundSound'));
  $add_14(this$static.this$0.loadScreen.watcher, this$static.this$0.roundSound);
  $setLooping_0(this$static.this$0.roundSound, true);
  this$static.this$0.startSound = $getSound(platform_1.assets, $get_4((!instance && (instance = new PropertiesManager_0(null)) , instance).settings, 'startSound'));
  $add_14(this$static.this$0.loadScreen.watcher, this$static.this$0.startSound);
  $setLooping_0(this$static.this$0.startSound, false);
}

function BomberMan$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(5, 1, {}, BomberMan$1_0);
_.onFailure = function onFailure(cause){
}
;
_.onSuccess = function onSuccess(result){
  $onSuccess(this, result);
}
;
_.this$0 = null;
function $render(this$static, surface){
  this$static.this$0.delegate.drawSurface(surface);
}

function BomberMan$2_0(this$0){
  this.this$0 = this$0;
}

defineSeed(6, 1, {}, BomberMan$2_0);
_.this$0 = null;
function $loadProperties(this$static, properties){
  var $e0, e, temp, x, x$index, x$max;
  try {
    for (x$index = 0 , x$max = properties.length; x$index < x$max; ++x$index) {
      x = properties[x$index];
      temp = $split($trim(x), '=', 0);
      $put_2(this$static.settings, temp[0], temp[1]);
    }
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Exception)) {
      e = $e0;
      $printStackTrace(e);
    }
     else 
      throw $e0;
  }
}

function PropertiesManager_0(callback){
  this.settings = new HashMap_0;
  $getText(platform_1.assets, new PropertiesManager$1_0(this, callback));
}

function initialize(callback){
  instance = new PropertiesManager_0(callback);
}

defineSeed(7, 1, {}, PropertiesManager_0);
var instance = null;
function $onFailure(cause){
  throw new Error_1(cause);
}

function $onSuccess_0(this$static, result){
  $loadProperties(this$static.this$0, $split(result, '\n', 0));
  !!this$static.val$callback && $onSuccess(this$static.val$callback);
}

function PropertiesManager$1_0(this$0, val$callback){
  this.this$0 = this$0;
  this.val$callback = val$callback;
}

defineSeed(8, 1, {}, PropertiesManager$1_0);
_.onFailure = function onFailure_0(cause){
  $onFailure(cause);
}
;
_.onSuccess = function onSuccess_0(result){
  $onSuccess_0(this, result);
}
;
_.this$0 = null;
_.val$callback = null;
function $destroy(this$static){
  this$static.state = 1;
  $removeEntity(this$static.logicWorld_1, this$static);
}

function $die(this$static){
  this$static.state = 1;
  if (--this$static.lives <= 0) {
    this$static.destroy();
    return;
  }
  this$static.reset();
}

function $setLives(this$static, x){
  this$static.lives = x;
}

function $setPosition(this$static, v){
  $setPosition_0(this$static, v.x, v.y);
}

defineSeed(13, 1, {});
_.destroy = function destroy(){
  $destroy(this);
}
;
_.die = function die(){
  $die(this);
}
;
_.reset = function reset(){
  this.setPosition(this.originalX, this.originalY);
  this.state = 2;
}
;
_.setPosition = function setPosition(x, y){
  this.x = x;
  this.y = y;
}
;
_.lives = 0;
_.logicWorld_1 = null;
_.originalX = 0;
_.originalY = 0;
_.state = 2;
_.x = 0;
_.y = 0;
function $alignPosition(this$static, c){
  var maxDistance, midDistance, x, y;
  maxDistance = $sub(new Vector2_0(c.width_0, c.heigth), new Vector2_0(this$static.width_0, this$static.height_0));
  midDistance = new Vector2_0(maxDistance.x / 2, maxDistance.y / 2);
  x = (new Vector2_0(this$static.x, this$static.y)).x < $add_2(new Vector2_0(round_int(c.x), round_int(c.y)), midDistance).x?(new Vector2_0(round_int(c.x), round_int(c.y))).x:$add_2(new Vector2_0(round_int(c.x), round_int(c.y)), maxDistance).x;
  y = (new Vector2_0(this$static.x, this$static.y)).y < $add_2(new Vector2_0(round_int(c.x), round_int(c.y)), midDistance).y?(new Vector2_0(round_int(c.x), round_int(c.y))).y:$add_2(new Vector2_0(round_int(c.x), round_int(c.y)), maxDistance).y;
  this$static.x = x;
  this$static.y = y;
  $setTransform(this$static.body_0, $getVec2($div(new Vector2_0(this$static.x, this$static.y), 100)));
}

function $getBottomCenter(this$static){
  return $add_2(new Vector2_0(this$static.x, this$static.y), new Vector2_0(16, 32));
}

function $increaseSpeed(this$static, increment){
  if (this$static.speed == 4 || increment < 0 && this$static.speed == 1)
    return;
  this$static.speed += increment;
}

function $initBody(this$static){
  var bd, fd, shape;
  bd = new BodyDef_0;
  bd.type_0 = ($clinit_BodyType() , DYNAMIC);
  $set_12(bd.position_0, $getVec2($div(new Vector2_0(this$static.x, this$static.y), 100)));
  shape = new CircleShape_0;
  shape.m_radius = 0.12800000607967377;
  this$static.height_0 = this$static.width_0 = shape.m_radius * 2 * 100;
  fd = new FixtureDef_0;
  fd.friction = 0;
  fd.isSensor = this$static.isSensor;
  fd.shape = shape;
  this$static.body_0 = $createBody(this$static.logicWorld_0.entityEngine.world, bd);
  $createFixture(this$static.body_0, fd);
}

function $move(this$static, d){
  var x, y;
  x = 0;
  y = 0;
  switch (d.ordinal) {
    case 3:
      y = -this$static._speed * 0.800000011920929;
      this$static.state = 5;
      break;
    case 0:
      y = this$static._speed * 0.800000011920929;
      this$static.state = 0;
      break;
    case 1:
      x = -this$static._speed * 0.800000011920929;
      this$static.state = 3;
      break;
    case 2:
      x = this$static._speed * 0.800000011920929;
      this$static.state = 4;
  }
  $setLinearVelocity(this$static.body_0, new Vec2_1(x, y));
}

function $move_0(this$static, v){
  var actualPos, x, y;
  actualPos = new Vector2_0(this$static.x, this$static.y);
  x = 0;
  y = 0;
  if (actualPos.x != v.x)
    if (actualPos.x > v.x) {
      x = -this$static._speed * 0.800000011920929;
      this$static.state = 5;
    }
     else {
      x = this$static._speed * 0.800000011920929;
      this$static.state = 4;
    }
  if (actualPos.y != v.y)
    if (actualPos.y > v.y) {
      y = -this$static._speed * 0.800000011920929;
      this$static.state = 5;
    }
     else {
      y = this$static._speed * 0.800000011920929;
      this$static.state = 0;
    }
  $setLinearVelocity(this$static.body_0, new Vec2_1(x, y));
}

function $setCenter(this$static, pos){
  $setPosition_0(this$static, pos.x - 16, pos.y - 16);
}

function $setPosition_0(this$static, x, y){
  this$static.x = x;
  this$static.y = y;
  $setTransform(this$static.body_0, $getVec2($div(new Vector2_0(this$static.x, this$static.y), 100)));
}

function $update(this$static, delta){
  this$static._speed = this$static.speed * ~~(delta / 33);
  $setPosition(this$static, $toInt($mul(new Vector2_1(this$static.body_0.m_xf.p))));
  this$static.state == 2 && $setLinearVelocity(this$static.body_0, new Vec2_1(0, 0));
}

function DynamicPhysicsEntity_0(logicWorld, x, y, lives, speed, isSensor){
  this.x = this.originalX = x;
  this.y = this.originalY = y;
  this.lives = lives;
  this.logicWorld_1 = logicWorld;
  $add_0(logicWorld.entityEngine, this);
  this.logicWorld_0 = logicWorld;
  this.speed = this._speed = speed;
  this.isSensor = isSensor;
  $initBody(this);
}

function DynamicPhysicsEntity_1(logicWorld, pos, speed){
  DynamicPhysicsEntity_0.call(this, logicWorld, pos.x, pos.y, 1, speed, true);
}

defineSeed(12, 13, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity]));
_.getBody = function getBody(){
  return this.body_0;
}
;
_.reset = function reset_0(){
  $setPosition_0(this, this.originalX, this.originalY);
  this.state = 2;
  !this.body_0.m_fixtureList && $initBody(this);
}
;
_.setPosition = function setPosition_0(x, y){
  $setPosition_0(this, x, y);
}
;
_.update = function update(delta){
  $update(this, delta);
}
;
_._speed = 0;
_.body_0 = null;
_.height_0 = 0;
_.isSensor = false;
_.logicWorld_0 = null;
_.speed = 0;
_.width_0 = 0;
function $update_0(this$static, delta){
  this$static.contact && this$static.strategy.changeDirection();
  this$static.strategy.move();
  $update(this$static, delta);
}

function Enemy_0(logicWorld, c, speed, strategy){
  DynamicPhysicsEntity_1.call(this, logicWorld, new Vector2_0(round_int(c.x), round_int(c.y)), speed);
  this.strategy = strategy.setEntity(this);
}

defineSeed(11, 12, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener, Q$Enemy]));
_.contact_0 = function contact_0(other){
  instanceOf(other, Q$FireEntity)?this.die():instanceOf(other, Q$DynamicPhysicsEntity) && this.strategy.changeDirection();
}
;
_.release_0 = function release(other){
  instanceOf(other, Q$Enemy) && (this.contact = false);
}
;
_.update = function update_0(delta){
  $update_0(this, delta);
}
;
_.contact = false;
_.strategy = null;
defineSeed(10, 11, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener, Q$Enemy]));
_.die = function die_0(){
  $increaseScore(this.logicWorld, 500);
  $die(this);
}
;
_.logicWorld = null;
function $clinit_BaromDecorator(){
  $clinit_BaromDecorator = nullMethod;
  dying = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'baromDying'), false);
  idle = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'baromIdle'), true);
}

function BaromDecorator_0(d, c){
  $clinit_BaromDecorator();
  Enemy_0.call(this, d, c, 0.6000000238418579, new Strategy2_0);
  this.logicWorld = d;
  this.decoratedWorld = d;
  this.sp = new SpritePlayer_0;
}

defineSeed(9, 10, makeCastMap([Q$DynamicPhysicsEntity, Q$Entity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener, Q$Enemy]), BaromDecorator_0);
_.destroy = function destroy_0(){
  this.state = 1;
  $removeEntity(this.logicWorld_1, this);
  $removeGfxObject(this.decoratedWorld, this);
}
;
_.die = function die_1(){
  this.dieTimer = 50;
}
;
_.drawSurface = function drawSurface(surface){
  $draw(this.sp, surface, $add_2(new Vector2_0(this.x, this.y), new Vector2_0(16, 32)));
}
;
_.paint = function paint(alpha){
}
;
_.update = function update_1(delta){
  switch (this.state) {
    case 1:
      this.currentSprite = dying;
      break;
    default:this.currentSprite = idle;
  }
  if (!this.currentSprite)
    throw new RuntimeException_0('Assets not initialized');
  if (this.dieTimer > 0) {
    --this.dieTimer;
    this.currentSprite = dying;
    this.dieTimer == 0 && ($increaseScore(this.logicWorld, 500) , $die(this));
  }
   else 
    $update_0(this, delta);
  $playAnimation(this.sp, delta, this.currentSprite);
}
;
_.currentSprite = null;
_.decoratedWorld = null;
_.dieTimer = 0;
_.sp = null;
var dying, idle;
function $clinit_BombDecorator(){
  $clinit_BombDecorator = nullMethod;
  anim = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'bomb'), true);
}

function BombDecorator_0(b, d){
  $clinit_BombDecorator();
  this.bomb = b;
  this.decoratedWorld = d;
  this.sp = new SpritePlayer_0;
}

defineSeed(14, 1, {}, BombDecorator_0);
_.drawSurface = function drawSurface_0(surface){
  $draw(this.sp, surface, $getBottomCenter(this.bomb));
}
;
_.paint = function paint_0(alpha){
}
;
_.update = function update_2(delta){
  var timer;
  timer = this.bomb.bombTimer;
  timer < 0 && $removeGfxObject(this.decoratedWorld, this);
  $setFrameTime(anim, timer + delta);
  $playAnimation(this.sp, delta, anim);
}
;
_.bomb = null;
_.decoratedWorld = null;
_.sp = null;
var anim;
function $incrementBombRange(this$static, range){
  if (this$static.bombRange > 10 || range < 0 && this$static.bombRange == 1)
    return;
  this$static.bombRange += range;
}

function $placeBomb(this$static){
  var b, c;
  if (this$static.bombs > 0) {
    c = $getBlockAt(this$static.logicWorld, $add_1(new Vector2_0(this$static.x, this$static.y)));
    b = new Bomb_0(this$static.logicWorld, this$static, c, this$static.bombRange, this$static.bombKick);
    c.b = b;
    --this$static.bombs;
    return b;
  }
  return null;
}

function $removeBomb(this$static){
  if (this$static.bombs == 1)
    return;
  --this$static.bombs;
}

defineSeed(16, 12, makeCastMap([Q$Bomber, Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener]));
_.contact_0 = function contact_1(other){
  var x;
  if (instanceOf(other, Q$Enemy) || instanceOf(other, Q$FireEntity))
    this.die();
  else if (instanceOf(other, Q$PowerUp)) {
    x = other;
    x.apply_0(this);
  }
}
;
_.destroy = function destroy_1(){
  $lose(this.logicWorld.bomberman);
  this.state = 1;
  $removeEntity(this.logicWorld_1, this);
}
;
_.die = function die_2(){
  $increaseScore(this.logicWorld, -200);
  $die(this);
}
;
_.release_0 = function release_0(entityB){
}
;
_.bombKick = false;
_.bombPass = false;
_.bombRange = 1;
_.bombs = 1;
_.logicWorld = null;
function $clinit_BomberDecorator(){
  $clinit_BomberDecorator = nullMethod;
  down = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'bomberDown'), true);
  dying_0 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'bomberDying'), false);
  idle_0 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'bomberIdle'), false);
  left_0 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'bomberLeft'), true);
  right_0 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'bomberRight'), true);
  up = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'bomberUp'), true);
}

function $onKeyDown_0(this$static, event_0){
  switch (event_0.key_0.ordinal) {
    case 98:
      $placeBomb_0(this$static);
      break;
    case 111:
      $add_10(this$static.moves, ($clinit_Direction() , LEFT));
      break;
    case 115:
      $add_10(this$static.moves, ($clinit_Direction() , UP));
      break;
    case 114:
      $add_10(this$static.moves, ($clinit_Direction() , RIGHT));
      break;
    case 108:
      $add_10(this$static.moves, ($clinit_Direction() , DOWN));
      break;
    case 121:
      $clear(this$static.moves.arrayList);
    default:this$static.state = 2;
  }
}

function $onKeyUp_0(this$static, event_0){
  switch (event_0.key_0.ordinal) {
    case 111:
      while ($contains_3(this$static.moves, ($clinit_Direction() , LEFT)))
        $remove_1(this$static.moves, LEFT);
      break;
    case 115:
      while ($contains_3(this$static.moves, ($clinit_Direction() , UP)))
        $remove_1(this$static.moves, UP);
      break;
    case 114:
      while ($contains_3(this$static.moves, ($clinit_Direction() , RIGHT)))
        $remove_1(this$static.moves, RIGHT);
      break;
    case 108:
      while ($contains_3(this$static.moves, ($clinit_Direction() , DOWN)))
        $remove_1(this$static.moves, DOWN);
  }
  if (this$static.moves.arrayList.size == 0) {
    this$static.state = 2;
    return;
  }
}

function $onPointerStart_0(this$static, event_0){
  $move_0(this$static, new Vector2_0(event_0.localX, event_0.localY));
}

function $placeBomb_0(this$static){
  var b;
  b = $placeBomb(this$static);
  if (b) {
    $addBomb(this$static.decoratedWorld, b);
    return b;
  }
  return null;
}

function $reset(this$static){
  $clear(this$static.moves.arrayList);
  $setPosition_0(this$static, this$static.originalX, this$static.originalY);
  this$static.state = 2;
  !this$static.body_0.m_fixtureList && $initBody(this$static);
}

function BomberDecorator_0(d){
  $clinit_BomberDecorator();
  DynamicPhysicsEntity_0.call(this, d, 32, 32, 3, 1, false);
  this.logicWorld = d;
  this.sp = new SpritePlayer_0;
  this.decoratedWorld = d;
  this.moves = new Stack_0;
  this.currentSprite = idle_0;
}

defineSeed(15, 16, makeCastMap([Q$Bomber, Q$DynamicPhysicsEntity, Q$Entity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener, Q$Keyboard$Listener, Q$Pointer$Listener]), BomberDecorator_0);
_.destroy = function destroy_2(){
  $lose(this.logicWorld.bomberman);
  this.state = 1;
  $removeEntity(this.logicWorld_1, this);
  $removeGfxObject(this.decoratedWorld, this);
}
;
_.die = function die_3(){
  this.dieTimer = 50;
}
;
_.drawSurface = function drawSurface_1(surface){
  $draw_0(this.sp, surface, $add_2(new Vector2_0(this.x, this.y), new Vector2_0(16, 32)));
}
;
_.onKeyDown = function onKeyDown_0(event_0){
  $onKeyDown_0(this, event_0);
}
;
_.onKeyTyped = function onKeyTyped_0(event_0){
}
;
_.onKeyUp = function onKeyUp_0(event_0){
  $onKeyUp_0(this, event_0);
}
;
_.onPointerDrag = function onPointerDrag_0(event_0){
}
;
_.onPointerEnd = function onPointerEnd_0(event_0){
}
;
_.onPointerStart = function onPointerStart_0(event_0){
  $onPointerStart_0(this, event_0);
}
;
_.paint = function paint_1(alpha){
}
;
_.reset = function reset_1(){
  $reset(this);
}
;
_.update = function update_3(delta){
  this.moves.arrayList.size == 0 || $move(this, $peek(this.moves));
  switch (this.state) {
    case 5:
      this.currentSprite = up;
      break;
    case 0:
      this.currentSprite = down;
      break;
    case 3:
      this.currentSprite = left_0;
      break;
    case 4:
      this.currentSprite = right_0;
      break;
    case 1:
      this.currentSprite = dying_0;
      break;
    case 2:
      this.currentSprite = idle_0;
  }
  if (!this.currentSprite)
    throw new RuntimeException_0('Assets not initialized');
  if (this.dieTimer > 0) {
    --this.dieTimer;
    this.currentSprite = dying_0;
    this.dieTimer == 0 && ($increaseScore(this.logicWorld, -200) , $die(this));
  }
   else 
    $update(this, delta);
  $playAnimation(this.sp, delta, this.currentSprite);
}
;
_.currentSprite = null;
_.decoratedWorld = null;
_.dieTimer = 0;
_.moves = null;
_.sp = null;
var down, dying_0, idle_0, left_0, right_0, up;
function $add(this$static, o){
  $add_10(this$static.gfxToAdd, o);
}

function $clearAll(this$static){
  $clear(this$static.gfxToAdd.arrayList);
  $clear(this$static.gfxToRemove.arrayList);
  $clear_2(this$static.gfxObjs);
}

function $doAdd(this$static){
  while (this$static.gfxToAdd.arrayList.size != 0)
    $addFirst(this$static.gfxObjs, $pop(this$static.gfxToAdd));
}

function $doRemove(this$static){
  while (this$static.gfxToRemove.arrayList.size != 0)
    $remove_1(this$static.gfxObjs, $pop(this$static.gfxToRemove));
}

function $drawSurface(this$static, surface){
  var x, x$iterator;
  for (x$iterator = $listIterator(this$static.gfxObjs, 0); x$iterator.currentNode != x$iterator.this$0.header;) {
    x = $next_3(x$iterator);
    x.drawSurface(surface);
  }
}

function $loadAssets(this$static, a){
  var image, images, x, x$index, x$max;
  images = ($clinit_Constants() , TEXTURES);
  for (x$index = 0 , x$max = images.length; x$index < x$max; ++x$index) {
    x = images[x$index];
    image = $getImage(platform_1.assets, $get_4((!instance && (instance = new PropertiesManager_0(null)) , instance).settings, x), ($clinit_Scale() , ONE_0));
    ++a.total;
    $addCallback_0(image, a.callback);
    $put_2(this$static.textureMap, x, image);
  }
}

function $paint(this$static, alpha){
  var x, x$iterator;
  for (x$iterator = $listIterator(this$static.gfxObjs, 0); x$iterator.currentNode != x$iterator.this$0.header;) {
    x = $next_3(x$iterator);
    x.paint(alpha);
  }
}

function $remove(this$static, o){
  $add_10(this$static.gfxToRemove, o);
}

function $update_1(this$static, delta){
  var x, x$iterator;
  $doAdd(this$static);
  $doRemove(this$static);
  for (x$iterator = $listIterator(this$static.gfxObjs, 0); x$iterator.currentNode != x$iterator.this$0.header;) {
    x = $next_3(x$iterator);
    instanceOf(x, Q$Entity) || x.update(delta);
  }
}

function DecoratedEntityEngine_0(){
  this.gfxObjs = new LinkedList_0;
  this.gfxToAdd = new Stack_0;
  this.gfxToRemove = new Stack_0;
  this.textureMap = new HashMap_0;
}

defineSeed(17, 1, {}, DecoratedEntityEngine_0);
var instance_0 = null;
function $addEntity(this$static, e){
  $add_0(this$static.entityEngine, e);
}

function $getAdjacent(this$static, c){
  var $e0, coords, set, x, y;
  set = new ArrayList_0;
  try {
    coords = $getCoordinate(this$static, c);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$RuntimeException)) {
      coords = $getCoordinate(this$static, $getBlockAt(this$static, $add_2($div(new Vector2_0(c.width_0, c.heigth), 2), $getPosition(c))));
    }
     else 
      throw $e0;
  }
  for (x = coords.x - 1; x <= coords.x + 1; ++x)
    for (y = coords.y - 1; y <= coords.y + 1; ++y)
      x > 0 && x < this$static.x && y > 0 && y < this$static.y && (x == coords.x || y == coords.y) && $add_4(set, this$static.grid[x][y]);
  return set;
}

function $getBlockAt(this$static, v){
  var j, j$array, j$index, j$max, y, y$index, y$max;
  for (j$array = this$static.grid , j$index = 0 , j$max = j$array.length; j$index < j$max; ++j$index) {
    j = j$array[j$index];
    for (y$index = 0 , y$max = j.length; y$index < y$max; ++y$index) {
      y = j[y$index];
      if (v.x >= y.x && v.x < y.x + y.width_0 && v.y >= y.y && v.y < y.y + y.heigth)
        return y;
    }
  }
  return null;
}

function $getBorderBlocks(this$static){
  var set, x, y;
  set = new HashSet_0;
  for (x = 0; x < this$static.x; ++x)
    for (y = 0; y < this$static.y; ++y)
      (x == 0 || x == this$static.x - 1 || y == 0 || y == this$static.y - 1) && $add_8(set, this$static.grid[x][y]);
  return set;
}

--></script>
<script><!--
function $getCoordinate(this$static, c){
  var target, x, y;
  for (x = 0; x < this$static.x; ++x)
    for (y = 0; y < this$static.y; ++y) {
      target = this$static.grid[x][y];
      if (target == c)
        return new LogicWorld$Coordinate_0(x, y);
    }
  throw new RuntimeException_0('block not in grid');
}

function $getFreeAdjacent(this$static, c){
  var res, x, x$iterator;
  res = new ArrayList_0;
  for (x$iterator = new AbstractList$IteratorImpl_0($getAdjacent(this$static, c)); x$iterator.i < x$iterator.this$0_0.size_0();) {
    x = $next_2(x$iterator);
    instanceOf(x, Q$FreeBlock) && (setCheck(res.array, res.size++, x) , true);
  }
  return res;
}

function $getRandomFreeBlock(this$static){
  var temp, x;
  if (this$static.freeGround.size < 1)
    throw new RuntimeException_0('no free blocks available');
  x = new Random_0;
  temp = $get_5(this$static.freeGround, $nextInt(x, this$static.freeGround.size));
  $remove_1(this$static.freeGround, temp);
  return temp;
}

function $handleExplosion(this$static, bomb){
  var center, f, pos, range, res, x, y;
  res = new ArrayList_0;
  center = $getBlockAt(this$static, $add_1(new Vector2_0(bomb.x, bomb.y)));
  pos = $getCoordinate(this$static, center);
  range = bomb.range;
  for (x = pos.x; x >= pos.x - range; --x)
    if (0 < x && x < this$static.x) {
      f = $instanceAt(this$static, x, pos.y);
      if (!f)
        break;
      setCheck(res.array, res.size++, f);
      if (instanceOf(f, Q$PowerUp))
        break;
    }
  for (x = pos.x + 1; x <= pos.x + range; ++x)
    if (0 < x && x < this$static.x) {
      f = $instanceAt(this$static, x, pos.y);
      if (!f)
        break;
      setCheck(res.array, res.size++, f);
      if (instanceOf(f, Q$PowerUp))
        break;
    }
  for (y = pos.y - 1; y >= pos.y - range; --y)
    if (0 < y && y < this$static.y) {
      f = $instanceAt(this$static, pos.x, y);
      if (!f)
        break;
      setCheck(res.array, res.size++, f);
      if (instanceOf(f, Q$PowerUp))
        break;
    }
  for (y = pos.y + 1; y <= pos.y + range; ++y)
    if (0 < y && y < this$static.y) {
      f = $instanceAt(this$static, pos.x, y);
      if (!f)
        break;
      setCheck(res.array, res.size++, f);
      if (instanceOf(f, Q$PowerUp))
        break;
    }
  return res;
}

function $increaseScore(this$static, v){
  $increaseScore_0(this$static.scoreManager, v);
}

function $initGrid(this$static, x, y){
  var cm, j, k, temp;
  for (j = 0; j < x; ++j)
    for (k = 0; k < y; ++k)
      if (k == 0 || k == y - 1 || j == 0 || j == x - 1 || j % 2 == 0 && k % 2 == 0) {
        cm = new WallBlock_0(j * this$static.size, k * this$static.size, this$static.size, this$static);
        setCheck(this$static.grid[j], k, cm);
        $add_4(this$static.staticGround, cm);
      }
       else {
        temp = new FreeBlock_0(j * this$static.size, k * this$static.size, this$static.size, this$static);
        setCheck(this$static.grid[j], k, temp);
        j > 2 && k > 2 && $add_9(this$static.freeGround, temp);
      }
}

function $initializeGame(this$static, blocks){
  var b, b$iterator;
  this$static.timer = new Timer_0;
  this$static.grid = initDims([_3_3Lbomberman_core_logic_Block_2_classLit, _3Lbomberman_core_logic_Block_2_classLit], [makeCastMap([Q$Serializable, Q$Object_$1]), makeCastMap([Q$Block_$1, Q$PhysicsEntity_$1, Q$Serializable, Q$Object_$1])], [Q$Block_$1, Q$Block], [this$static.x, this$static.y], 2, 0);
  for (b$iterator = new AbstractList$IteratorImpl_0($getBombs(this$static.entityEngine)); b$iterator.i < b$iterator.this$0_0.size_0();) {
    b = $next_2(b$iterator);
    ++b.caller_0.bombs;
    $destroy(b);
  }
  $removeAll(this$static.entityEngine);
  $clearWorld(this$static.entityEngine);
  this$static.dynamicGround = new LinkedList_0;
  this$static.staticGround = new ArrayList_0;
  this$static.freeGround = new LinkedList_0;
  $initGrid(this$static, this$static.x, this$static.y);
  $placeBloks(this$static, blocks);
}

function $instanceAt(this$static, x, y){
  var $e0, c, e, p;
  c = this$static.grid[x][y];
  setCheck(this$static.grid[x], y, c.destroy_0());
  $remove_1(this$static.dynamicGround, c);
  if (instanceOf(c, Q$FreeBlock))
    return new FireEntity_0(this$static, c);
  else if (instanceOf(c, Q$BrickBlock) && !!c.powerUp) {
    this$static.scoreManager.score += 50;
    try {
      p = null;
      switch (c.powerUp.ordinal) {
        case 0:
          p = new PowerUpBombKick_0(this$static, c);
          break;
        case 1:
          p = new PowerUpBombPass_0(this$static, c);
          break;
        case 2:
          p = new PowerUpBombRangeDown_0(this$static, c);
          break;
        case 3:
          p = new PowerUpBombRangeUp_0(this$static, c);
          break;
        case 4:
          p = new PowerUpBomb_0(this$static, c);
          break;
        case 5:
          p = new Door_0(this$static, c);
          break;
        case 6:
          p = new PowerUpLife_0(this$static, c);
          break;
        case 8:
          p = new PowerUpSkull_0(this$static, c);
          break;
        case 9:
          p = new PowerUpSpeedDown_0(this$static, c);
          break;
        case 10:
          p = new PowerUpSpeedUp_0(this$static, c);
          break;
        case 11:
          p = new PowerUpTimeDown_0(this$static, c);
          break;
        case 12:
          p = new PowerUpTimeUp_0(this$static, c);
      }
      !!p && $add_0(this$static.entityEngine, p);
      return p;
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$Exception)) {
        e = $e0;
        $printStackTrace(e);
      }
       else 
        throw $e0;
    }
  }
  return null;
}

function $placeBloks(this$static, n){
  var a, b, cm, count, powerUp, rad, rand, v, x, x$array, x$index, x$max;
  count = n;
  rad = new Random_0;
  while (count > 0) {
    a = $nextInt(new Random_0, this$static.x - 1);
    b = $nextInt(new Random_0, this$static.y - 1);
    if (instanceOf(this$static.grid[a][b], Q$FreeBlock) && !(a < 3 && b < 3)) {
      $remove_1(this$static.freeGround, this$static.grid[a][b]);
      rand = $nextInternal(rad, 26) * 1.4901161193847656E-8 + $nextInternal(rad, 27) * 1.1102230246251565E-16;
      v = 0;
      powerUp = null;
      for (x$array = ($clinit_PowerUpEnum() , $clinit_PowerUpEnum() , $VALUES_0) , x$index = 0 , x$max = x$array.length; x$index < x$max; ++x$index) {
        x = x$array[x$index];
        powerUp = x;
        v += x.probability;
        if (v > rand)
          break;
      }
      --count == 1 && (powerUp = DOOR);
      cm = new BrickBlock_0(powerUp, a * this$static.size, b * this$static.size, this$static.size, this$static);
      setCheck(this$static.grid[a], b, cm);
      $add_9(this$static.dynamicGround, cm);
    }
  }
}

function $removeEntity(this$static, e){
  $remove_0(this$static.entityEngine, e);
}

defineSeed(19, 1, {});
_.dynamicGround = null;
_.freeGround = null;
_.grid = null;
_.scoreManager = null;
_.size = 0;
_.staticGround = null;
_.timer = null;
_.x = 0;
_.y = 0;
function $addBomb(this$static, b){
  var bd;
  bd = new BombDecorator_0(b, this$static);
  $add(this$static.decoratedEntityEngine, bd);
}

function $addGfxObject(this$static, o){
  $add(this$static.decoratedEntityEngine, o);
}

function $drawStaticGround(this$static){
  var x, x$iterator;
  this$static.surfaceStatic = platform_1.graphics.createSurface(platform_1.graphics.width_2(), platform_1.graphics.height_2());
  this$static.staticGroundLayer = platform_1.graphics.createImageLayer(this$static.surfaceStatic);
  for (x$iterator = new AbstractList$IteratorImpl_0(this$static.staticGround); x$iterator.i < x$iterator.this$0_0.size_0();) {
    x = $next_2(x$iterator);
    this$static.surfaceStatic.surface_0().drawImage_2(this$static.staticGroundImage, (new Vector2_0(round_int(x.x), round_int(x.y))).x, (new Vector2_0(round_int(x.x), round_int(x.y))).y, 32, 32);
  }
}

function $drawSurface_0(this$static, surface){
  $drawSurface(this$static.decoratedEntityEngine, surface);
}

function $handleExplosion_0(this$static, b){
  var f, f$iterator, res;
  $play_0(this$static.bomb);
  res = $handleExplosion(this$static, b);
  for (f$iterator = new AbstractList$IteratorImpl_0(res); f$iterator.i < f$iterator.this$0_0.size_0();) {
    f = $next_2(f$iterator);
    instanceOf(f, Q$FireEntity)?$addGfxObject(this$static, new FireDecorator_0(f, this$static)):instanceOf(f, Q$PowerUp) && $addGfxObject(this$static, new PowerUpDecorator_0(this$static, f));
  }
  $updateDynamicGround(this$static);
  return res;
}

function $initDynamicGround(this$static){
  var c, c$iterator, res;
  res = new ArrayList_0;
  for (c$iterator = $listIterator(this$static.dynamicGround, 0); c$iterator.currentNode != c$iterator.this$0.header;) {
    c = $next_3(c$iterator);
    $add_4(res, new DynamicBlockDecorator_0(this$static, c));
  }
  this$static.surfaceDynamic = platform_1.graphics.createSurface(platform_1.graphics.width_2(), platform_1.graphics.height_2());
  this$static.dynamicGroundLayer = platform_1.graphics.createImageLayer(this$static.surfaceDynamic);
  return res;
}

function $initializeGame_0(this$static, blocks){
  $clearAll(this$static.decoratedEntityEngine);
  $initializeGame(this$static, blocks);
  this$static.dynamicGroundDecorators = $initDynamicGround(this$static);
}

function $loadAssets_0(this$static, a){
  this$static.bomb = $getSound(platform_1.assets, $get_4((!instance && (instance = new PropertiesManager_0(null)) , instance).settings, 'bombSound'));
  $add_14(a, this$static.bomb);
  this$static.staticGroundImage = $getImage(platform_1.assets, $get_4((!instance && (instance = new PropertiesManager_0(null)) , instance).settings, 'staticGroundImage'), ($clinit_Scale() , ONE_0));
  $add_13(a, this$static.staticGroundImage);
  $loadAssets(this$static.decoratedEntityEngine, a);
}

function $paint_0(this$static, alpha){
  $paint(this$static.decoratedEntityEngine, alpha);
}

function $removeGfxObject(this$static, o){
  $remove(this$static.decoratedEntityEngine, o);
}

function $show(this$static){
  $drawStaticGround(this$static);
  $updateDynamicGround(this$static);
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).groundLayer.add_1(this$static.staticGroundLayer);
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).groundLayer.add_1(this$static.dynamicGroundLayer);
}

function $update_2(this$static, delta){
  $update_3(this$static.entityEngine, delta);
  $update_5(this$static.timer, delta);
  round_int(this$static.timer.time) < 0 && $lose(this$static.bomberman);
  $update_1(this$static.decoratedEntityEngine, delta);
}

function $updateDynamicGround(this$static){
  var b, b$iterator, current, newList, x, x$iterator;
  newList = new ArrayList_1(this$static.dynamicGroundDecorators);
  current = this$static.dynamicGround;
  this$static.dynamicGroundDecorators.retainAll(current);
  $removeAll_0(newList, current);
  for (b$iterator = new AbstractList$IteratorImpl_0(newList); b$iterator.i < b$iterator.this$0_0.size_0();) {
    b = $next_2(b$iterator);
    $add(this$static.decoratedEntityEngine, b);
  }
  this$static.surfaceDynamic.surface_0().clear_2();
  for (x$iterator = new AbstractList$IteratorImpl_0(this$static.dynamicGroundDecorators); x$iterator.i < x$iterator.this$0_0.size_0();) {
    x = $next_2(x$iterator);
    x.drawSurface(this$static.surfaceDynamic.surface_0());
  }
}

function DecoratedWorld_0(bomberman){
  this.entityEngine = (!instance_2 && (instance_2 = new EntityEngine_0) , instance_2);
  this.size = 32;
  this.x = 19;
  this.y = 15;
  this.scoreManager = new ScoreManager_0;
  this.bomberman = bomberman;
  this.decoratedEntityEngine = (!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0);
  this.staticGroundLayer = platform_1.graphics.createGroupLayer();
}

defineSeed(18, 19, {}, DecoratedWorld_0);
_.bomb = null;
_.bomberman = null;
_.decoratedEntityEngine = null;
_.dynamicGroundDecorators = null;
_.dynamicGroundLayer = null;
_.staticGroundImage = null;
_.staticGroundLayer = null;
_.surfaceDynamic = null;
_.surfaceStatic = null;
function $clinit_DynamicBlockDecorator(){
  $clinit_DynamicBlockDecorator = nullMethod;
  anim_0 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'dynamicGroundImage'), false);
}

function DynamicBlockDecorator_0(d, c){
  $clinit_DynamicBlockDecorator();
  this.c = c;
  this.d = d;
  this.sp = new SpritePlayer_0;
  $playAnimation(this.sp, 0, anim_0);
}

defineSeed(20, 1, {}, DynamicBlockDecorator_0);
_.drawSurface = function drawSurface_2(surface){
  $draw_1(this.sp, surface, $getPosition(this.c), 32, 32);
}
;
_.equals$ = function equals_0(o){
  return instanceOf(o, Q$Block) && o == this.c;
}
;
_.paint = function paint_2(alpha){
}
;
_.update = function update_4(delta){
  this.sp.frameIndex == $frameCount(anim_0) && $removeGfxObject(this.d, this);
  $playAnimation(this.sp, delta, anim_0);
}
;
_.c = null;
_.d = null;
_.sp = null;
var anim_0;
function $destroy_0(this$static){
  $destroy(this$static.fire);
  $removeGfxObject(this$static.decoratedWorld, this$static);
}

function FireDecorator_0(f, d){
  this.anim = new Sprite_1($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'fire'), new FireDecorator$1_0(this));
  this.fire = f;
  this.sp = new SpritePlayer_0;
  this.decoratedWorld = d;
}

defineSeed(21, 1, {}, FireDecorator_0);
_.drawSurface = function drawSurface_3(surface){
  $draw(this.sp, surface, $getBottomCenter(this.fire));
}
;
_.paint = function paint_3(alpha){
}
;
_.update = function update_5(delta){
  $playAnimation(this.sp, delta, this.anim);
}
;
_.decoratedWorld = null;
_.fire = null;
_.sp = null;
function FireDecorator$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(22, 1, {}, FireDecorator$1_0);
_.this$0 = null;
function LayerManager_0(){
  this.backgroundLayer = platform_1.graphics.createGroupLayer();
  this.groundLayer = platform_1.graphics.createGroupLayer();
  this.foregroundLayer = platform_1.graphics.createGroupLayer();
  this.immediateLayer = platform_1.graphics.createGroupLayer();
  this.overlayLayer = platform_1.graphics.createGroupLayer();
  platform_1.graphics.rootLayer_0().add_1(this.backgroundLayer);
  platform_1.graphics.rootLayer_0().add_1(this.groundLayer);
  platform_1.graphics.rootLayer_0().add_1(this.foregroundLayer);
  platform_1.graphics.rootLayer_0().add_1(this.immediateLayer);
  platform_1.graphics.rootLayer_0().add_1(this.overlayLayer);
}

function clear(){
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).backgroundLayer.clear_0();
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).foregroundLayer.clear_0();
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).groundLayer.clear_0();
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).overlayLayer.clear_0();
}

defineSeed(23, 1, {}, LayerManager_0);
_.backgroundLayer = null;
_.foregroundLayer = null;
_.groundLayer = null;
_.immediateLayer = null;
_.overlayLayer = null;
var instance_1 = null;
defineSeed(25, 11, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener, Q$Enemy]));
_.die = function die_4(){
  $increaseScore(this.logicWorld, 700);
  $die(this);
}
;
_.logicWorld = null;
function $clinit_MaronDecorator(){
  $clinit_MaronDecorator = nullMethod;
  dying_1 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'maronDying'), false);
  idle_1 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'maronIdle'), true);
}

function MaronDecorator_0(d, c){
  $clinit_MaronDecorator();
  Enemy_0.call(this, d, c, 1, new Strategy2_0);
  this.logicWorld = d;
  this.decoratedWorld = d;
  this.sp = new SpritePlayer_0;
}

defineSeed(24, 25, makeCastMap([Q$DynamicPhysicsEntity, Q$Entity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener, Q$Enemy]), MaronDecorator_0);
_.destroy = function destroy_3(){
  this.state = 1;
  $removeEntity(this.logicWorld_1, this);
  $removeGfxObject(this.decoratedWorld, this);
}
;
_.die = function die_5(){
  this.dieTimer = 50;
}
;
_.drawSurface = function drawSurface_4(surface){
  $draw(this.sp, surface, $add_2(new Vector2_0(this.x, this.y), new Vector2_0(16, 32)));
}
;
_.paint = function paint_4(alpha){
}
;
_.update = function update_6(delta){
  switch (this.state) {
    case 1:
      this.currentSprite = dying_1;
      break;
    default:this.currentSprite = idle_1;
  }
  if (!this.currentSprite)
    throw new RuntimeException_0('Assets not initialized');
  if (this.dieTimer > 0) {
    --this.dieTimer;
    this.currentSprite = dying_1;
    this.dieTimer == 0 && ($increaseScore(this.logicWorld, 700) , $die(this));
  }
   else 
    $update_0(this, delta);
  $playAnimation(this.sp, delta, this.currentSprite);
}
;
_.currentSprite = null;
_.decoratedWorld = null;
_.dieTimer = 0;
_.sp = null;
var dying_1, idle_1;
defineSeed(27, 11, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener, Q$Enemy]));
_.die = function die_6(){
  $increaseScore(this.logicWorld, 300);
  $die(this);
}
;
_.logicWorld = null;
function $clinit_MinvoDecorator(){
  $clinit_MinvoDecorator = nullMethod;
  dying_2 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'minboDying'), false);
  idle_2 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'minboIdle'), true);
}

function MinvoDecorator_0(d, c){
  $clinit_MinvoDecorator();
  Enemy_0.call(this, d, c, 1, new Strategy1_0);
  this.logicWorld = d;
  this.decoratedWorld = d;
  this.sp = new SpritePlayer_0;
}

defineSeed(26, 27, makeCastMap([Q$DynamicPhysicsEntity, Q$Entity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener, Q$Enemy]), MinvoDecorator_0);
_.destroy = function destroy_4(){
  this.state = 1;
  $removeEntity(this.logicWorld_1, this);
  $removeGfxObject(this.decoratedWorld, this);
}
;
_.die = function die_7(){
  this.dieTimer = 50;
}
;
_.drawSurface = function drawSurface_5(surface){
  $draw(this.sp, surface, $add_2(new Vector2_0(this.x, this.y), new Vector2_0(16, 32)));
}
;
_.paint = function paint_5(alpha){
}
;
_.update = function update_7(delta){
  switch (this.state) {
    case 1:
      this.currentSprite = dying_2;
      break;
    default:this.currentSprite = idle_2;
  }
  if (!this.currentSprite)
    throw new RuntimeException_0('Assets not initialized');
  if (this.dieTimer > 0) {
    --this.dieTimer;
    this.currentSprite = dying_2;
    this.dieTimer == 0 && ($increaseScore(this.logicWorld, 300) , $die(this));
  }
   else 
    $update_0(this, delta);
  $playAnimation(this.sp, delta, this.currentSprite);
}
;
_.currentSprite = null;
_.decoratedWorld = null;
_.dieTimer = 0;
_.sp = null;
var dying_2, idle_2;
defineSeed(29, 11, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener, Q$Enemy]));
_.die = function die_8(){
  $increaseScore(this.logicWorld, 200);
  $die(this);
}
;
_.logicWorld = null;
function $clinit_OnilDecorator(){
  $clinit_OnilDecorator = nullMethod;
  dying_3 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'onilDying'), false);
  idle_3 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'onilIdle'), true);
}

function OnilDecorator_0(d, c){
  $clinit_OnilDecorator();
  Enemy_0.call(this, d, c, 0.6000000238418579, new Strategy1_0);
  this.logicWorld = d;
  this.decoratedWorld = d;
  this.sp = new SpritePlayer_0;
}

defineSeed(28, 29, makeCastMap([Q$DynamicPhysicsEntity, Q$Entity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener, Q$Enemy]), OnilDecorator_0);
_.destroy = function destroy_5(){
  this.state = 1;
  $removeEntity(this.logicWorld_1, this);
  $removeGfxObject(this.decoratedWorld, this);
}
;
_.die = function die_9(){
  this.dieTimer = 50;
}
;
_.drawSurface = function drawSurface_6(surface){
  $draw(this.sp, surface, $add_2(new Vector2_0(this.x, this.y), new Vector2_0(16, 32)));
}
;
_.paint = function paint_6(alpha){
}
;
_.update = function update_8(delta){
  switch (this.state) {
    case 1:
      this.currentSprite = dying_3;
      break;
    default:this.currentSprite = idle_3;
  }
  if (!this.currentSprite)
    throw new RuntimeException_0('Assets not initialized');
  if (this.dieTimer > 0) {
    --this.dieTimer;
    this.currentSprite = dying_3;
    this.dieTimer == 0 && ($increaseScore(this.logicWorld, 200) , $die(this));
  }
   else 
    $update_0(this, delta);
  $playAnimation(this.sp, delta, this.currentSprite);
}
;
_.currentSprite = null;
_.decoratedWorld = null;
_.dieTimer = 0;
_.sp = null;
var dying_3, idle_3;
defineSeed(31, 11, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener, Q$Enemy]));
_.die = function die_10(){
  $increaseScore(this.logicWorld, 250);
  $die(this);
}
;
_.logicWorld = null;
function $clinit_PontanDecorator(){
  $clinit_PontanDecorator = nullMethod;
  dying_4 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'pontanDying'), false);
  idle_4 = new Sprite_2($get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'pontanIdle'), true);
}

function PontanDecorator_0(d, c){
  $clinit_PontanDecorator();
  Enemy_0.call(this, d, c, 0.800000011920929, new Strategy1_0);
  this.logicWorld = d;
  this.decoratedWorld = d;
  this.sp = new SpritePlayer_0;
}

defineSeed(30, 31, makeCastMap([Q$DynamicPhysicsEntity, Q$Entity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener, Q$Enemy]), PontanDecorator_0);
_.destroy = function destroy_6(){
  this.state = 1;
  $removeEntity(this.logicWorld_1, this);
  $removeGfxObject(this.decoratedWorld, this);
}
;
_.die = function die_11(){
  this.dieTimer = 50;
}
;
_.drawSurface = function drawSurface_7(surface){
  $draw(this.sp, surface, $add_2(new Vector2_0(this.x, this.y), new Vector2_0(16, 32)));
}
;
_.paint = function paint_7(alpha){
}
;
_.update = function update_9(delta){
  switch (this.state) {
    case 1:
      this.currentSprite = dying_4;
      break;
    default:this.currentSprite = idle_4;
  }
  if (!this.currentSprite)
    throw new RuntimeException_0('Assets not initialized');
  if (this.dieTimer > 0) {
    --this.dieTimer;
    this.currentSprite = dying_4;
    this.dieTimer == 0 && ($increaseScore(this.logicWorld, 250) , $die(this));
  }
   else 
    $update_0(this, delta);
  $playAnimation(this.sp, delta, this.currentSprite);
}
;
_.currentSprite = null;
_.decoratedWorld = null;
_.dieTimer = 0;
_.sp = null;
var dying_4, idle_4;
function PowerUpDecorator_0(d, p){
  var image1;
  this.d = d;
  this.p = p;
  this.sp = new SpritePlayer_0;
  instanceOf(p, Q$Door)?(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'Door')):instanceOf(p, Q$PowerUpBomb)?(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'PowerUpBomb')):instanceOf(p, Q$PowerUpBombKick)?(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'PowerUpBombKick')):instanceOf(p, Q$PowerUpBombPass)?(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'PowerUpBombPass')):instanceOf(p, Q$PowerUpBombRangeDown)?(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'PowerUpBombRangeDown')):instanceOf(p, Q$PowerUpBombRangeUp)?(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'PowerUpBombRangeUp')):instanceOf(p, Q$PowerUpLife)?(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'PowerUpLife')):instanceOf(p, Q$PowerUpSkull)?(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'PowerUpSkull')):instanceOf(p, Q$PowerUpSpeedUp)?(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'PowerUpSpeedUp')):instanceOf(p, Q$PowerUpSpeedDown)?(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'PowerUpSpeedDown')):instanceOf(p, Q$PowerUpTimeDown)?(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'PowerUpTimeDown')):instanceOf(p, Q$PowerUpTimeUp)?(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'PowerUpTimeUp')):(image1 = $get_4((!instance_0 && (instance_0 = new DecoratedEntityEngine_0) , instance_0).textureMap, 'PowerUpBomb'));
  this.image = new Sprite_2(image1, true);
}

defineSeed(32, 1, {}, PowerUpDecorator_0);
_.drawSurface = function drawSurface_8(surface){
  $draw(this.sp, surface, $getBottomCenter(this.p));
}
;
_.paint = function paint_8(alpha){
}
;
_.update = function update_10(delta){
  $playAnimation(this.sp, delta, this.image);
  this.p.timer < 0 && $removeGfxObject(this.d, this);
}
;
_.d = null;
_.image = null;
_.p = null;
_.sp = null;
function $frameCount(this$static){
  return round_int(this$static.texture.width_1() / round_int(this$static.texture.height_1()));
}

function $setFrameTime(this$static, t){
  this$static.frameTime = t;
}

function Sprite_0(texture, isLooping, callback){
  this.callback = callback;
  this.texture = texture;
  this.frameTime = 130;
  this.isLooping = isLooping;
}

function Sprite_1(texture, callback){
  Sprite_0.call(this, texture, false, callback);
}

function Sprite_2(texture, isLooping){
  Sprite_0.call(this, texture, isLooping, null);
}

defineSeed(33, 1, {}, Sprite_1, Sprite_2);
_.callback = null;
_.frameTime = 0;
_.isLooping = false;
_.texture = null;
function $draw(this$static, surf, position){
  if (!this$static.sprite)
    return;
  surf.drawImage_3(this$static.sprite.texture, position.x - round_int(this$static.sprite.texture.height_1()) / 2, position.y - round_int(this$static.sprite.texture.height_1()), round_int(this$static.sprite.texture.height_1()), round_int(this$static.sprite.texture.height_1()), this$static.frameIndex * round_int(this$static.sprite.texture.height_1()), 0, round_int(this$static.sprite.texture.height_1()), round_int(this$static.sprite.texture.height_1()));
}

function $draw_0(this$static, surface, position){
  if (!this$static.sprite)
    return;
  surface.drawImage_3(this$static.sprite.texture, position.x - 16, position.y - 32, 32, 32, this$static.frameIndex * round_int(this$static.sprite.texture.height_1()), 0, round_int(this$static.sprite.texture.height_1()), round_int(this$static.sprite.texture.height_1()));
}

function $draw_1(this$static, surf, position, fixedSquareSize, fixedSquareSize2){
  if (!this$static.sprite)
    throw new RuntimeException_0('No animation is currently playing.');
  surf.drawImage_3(this$static.sprite.texture, position.x, position.y, fixedSquareSize, fixedSquareSize2, this$static.frameIndex * round_int(this$static.sprite.texture.height_1()), 0, round_int(this$static.sprite.texture.height_1()), round_int(this$static.sprite.texture.height_1()));
}

function $playAnimation(this$static, gameTime, animation){
  if (this$static.sprite == animation) {
    this$static.time += gameTime;
    while (this$static.time > this$static.sprite.frameTime) {
      this$static.time -= this$static.sprite.frameTime;
      this$static.sprite.isLooping?(this$static.frameIndex = (this$static.frameIndex + 1) % $frameCount(this$static.sprite)):(this$static.frameIndex = this$static.frameIndex + 1 < $frameCount(this$static.sprite) - 1?this$static.frameIndex + 1:$frameCount(this$static.sprite) - 1);
      if (this$static.frameIndex == $frameCount(this$static.sprite) - 1) {
        if (this$static.completed && !!this$static.sprite.callback) {
          $destroy_0(this$static.sprite.callback.this$0);
          break;
        }
        this$static.completed = true;
      }
    }
    return;
  }
  this$static.sprite = animation;
  this$static.frameIndex = 0;
  this$static.time = 0;
  this$static.completed = false;
}

function SpritePlayer_0(){
}

defineSeed(34, 1, {}, SpritePlayer_0);
_.completed = false;
_.frameIndex = 0;
_.sprite = null;
_.time = 0;
function $contains(this$static, d){
  return $contains_0(this$static, new Vector2_0(d.x, d.y)) && $contains_0(this$static, $add_2(new Vector2_0(d.x, d.y), new Vector2_0(d.width_0, d.height_0)));
}

function $contains_0(this$static, v){
  return v.x >= this$static.x && v.x < this$static.x + this$static.width_0 && v.y >= this$static.y && v.y < this$static.y + this$static.heigth;
}

function $getPosition(this$static){
  return new Vector2_0(round_int(this$static.x), round_int(this$static.y));
}

function Block_0(x, y, width, height, nullBody, world){
  var bd, ps, fd;
  this.x = x;
  this.y = y;
  this.width_0 = width;
  this.heigth = height;
  this.logicWorld_0 = world;
  nullBody || (bd = new BodyDef_0 , bd.type_0 = ($clinit_BodyType() , STATIC_0) , $set_11(bd.position_0, this.x / 100, this.y / 100) , ps = new PolygonShape_0 , $setAsBox(ps, this.width_0 / 2 / 100, this.heigth / 2 / 100) , fd = new FixtureDef_0 , fd.shape = ps , this.body_0 = $createBody(this.logicWorld_0.entityEngine.world, bd) , $createFixture(this.body_0, fd) , undefined);
}

defineSeed(35, 1, makeCastMap([Q$Block, Q$PhysicsEntity]));
_.getBody = function getBody_0(){
  return this.body_0;
}
;
_.b = null;
_.body_0 = null;
_.heigth = 0;
_.logicWorld_0 = null;
_.width_0 = 0;
_.x = 0;
_.y = 0;
--></script>
<script><!--
function Bomb_0(logicWorld, bomber, c, bombRange, bombKick){
  DynamicPhysicsEntity_0.call(this, logicWorld, (new Vector2_0(round_int(c.x), round_int(c.y))).x, (new Vector2_0(round_int(c.x), round_int(c.y))).y, 0, 0, true);
  $setCenter(this, $add_2($div(new Vector2_0(c.width_0, c.heigth), 2), new Vector2_0(round_int(c.x), round_int(c.y))));
  $setType(this.body_0, ($clinit_BodyType() , KINEMATIC));
  this.body_0.m_linearDamping = 0;
  this.range = bombRange;
  this.caller_0 = bomber;
  this.bombTimer = 70;
  this.logicWorld = logicWorld;
  $setType(this.body_0, bombKick?DYNAMIC:STATIC_0);
}

defineSeed(36, 12, makeCastMap([Q$Bomb, Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PhysicsEntity$HasContactListener]), Bomb_0);
_.contact_0 = function contact_2(other){
  instanceOf(other, Q$FireEntity) && (this.bombTimer = 0);
}
;
_.destroy = function destroy_7(){
  ++this.caller_0.bombs;
  this.state = 1;
  $removeEntity(this.logicWorld_1, this);
}
;
_.release_0 = function release_1(entityB){
  instanceOf(entityB, Q$Bomber) && !this.caller_0.bombPass && $setSensor(this.body_0.m_fixtureList, false);
}
;
_.update = function update_11(delta){
  if (this.bombTimer-- < 0) {
    $handleExplosion_0(this.logicWorld, this);
    ++this.caller_0.bombs;
    this.state = 1;
    $removeEntity(this.logicWorld_1, this);
  }
  $setPosition(this, $toInt($mul(new Vector2_1(this.body_0.m_xf.p))));
}
;
_.bombTimer = 0;
_.caller_0 = null;
_.logicWorld = null;
_.range = 0;
function BrickBlock_0(power, posX, posY, dimension, logicWorld){
  Block_0.call(this, posX, posY, dimension, dimension, false, logicWorld);
  this.powerUp = power;
  this.logicWorld = logicWorld;
}

defineSeed(37, 35, makeCastMap([Q$Block, Q$BrickBlock, Q$PhysicsEntity]), BrickBlock_0);
_.destroy_0 = function destroy_8(){
  $destroyBody(this.body_0.m_world, this.body_0);
  return new FreeBlock_0((new Vector2_0(round_int(this.x), round_int(this.y))).x, (new Vector2_0(round_int(this.x), round_int(this.y))).y, (new Vector2_0(this.width_0, this.heigth)).x, this.logicWorld);
}
;
_.logicWorld = null;
_.powerUp = null;
function Enum_0(name_0, ordinal){
  this.name_1 = name_0;
  this.ordinal = ordinal;
}

defineSeed(39, 1, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum]));
_.compareTo$ = function compareTo(other){
  return this.ordinal - other.ordinal;
}
;
_.equals$ = function equals_1(other){
  return this === other;
}
;
_.hashCode$ = function hashCode_1(){
  return getHashCode(this);
}
;
_.toString$ = function toString_1(){
  return this.name_1;
}
;
_.name_1 = null;
_.ordinal = 0;
function $clinit_Direction(){
  $clinit_Direction = nullMethod;
  DOWN = new Direction_0('DOWN', 0);
  LEFT = new Direction_0('LEFT', 1);
  RIGHT = new Direction_0('RIGHT', 2);
  UP = new Direction_0('UP', 3);
  $VALUES = initValues(_3Lbomberman_core_logic_Direction_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Direction, [DOWN, LEFT, RIGHT, UP]);
}

function Direction_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_0(){
  $clinit_Direction();
  return $VALUES;
}

defineSeed(38, 39, makeCastMap([Q$Direction, Q$Serializable, Q$Comparable, Q$Enum]), Direction_0);
var $VALUES, DOWN, LEFT, RIGHT, UP;
function $add_0(this$static, entity){
  $add_10(this$static.entitiesToAdd, entity);
}

function $clearWorld(this$static){
  var temp;
  temp = this$static.world.m_bodyList;
  while (temp) {
    $destroyBody(this$static.world, temp);
    temp = temp.m_next;
  }
}

function $doAdd_0(this$static, entity){
  var physicsEntity;
  $add_4(this$static.entities, entity);
  if (instanceOf(entity, Q$PhysicsEntity)) {
    physicsEntity = entity;
    $put_2(this$static.bodyEntityLUT, physicsEntity.getBody(), physicsEntity);
  }
}

function $doRemove_0(this$static, entity){
  var body, physicsEntity;
  $remove_3(this$static.entities, entity);
  if (instanceOf(entity, Q$PhysicsEntity)) {
    physicsEntity = entity;
    body = physicsEntity.getBody();
    $remove_9(this$static.bodyEntityLUT, body);
    !!body && $destroyBody(this$static.world, body);
  }
}

function $endContact(this$static, contact){
  $add_10(this$static.release, contact);
}

function $getBombs(this$static){
  var res, x, x$iterator;
  res = new ArrayList_0;
  for (x$iterator = new AbstractList$IteratorImpl_0(this$static.entities); x$iterator.i < x$iterator.this$0_0.size_0();) {
    x = $next_2(x$iterator);
    instanceOf(x, Q$Bomb) && $add_4(res, x);
  }
  return res;
}

function $getEnemies(this$static){
  var res, x, x$iterator;
  res = new ArrayList_0;
  for (x$iterator = new AbstractList$IteratorImpl_0(this$static.entities); x$iterator.i < x$iterator.this$0_0.size_0();) {
    x = $next_2(x$iterator);
    instanceOf(x, Q$Enemy) && $add_4(res, x);
  }
  return res;
}

function $processContacts(this$static){
  var contact, entityA, entityB;
  while (this$static.contacts.arrayList.size != 0) {
    contact = $pop(this$static.contacts);
    entityA = $get_4(this$static.bodyEntityLUT, contact.m_fixtureA.m_body);
    entityB = $get_4(this$static.bodyEntityLUT, contact.m_fixtureB.m_body);
    if (!!entityA && !!entityB) {
      instanceOf(entityA, Q$PhysicsEntity$HasContactListener) && entityA.contact_0(entityB);
      instanceOf(entityB, Q$PhysicsEntity$HasContactListener) && entityB.contact_0(entityA);
    }
  }
}

function $processReleases(this$static){
  var contact, entityA, entityB;
  while (this$static.release.arrayList.size != 0) {
    contact = $pop(this$static.release);
    entityA = $get_4(this$static.bodyEntityLUT, contact.m_fixtureA.m_body);
    entityB = $get_4(this$static.bodyEntityLUT, contact.m_fixtureB.m_body);
    if (!!entityA && !!entityB) {
      instanceOf(entityA, Q$PhysicsEntity$HasContactListener) && entityA.release_0(entityB);
      instanceOf(entityB, Q$PhysicsEntity$HasContactListener) && entityB.release_0(entityA);
    }
  }
}

function $remove_0(this$static, entity){
  $add_10(this$static.entitiesToRemove, entity);
}

function $removeAll(this$static){
  var e;
  while (this$static.entities.size > 0) {
    e = $get(this$static.entities, 0);
    $doRemove_0(this$static, e);
  }
}

function $update_3(this$static, delta){
  var e, e$iterator, entity;
  for (e$iterator = new AbstractList$IteratorImpl_0(this$static.entities); e$iterator.i < e$iterator.this$0_0.size_0();) {
    e = $next_2(e$iterator);
    e.update(delta);
  }
  while (this$static.entitiesToAdd.arrayList.size != 0) {
    entity = $pop(this$static.entitiesToAdd);
    $doAdd_0(this$static, entity);
  }
  while (this$static.entitiesToRemove.arrayList.size != 0) {
    entity = $pop(this$static.entitiesToRemove);
    $doRemove_0(this$static, entity);
  }
  $step(this$static.world);
  $processContacts(this$static);
  $processReleases(this$static);
}

function EntityEngine_0(){
  this.bodyEntityLUT = new HashMap_0;
  this.contacts = new Stack_0;
  this.entities = new ArrayList_0;
  this.entitiesToAdd = new Stack_0;
  this.entitiesToRemove = new Stack_0;
  this.release = new Stack_0;
  this.world = new World_0(new Vec2_1(0, 0));
  this.world.m_warmStarting = true;
  this.world.m_flags |= 4;
  this.world.m_contactManager.m_contactListener = this;
}

defineSeed(40, 1, {}, EntityEngine_0);
_.world = null;
var instance_2 = null;
function FireEntity_0(logicWorld, c){
  DynamicPhysicsEntity_0.call(this, logicWorld, (new Vector2_0(round_int(c.x), round_int(c.y))).x, (new Vector2_0(round_int(c.x), round_int(c.y))).y, 1, 0, true);
  $setCenter(this, $add_2($div(new Vector2_0(c.width_0, c.heigth), 2), new Vector2_0(round_int(c.x), round_int(c.y))));
  $setType(this.body_0, ($clinit_BodyType() , KINEMATIC));
  $setActive(this.body_0);
}

defineSeed(41, 12, makeCastMap([Q$DynamicPhysicsEntity, Q$FireEntity, Q$PhysicsEntity]), FireEntity_0);
_.update = function update_12(delta){
  $update(this, delta);
}
;
function FreeBlock_0(posX, posY, dimension, logicWorld){
  Block_0.call(this, posX, posY, dimension, dimension, true, logicWorld);
}

defineSeed(42, 35, makeCastMap([Q$Block, Q$FreeBlock, Q$PhysicsEntity]), FreeBlock_0);
_.destroy_0 = function destroy_9(){
  var bomb;
  bomb = this.b;
  !!bomb && (bomb.bombTimer = 0);
  this.b = null;
  return this;
}
;
function LogicWorld$Coordinate_0(x, y){
  this.x = x;
  this.y = y;
}

defineSeed(43, 1, {}, LogicWorld$Coordinate_0);
_.x = 0;
_.y = 0;
function $increaseScore_0(this$static, v){
  this$static.score += v;
}

function ScoreManager_0(){
}

defineSeed(44, 1, {}, ScoreManager_0);
_.score = 0;
function $changeDirection(this$static){
  var bomb;
  bomb = this$static.current;
  this$static.current = this$static.visited.arrayList.size == 0?this$static.current:$peek(this$static.visited);
  $clear(this$static.visited.arrayList);
  $push_1(this$static.visited, bomb);
}

function $getNextMove(this$static){
  var adjacents, x;
  if (!this$static.entity)
    throw new RuntimeException_0('Strategy class not correctly initialized');
  x = new Random_0;
  $push_1(this$static.visited, this$static.current);
  adjacents = $getFreeAdjacent(this$static.logicWorld, this$static.current);
  $removeAll_0(adjacents, this$static.visited);
  if (adjacents.size > 0)
    return $get(adjacents, $nextInt(x, adjacents.size));
  $clear(this$static.visited.arrayList);
  $push_1(this$static.visited, this$static.current);
  adjacents = $getFreeAdjacent(this$static.logicWorld, this$static.current);
  $remove_3(adjacents, this$static.current);
  return adjacents.size < 1?this$static.current:$get(adjacents, $nextInt(x, adjacents.size));
}

function Strategy1_0(){
  this.visited = new Stack_0;
}

defineSeed(45, 1, {}, Strategy1_0);
_.changeDirection = function changeDirection(){
  $changeDirection(this);
}
;
_.move = function move(){
  if (!this.entity)
    throw new RuntimeException_0('Strategy class not correctly initialized');
  if ($contains(this.current, this.entity)) {
    $alignPosition(this.entity, this.current);
    this.current = $getNextMove(this);
  }
  !!this.current.b && $changeDirection(this);
  $move_0(this.entity, $getPosition(this.current));
}
;
_.setEntity = function setEntity(entity){
  this.entity = entity;
  this.logicWorld = entity.logicWorld_1;
  this.current = $getBlockAt(this.logicWorld, $add_1(new Vector2_0(entity.x, entity.y)));
  return this;
}
;
_.current = null;
_.entity = null;
_.logicWorld = null;
function $getNextMove_0(this$static){
  var adjacents, tempRand, x;
  if (!this$static.entity)
    throw new RuntimeException_0('Strategy class not correctly initialized');
  this$static.oldIndex = this$static.currentIndex;
  x = new Random_0;
  $push_1(this$static.visited, this$static.current);
  adjacents = $getAdjacent(this$static.logicWorld, this$static.current);
  $removeAll_0(adjacents, this$static.border);
  if (this$static.counter > 3 || this$static.oldIndex >= adjacents.size) {
    tempRand = $nextInt(x, adjacents.size);
    this$static.currentIndex = tempRand;
    this$static.counter = 0;
  }
  ++this$static.counter;
  return $get(adjacents, this$static.currentIndex);
}

function Strategy2_0(){
  this.visited = new Stack_0;
}

defineSeed(46, 1, {}, Strategy2_0);
_.changeDirection = function changeDirection_0(){
  this.counter = 4;
  this.current = this.visited.arrayList.size == 0?this.current:$pop(this.visited);
}
;
_.move = function move_0(){
  if (!this.entity)
    throw new RuntimeException_0('Strategy class not correctly initialized');
  if ($contains(this.current, this.entity)) {
    $alignPosition(this.entity, this.current);
    this.current = $getNextMove_0(this);
  }
  !!this.current.b && (this.counter = 4 , this.current = this.visited.arrayList.size == 0?this.current:$pop(this.visited));
  $move_0(this.entity, $getPosition(this.current));
}
;
_.setEntity = function setEntity_0(entity){
  this.entity = entity;
  this.logicWorld = entity.logicWorld_1;
  this.current = $getBlockAt(this.logicWorld, $add_1(new Vector2_0(entity.x, entity.y)));
  this.border = $getBorderBlocks(this.logicWorld);
  return this;
}
;
_.border = null;
_.counter = 0;
_.current = null;
_.currentIndex = 0;
_.entity = null;
_.logicWorld = null;
_.oldIndex = 0;
function WallBlock_0(x, y, dimension, logicWorld){
  Block_0.call(this, x, y, dimension, dimension, false, logicWorld);
}

defineSeed(47, 35, makeCastMap([Q$Block, Q$PhysicsEntity]), WallBlock_0);
_.destroy_0 = function destroy_10(){
  return this;
}
;
function PowerUp_0(l_0, c){
  DynamicPhysicsEntity_0.call(this, l_0, (new Vector2_0(round_int(c.x), round_int(c.y))).x, (new Vector2_0(round_int(c.x), round_int(c.y))).y, 1, 0, true);
}

defineSeed(49, 12, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PowerUp]));
_.destroy = function destroy_11(){
  this.timer = 0;
}
;
_.update = function update_13(delta){
  this.timer-- < 0 && (this.state = 1 , $removeEntity(this.logicWorld_1, this));
}
;
_.timer = 550;
function Door_0(l_0, c){
  PowerUp_0.call(this, l_0, c);
  this.l_0 = l_0;
}

defineSeed(48, 49, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$Door, Q$PowerUp]), Door_0);
_.apply_0 = function apply(b){
  if ($getEnemies(this.l_0.entityEngine).size != 0)
    return;
  $win(this.l_0.bomberman);
  this.timer = 0;
}
;
_.update = function update_14(delta){
}
;
_.l_0 = null;
function PowerUpBomb_0(l_0, c){
  PowerUp_0.call(this, l_0, c);
}

defineSeed(50, 49, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PowerUp, Q$PowerUpBomb]), PowerUpBomb_0);
_.apply_0 = function apply_0(b){
  ++b.bombs;
  this.timer = 0;
}
;
function PowerUpBombKick_0(l_0, c){
  PowerUp_0.call(this, l_0, c);
  this.l_0 = l_0;
}

defineSeed(51, 49, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PowerUp, Q$PowerUpBombKick]), PowerUpBombKick_0);
_.apply_0 = function apply_1(b){
  var x, x$iterator;
  b.bombPass = false;
  b.bombKick = true;
  for (x$iterator = new AbstractList$IteratorImpl_0($getBombs(this.l_0.entityEngine)); x$iterator.i < x$iterator.this$0_0.size_0();) {
    x = $next_2(x$iterator);
    $setSensor(x.body_0.m_fixtureList, false);
    $setType(x.body_0, ($clinit_BodyType() , DYNAMIC));
  }
  this.timer = 0;
}
;
_.l_0 = null;
function PowerUpBombPass_0(l_0, c){
  PowerUp_0.call(this, l_0, c);
  this.l_0 = l_0;
}

defineSeed(52, 49, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PowerUp, Q$PowerUpBombPass]), PowerUpBombPass_0);
_.apply_0 = function apply_2(b){
  var x, x$iterator;
  b.bombPass = true;
  for (x$iterator = new AbstractList$IteratorImpl_0($getBombs(this.l_0.entityEngine)); x$iterator.i < x$iterator.this$0_0.size_0();) {
    x = $next_2(x$iterator);
    $setSensor(x.body_0.m_fixtureList, true);
  }
  this.timer = 0;
}
;
_.l_0 = null;
function PowerUpBombRangeDown_0(l_0, c){
  PowerUp_0.call(this, l_0, c);
}

defineSeed(53, 49, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PowerUp, Q$PowerUpBombRangeDown]), PowerUpBombRangeDown_0);
_.apply_0 = function apply_3(b){
  $incrementBombRange(b, -1);
  this.timer = 0;
}
;
function PowerUpBombRangeUp_0(l_0, c){
  PowerUp_0.call(this, l_0, c);
}

defineSeed(54, 49, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PowerUp, Q$PowerUpBombRangeUp]), PowerUpBombRangeUp_0);
_.apply_0 = function apply_4(b){
  $incrementBombRange(b, 1);
  this.timer = 0;
}
;
function $clinit_PowerUpEnum(){
  $clinit_PowerUpEnum = nullMethod;
  BOMB_KICK = new PowerUpEnum_0('BOMB_KICK', 0, 0.05000000074505806, 'powerUpBombKick');
  BOMB_PASS = new PowerUpEnum_0('BOMB_PASS', 1, 0.05000000074505806, 'powerUpBombPass');
  BOMB_RANGE_DOWN = new PowerUpEnum_0('BOMB_RANGE_DOWN', 2, 0.05000000074505806, 'powerUpBombRangeDown');
  BOMB_RANGE_UP = new PowerUpEnum_0('BOMB_RANGE_UP', 3, 0.05999999865889549, 'powerUpBombRangeUp');
  BOMB_UP = new PowerUpEnum_0('BOMB_UP', 4, 0.06499999761581421, 'powerUpBomb');
  DOOR = new PowerUpEnum_0('DOOR', 5, 0, 'Door');
  LIFE_UP = new PowerUpEnum_0('LIFE_UP', 6, 0.054999999701976776, 'powerUpLife');
  NULL = new PowerUpEnum_0('NULL', 7, 0.30000001192092896, '');
  SKULL = new PowerUpEnum_0('SKULL', 8, 0.15000000596046448, 'powerUpSkull');
  SPEED_DOWN = new PowerUpEnum_0('SPEED_DOWN', 9, 0.05000000074505806, 'powerUpSpeedDown');
  SPEED_UP = new PowerUpEnum_0('SPEED_UP', 10, 0.05999999865889549, 'powerUpSpeedUp');
  TIME_DOWN = new PowerUpEnum_0('TIME_DOWN', 11, 0.05000000074505806, 'powerUpTimeDown');
  TIME_UP = new PowerUpEnum_0('TIME_UP', 12, 0.05999999865889549, 'powerUpTimeUp');
  $VALUES_0 = initValues(_3Lbomberman_core_logic_powerUp_PowerUpEnum_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$PowerUpEnum, [BOMB_KICK, BOMB_PASS, BOMB_RANGE_DOWN, BOMB_RANGE_UP, BOMB_UP, DOOR, LIFE_UP, NULL, SKULL, SPEED_DOWN, SPEED_UP, TIME_DOWN, TIME_UP]);
}

function PowerUpEnum_0(enum$name, enum$ordinal, probability, name_0){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.probability = probability;
  this.name_0 = name_0;
}

function values_1(){
  $clinit_PowerUpEnum();
  return $VALUES_0;
}

defineSeed(55, 39, makeCastMap([Q$PowerUpEnum, Q$Serializable, Q$Comparable, Q$Enum]), PowerUpEnum_0);
_.name_0 = null;
_.probability = 0;
var $VALUES_0, BOMB_KICK, BOMB_PASS, BOMB_RANGE_DOWN, BOMB_RANGE_UP, BOMB_UP, DOOR, LIFE_UP, NULL, SKULL, SPEED_DOWN, SPEED_UP, TIME_DOWN, TIME_UP;
function PowerUpLife_0(l_0, c){
  PowerUp_0.call(this, l_0, c);
}

defineSeed(56, 49, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PowerUp, Q$PowerUpLife]), PowerUpLife_0);
_.apply_0 = function apply_5(b){
  $setLives(b, b.lives + 1);
  this.timer = 0;
}
;
function PowerUpSkull_0(l_0, c){
  PowerUp_0.call(this, l_0, c);
  this.l_0 = l_0;
}

defineSeed(57, 49, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PowerUp, Q$PowerUpSkull]), PowerUpSkull_0);
_.apply_0 = function apply_6(b){
  switch ($nextInt(new Random_0, 6)) {
    case 0:
      $removeBomb(b);
      break;
    case 1:
      b.die();
      break;
    case 2:
      this.l_0.timer.time += -7;
      break;
    case 3:
      $incrementBombRange(b, -1);
      break;
    default:$increaseSpeed(b, -0.5);
  }
  this.timer = 0;
}
;
_.l_0 = null;
function PowerUpSpeedDown_0(l_0, c){
  PowerUp_0.call(this, l_0, c);
}

defineSeed(58, 49, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PowerUp, Q$PowerUpSpeedDown]), PowerUpSpeedDown_0);
_.apply_0 = function apply_7(b){
  $increaseSpeed(b, -0.5);
  this.timer = 0;
}
;
function PowerUpSpeedUp_0(l_0, c){
  PowerUp_0.call(this, l_0, c);
}

defineSeed(59, 49, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PowerUp, Q$PowerUpSpeedUp]), PowerUpSpeedUp_0);
_.apply_0 = function apply_8(b){
  $increaseSpeed(b, 0.5);
  this.timer = 0;
}
;
function PowerUpTimeDown_0(l_0, c){
  PowerUp_0.call(this, l_0, c);
  this.l_0 = l_0;
}

defineSeed(60, 49, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PowerUp, Q$PowerUpTimeDown]), PowerUpTimeDown_0);
_.apply_0 = function apply_9(b){
  this.l_0.timer.time += -30;
  this.timer = 0;
}
;
_.l_0 = null;
function PowerUpTimeUp_0(l_0, c){
  PowerUp_0.call(this, l_0, c);
  this.l_0 = l_0;
}

defineSeed(61, 49, makeCastMap([Q$DynamicPhysicsEntity, Q$PhysicsEntity, Q$PowerUp, Q$PowerUpTimeUp]), PowerUpTimeUp_0);
_.apply_0 = function apply_10(b){
  this.l_0.timer.time += 30;
  this.timer = 0;
}
;
_.l_0 = null;
function $addAction(this$static, r){
  $add_4(this$static.todo, r);
}

function $invoke(this$static){
  var r, r$iterator;
  if (this$static.isActive) {
    for (r$iterator = new AbstractList$IteratorImpl_0(this$static.todo); r$iterator.i < r$iterator.this$0_0.size_0();) {
      r = $next_2(r$iterator);
      r.run();
    }
  }
}

function $setIsActive(this$static, isActive){
  this$static.isActive = isActive;
  isActive?this$static.il.setAlpha(1):this$static.il.setAlpha(0.5);
}

function Button_0(il){
  this.il = il;
  this.todo = new ArrayList_0;
  il.addListener(new Button$1_0(this));
  this.isActive = true;
}

defineSeed(62, 1, {}, Button_0);
_.il = null;
_.isActive = false;
_.todo = null;
function Button$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(63, 1, makeCastMap([Q$Pointer$Listener]), Button$1_0);
_.onPointerDrag = function onPointerDrag_1(e){
}
;
_.onPointerEnd = function onPointerEnd_1(e){
  $invoke(this.this$0);
}
;
_.onPointerStart = function onPointerStart_1(e){
}
;
_.this$0 = null;
function $show_0(this$static){
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).backgroundLayer.add_1(platform_1.graphics.createImageLayer(this$static.bgImage));
  $show(this$static.world);
}

function $startNewRandomRound(this$static, newLevel){
  var x;
  x = new Random_0;
  $startNewRound_0(this$static, 25 + $nextInt(x, 30), 1 + $nextInt(x, 4), newLevel);
}

function $startNewRound_0(this$static, blocks, enemies, newLevel){
  var enemy, freeBlock, x;
  x = new Random_0;
  $initializeGame_0(this$static.world, blocks);
  newLevel?(this$static.bomber = new BomberDecorator_0(this$static.world)):$addEntity(this$static.world, this$static.bomber);
  $reset(this$static.bomber);
  $addGfxObject(this$static.world, this$static.bomber);
  while (enemies > 0) {
    freeBlock = $getRandomFreeBlock(this$static.world);
    enemy = null;
    switch ($nextInt(x, 5)) {
      case 0:
        enemy = new BaromDecorator_0(this$static.world, freeBlock);
        break;
      case 1:
        enemy = new MaronDecorator_0(this$static.world, freeBlock);
        break;
      case 2:
        enemy = new OnilDecorator_0(this$static.world, freeBlock);
        break;
      case 3:
        enemy = new PontanDecorator_0(this$static.world, freeBlock);
        break;
      case 4:
        enemy = new MinvoDecorator_0(this$static.world, freeBlock);
    }
    $addGfxObject(this$static.world, enemy);
    --enemies;
  }
}

function GameScreen_0(bomberman){
  this.bomberman = bomberman;
  this.world = new DecoratedWorld_0(bomberman);
  this.timerGfxComponent = new TextGuiComponent_0((!instance_1 && (instance_1 = new LayerManager_0) , instance_1).overlayLayer, 310, 512, true);
  this.scoreGfxComponent = new TextGuiComponent_0((!instance_1 && (instance_1 = new LayerManager_0) , instance_1).overlayLayer, 485, 498, false);
  this.livesGfxComponent = new TextGuiComponent_0((!instance_1 && (instance_1 = new LayerManager_0) , instance_1).overlayLayer, 110, 498, false);
}

defineSeed(64, 1, makeCastMap([Q$UIScreen, Q$Keyboard$Listener, Q$Pointer$Listener, Q$Touch$Listener]), GameScreen_0);
_.drawSurface = function drawSurface_9(surface){
  $drawSurface_0(this.world, surface);
}
;
_.loadAssets = function loadAssets(a){
  this.bgImage = $getImage(platform_1.assets, $get_4((!instance && (instance = new PropertiesManager_0(null)) , instance).settings, 'gameScreen'), ($clinit_Scale() , ONE_0));
  $add_13(a, this.bgImage);
  $loadAssets_0(this.world, a);
}
;
_.onKeyDown = function onKeyDown_1(event_0){
  event_0.key_0 == ($clinit_Key() , ESCAPE) && $pause(this.bomberman);
  $onKeyDown_0(this.bomber, event_0);
}
;
_.onKeyTyped = function onKeyTyped_1(event_0){
}
;
_.onKeyUp = function onKeyUp_1(event_0){
  $onKeyUp_0(this.bomber, event_0);
}
;
_.onPointerDrag = function onPointerDrag_2(event_0){
}
;
_.onPointerEnd = function onPointerEnd_2(event_0){
}
;
_.onPointerStart = function onPointerStart_2(event_0){
  $onPointerStart_0(this.bomber, event_0);
}
;
_.onTouchEnd = function onTouchEnd_0(touches){
}
;
_.onTouchMove = function onTouchMove_0(touches){
}
;
_.onTouchStart = function onTouchStart_0(touches){
  $move_0(this.bomber, new Vector2_0(touches[0].localX_0(), touches[0].localY_0()));
}
;
_.paint = function paint_9(alpha){
  $paint_0(this.world, alpha);
  $update_4(this.timerGfxComponent, $toString(this.world.timer), 24, -1, 0);
  $update_4(this.livesGfxComponent, this.bomber.lives + '', 24, -1, 1);
  $update_4(this.scoreGfxComponent, this.world.scoreManager.score + '', 24, -1, 1);
}
;
_.update = function update_15(delta){
  $update_2(this.world, delta);
}
;
_.bgImage = null;
_.bomber = null;
_.bomberman = null;
_.livesGfxComponent = null;
_.scoreGfxComponent = null;
_.timerGfxComponent = null;
_.world = null;
function $createBackground(){
  var canvas, ci, fills, i;
  platform_1.graphics.width_2();
  platform_1.graphics.height_2();
  ci = $createImage(platform_1.graphics, 510, 489);
  canvas = ci.canvas;
  $setFillStyleWeb(canvas.ctx, cssColorString(-813692406));
  $fillRoundRect(canvas, 5, 5, 505, 484);
  fills = initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [-8750470, -7368817, -3355444, -1513240, -1, -1, -1513240, -3355444, -7368817, -8750470]);
  for (i = 0; i < fills.length; ++i) {
    $setStrokeColor(canvas, fills[i]);
    $addRoundRectPath(canvas, i, i, 505 - i * 2, 484 - i * 2);
    canvas.ctx.stroke();
    canvas.isDirty = true;
  }
  $setFillStyleWeb(canvas.ctx, cssColorString(-3796719));
  $fillRoundRect(canvas, fills.length, fills.length, 505 - fills.length * 2, 484 - fills.length * 2);
  return ci;
}

function $createText(text, size){
  var ci, font, format, layout;
  font = new HtmlFont_0('Pusab', ($clinit_Font$Style() , PLAIN), size);
  format = $withAlignment($withFont(new TextFormat_0, font), ($clinit_TextFormat$Alignment() , LEFT_1));
  layout = $layoutText(platform_1.graphics, text, format);
  ci = $createImage(platform_1.graphics, layout.width_0, layout.height_0);
  $setFillColor(ci.canvas, -1);
  $fillText_0(ci.canvas, layout, 0, 0);
  return platform_1.graphics.createImageLayer(ci);
}

function $createWrappedText(text){
  var ci, font, format, layout;
  font = new HtmlFont_0('Pusab', ($clinit_Font$Style() , PLAIN), 18);
  format = new TextFormat_1(font, 410, ($clinit_TextFormat$Alignment() , LEFT_1));
  layout = $layoutText(platform_1.graphics, text, format);
  ci = $createImage(platform_1.graphics, layout.width_0, layout.height_0);
  $setFillColor(ci.canvas, -1);
  $fillText_0(ci.canvas, layout, 0, 0);
  return platform_1.graphics.createImageLayer(ci);
}

function $drawScreen1(this$static){
  var count, powerUp, powerUp1, row, x, x$array, x$index, x$max;
  this$static.contentLayer.addAt($createText('PowerUps', 24), 213, 110);
  count = 0;
  row = 305;
  for (x$array = ($clinit_PowerUpEnum() , $clinit_PowerUpEnum() , $VALUES_0) , x$index = 0 , x$max = x$array.length; x$index < x$max; ++x$index) {
    x = x$array[x$index];
    if (x == NULL)
      continue;
    ++count;
    if (x == DOOR) {
      powerUp1 = $getImage(platform_1.assets, 'images/powerUp/' + x.name_0 + '.png', ($clinit_Scale() , ONE_0));
      this$static.anim = new Sprite_2(powerUp1, true);
      this$static.pos = new Vector2_0(50 + count * 64, row);
      this$static.render = true;
    }
     else {
      powerUp = $getImage(platform_1.assets, 'images/powerUp/' + x.name_0 + '.png', ($clinit_Scale() , ONE_0));
      $addCallback_0(powerUp, new InstructionsScreen$RescaleAndPlaceImageCallback_0(this$static, 50 + count * 64, row, 64, 64));
    }
    if (count == 6) {
      row += 84;
      count = 0;
    }
  }
  this$static.contentLayer.addAt($createWrappedText("every floor contains power-up hidden in blocks that can increase Bomberman's abilities, as well as his chances for survival."), 115, 166);
}

function $hide(this$static){
  this$static.optionsLayer.destroy();
  this$static.optionsLayer = null;
  $start(this$static.bomberman);
}

function $show_1(this$static){
  var alphaMat, alphaMatLayer, bgIl, h_0, w;
  this$static.optionsLayer = platform_1.graphics.createGroupLayer();
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).foregroundLayer.add_1(this$static.optionsLayer);
  this$static.contentLayer = platform_1.graphics.createGroupLayer();
  w = platform_1.graphics.width_2();
  h_0 = platform_1.graphics.height_2();
  alphaMat = $createImage(platform_1.graphics, w, h_0);
  $setFillColor(alphaMat.canvas, 16777215);
  $fillRect_0(alphaMat.canvas, 0, 0, w, h_0);
  alphaMatLayer = platform_1.graphics.createImageLayer(alphaMat);
  alphaMatLayer.addListener(new InstructionsScreen$1_0);
  this$static.optionsLayer.add_1(alphaMatLayer);
  bgIl = platform_1.graphics.createImageLayer(this$static.optionsBgImage);
  this$static.optionsLayer.addAt(bgIl, (w - bgIl.width_1()) / 2, (h_0 - bgIl.height_1()) / 2);
  this$static.done = new Button_0($createText('\u25B6 Done', 18));
  this$static.optionsLayer.addAt(this$static.done.il, 265, 472);
  $addAction(this$static.done, new InstructionsScreen$2_0(this$static));
  this$static.right = new Button_0($createText('\u25BA', 18));
  this$static.optionsLayer.addAt(this$static.right.il, 504, 275);
  $addAction(this$static.right, new InstructionsScreen$3_0(this$static));
  this$static.left_0 = new Button_0($createText('\u25C0', 18));
  this$static.optionsLayer.addAt(this$static.left_0.il, 82, 275);
  $addAction(this$static.left_0, new InstructionsScreen$4_0(this$static));
  this$static.optionsLayer.add_1(this$static.contentLayer);
  this$static.curScreen = 0;
  $updateContent(this$static);
}

--></script>
<script><!--
function $updateContent(this$static){
  var arrows, esc, space;
  this$static.curScreen == 0?$setIsActive(this$static.left_0, false):$setIsActive(this$static.left_0, true);
  this$static.curScreen == 2?$setIsActive(this$static.right, false):$setIsActive(this$static.right, true);
  this$static.contentLayer.clear_0();
  this$static.contentLayer.addAt($createText('(' + (this$static.curScreen + 1) + '/3)', 18), 271, 70);
  switch (this$static.curScreen) {
    case 0:
      this$static.contentLayer.addAt($createText('the game', 24), 210, 110);
      this$static.contentLayer.addAt($createWrappedText('You control Bomberman throughout his efforts to climb the floors of the underground labyrinth and reach the surface in order to become human.\nIn order to do this, you must accomplish two things on each floor: You must destroy every enemy, and you must reveal the exit which can only be used once ever enemy is defeated.'), 115, 166);
      this$static.render = false;
      break;
    case 1:
      $drawScreen1(this$static);
      this$static.render = true;
      break;
    case 2:
      this$static.contentLayer.addAt($createText('Instructions', 24), 174, 110);
      this$static.contentLayer.addAt($createWrappedText('- Use the arrows keys to move Bomberman in any of the four directions.\n- Press the Space key to drop a bomb\n- Press the ESC key to pause the game.'), 115, 166);
      arrows = $getImage(platform_1.assets, 'images/tutorial/arrows.png', ($clinit_Scale() , ONE_0));
      $addCallback_0(arrows, new InstructionsScreen$RescaleAndPlaceImageCallback_0(this$static, 110, 350, 100, 100));
      esc = $getImage(platform_1.assets, 'images/tutorial/esc.png', ONE_0);
      $addCallback_0(esc, new InstructionsScreen$RescaleAndPlaceImageCallback_0(this$static, 250, 400, 50, 50));
      space = $getImage(platform_1.assets, 'images/tutorial/space.png', ONE_0);
      $addCallback_0(space, new InstructionsScreen$RescaleAndPlaceImageCallback_0(this$static, 350, 400, 150, 50));
      this$static.render = false;
      break;
    default:throw new IllegalStateException_1('screen: ' + this$static.curScreen);
  }
}

function InstructionsScreen_0(bomberman){
  this.sp = new SpritePlayer_0;
  this.bomberman = bomberman;
  this.optionsLayer = null;
  this.optionsBgImage = $createBackground();
}

defineSeed(65, 1, makeCastMap([Q$UIScreen, Q$Keyboard$Listener, Q$Pointer$Listener, Q$Touch$Listener]), InstructionsScreen_0);
_.drawSurface = function drawSurface_10(surface){
  this.render && $draw_1(this.sp, surface, this.pos, 64, 64);
}
;
_.loadAssets = function loadAssets_0(a){
}
;
_.onKeyDown = function onKeyDown_2(event_0){
}
;
_.onKeyTyped = function onKeyTyped_2(event_0){
}
;
_.onKeyUp = function onKeyUp_2(event_0){
  switch (event_0.key_0.ordinal) {
    case 111:
      if (this.curScreen > 0) {
        --this.curScreen;
        $updateContent(this);
      }

      break;
    case 114:
      if (this.curScreen < 2) {
        ++this.curScreen;
        $updateContent(this);
      }

      break;
    case 118:
    case 98:
      $invoke(this.done);
  }
}
;
_.onPointerDrag = function onPointerDrag_3(event_0){
}
;
_.onPointerEnd = function onPointerEnd_3(event_0){
}
;
_.onPointerStart = function onPointerStart_3(event_0){
}
;
_.onTouchEnd = function onTouchEnd_1(touches){
}
;
_.onTouchMove = function onTouchMove_1(touches){
}
;
_.onTouchStart = function onTouchStart_1(touches){
}
;
_.paint = function paint_10(alpha){
}
;
_.update = function update_16(delta){
  this.render && $playAnimation(this.sp, delta, this.anim);
}
;
_.anim = null;
_.bomberman = null;
_.contentLayer = null;
_.curScreen = 0;
_.done = null;
_.left_0 = null;
_.optionsBgImage = null;
_.optionsLayer = null;
_.pos = null;
_.render = false;
_.right = null;
function InstructionsScreen$1_0(){
}

defineSeed(66, 1, makeCastMap([Q$Pointer$Listener]), InstructionsScreen$1_0);
_.onPointerDrag = function onPointerDrag_4(e){
}
;
_.onPointerEnd = function onPointerEnd_4(e){
}
;
_.onPointerStart = function onPointerStart_4(e){
}
;
function InstructionsScreen$2_0(this$0){
  this.this$0 = this$0;
}

defineSeed(67, 1, {}, InstructionsScreen$2_0);
_.run = function run(){
  $hide(this.this$0);
}
;
_.this$0 = null;
function InstructionsScreen$3_0(this$0){
  this.this$0 = this$0;
}

defineSeed(68, 1, {}, InstructionsScreen$3_0);
_.run = function run_0(){
  ++this.this$0.curScreen;
  $updateContent(this.this$0);
}
;
_.this$0 = null;
function InstructionsScreen$4_0(this$0){
  this.this$0 = this$0;
}

defineSeed(69, 1, {}, InstructionsScreen$4_0);
_.run = function run_1(){
  --this.this$0.curScreen;
  $updateContent(this.this$0);
}
;
_.this$0 = null;
function InstructionsScreen$RescaleAndPlaceImageCallback_0(this$0, x, y, w, h_0){
  this.this$0 = this$0;
  this.x = x;
  this.y = y;
  this.w = w;
  this.h_0 = h_0;
}

defineSeed(70, 1, {}, InstructionsScreen$RescaleAndPlaceImageCallback_0);
_.onFailure = function onFailure_1(t){
  throw new Error_1(t);
}
;
_.onSuccess = function onSuccess_1(img){
  var ci, il;
  ci = $createImage(platform_1.graphics, this.w, this.h_0);
  $drawImage_1(ci.canvas, img, 0, 0, this.w, this.h_0, 0, 0, img.width_1(), img.height_1());
  il = platform_1.graphics.createImageLayer(ci);
  this.this$0.contentLayer.addAt(il, this.x, this.y);
}
;
_.h_0 = 0;
_.this$0 = null;
_.w = 0;
_.x = 0;
_.y = 0;
function $loadAssets_1(this$static){
  var x, x$array, x$index, x$max;
  this$static.watcher = new AssetWatcher_0(new LoadScreen$1_0(this$static));
  for (x$array = this$static.screens , x$index = 0 , x$max = x$array.length; x$index < x$max; ++x$index) {
    x = x$array[x$index];
    x.loadAssets(this$static.watcher);
  }
  $start_0(this$static.watcher);
}

function LoadScreen_0(bomberman, screens){
  this.bomberman = bomberman;
  this.screens = screens;
  this.loadingGfx = new TextGuiComponent_0((!instance_1 && (instance_1 = new LayerManager_0) , instance_1).overlayLayer, 304, 272, true);
}

defineSeed(71, 1, makeCastMap([Q$UIScreen, Q$Keyboard$Listener, Q$Pointer$Listener, Q$Touch$Listener]), LoadScreen_0);
_.drawSurface = function drawSurface_11(surface){
}
;
_.loadAssets = function loadAssets_1(a){
  $loadAssets_1(this);
}
;
_.onKeyDown = function onKeyDown_3(event_0){
}
;
_.onKeyTyped = function onKeyTyped_3(event_0){
}
;
_.onKeyUp = function onKeyUp_3(event_0){
}
;
_.onPointerDrag = function onPointerDrag_5(event_0){
}
;
_.onPointerEnd = function onPointerEnd_5(event_0){
}
;
_.onPointerStart = function onPointerStart_5(event_0){
}
;
_.onTouchEnd = function onTouchEnd_2(touches){
}
;
_.onTouchMove = function onTouchMove_2(touches){
}
;
_.onTouchStart = function onTouchStart_2(touches){
}
;
_.paint = function paint_11(alpha){
  $update_4(this.loadingGfx, 'Loading - ' + ~~(this.completed * 100 / this.count) + '%', 24, -1, 0);
}
;
_.update = function update_17(delta){
}
;
_.bomberman = null;
_.completed = 0;
_.count = 1;
_.loadingGfx = null;
_.screens = null;
_.watcher = null;
defineSeed(73, 1, {});
function $error(e){
  throw new Error_1(e);
}

function $progress(this$static, loaded, total){
  this$static.this$0.count = total;
  this$static.this$0.completed = loaded;
}

function LoadScreen$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(72, 73, {}, LoadScreen$1_0);
_.this$0 = null;
function $show_2(this$static){
  this$static.loseLayer = platform_1.graphics.createImageLayer(this$static.loseOverlay);
  this$static.loseLayer.setTranslation(104, 122);
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).overlayLayer.add_1(this$static.loseLayer);
}

function LoseScreen_0(bomberman){
  this.bomberman = bomberman;
}

defineSeed(74, 1, makeCastMap([Q$UIScreen, Q$Keyboard$Listener, Q$Pointer$Listener, Q$Touch$Listener]), LoseScreen_0);
_.drawSurface = function drawSurface_12(surface){
}
;
_.loadAssets = function loadAssets_2(a){
  this.loseOverlay = $getImage(platform_1.assets, $get_4((!instance && (instance = new PropertiesManager_0(null)) , instance).settings, 'loseScreenOverlay'), ($clinit_Scale() , ONE_0));
  $add_13(a, this.loseOverlay);
}
;
_.onKeyDown = function onKeyDown_4(event_0){
  event_0.key_0 == ($clinit_Key() , SPACE) && $startNewRound(this.bomberman, true);
  event_0.key_0 == ENTER && $start(this.bomberman);
}
;
_.onKeyTyped = function onKeyTyped_4(event_0){
}
;
_.onKeyUp = function onKeyUp_4(event_0){
}
;
_.onPointerDrag = function onPointerDrag_6(event_0){
}
;
_.onPointerEnd = function onPointerEnd_6(event_0){
}
;
_.onPointerStart = function onPointerStart_6(event_0){
}
;
_.onTouchEnd = function onTouchEnd_3(touches){
}
;
_.onTouchMove = function onTouchMove_3(touches){
}
;
_.onTouchStart = function onTouchStart_3(touches){
}
;
_.paint = function paint_12(alpha){
}
;
_.update = function update_18(delta){
}
;
_.bomberman = null;
_.loseLayer = null;
_.loseOverlay = null;
function $hide_0(this$static){
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).overlayLayer.remove_4(this$static.pauseLayer);
}

function $show_3(this$static){
  this$static.pauseLayer = platform_1.graphics.createImageLayer(this$static.pauseOverlay);
  this$static.pauseLayer.setTranslation(104, 122);
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).overlayLayer.add_1(this$static.pauseLayer);
}

function PauseScreen_0(bomberman){
  this.bomberman = bomberman;
}

defineSeed(75, 1, makeCastMap([Q$UIScreen, Q$Keyboard$Listener, Q$Pointer$Listener, Q$Touch$Listener]), PauseScreen_0);
_.drawSurface = function drawSurface_13(surface){
}
;
_.loadAssets = function loadAssets_3(a){
  this.pauseOverlay = $getImage(platform_1.assets, $get_4((!instance && (instance = new PropertiesManager_0(null)) , instance).settings, 'pauseScreenOverlay'), ($clinit_Scale() , ONE_0));
  $add_13(a, this.pauseOverlay);
}
;
_.onKeyDown = function onKeyDown_5(event_0){
  event_0.key_0 == ($clinit_Key() , ESCAPE) && $resume(this.bomberman);
  event_0.key_0 == SPACE && $startNewRound(this.bomberman, true);
  event_0.key_0 == ENTER && $start(this.bomberman);
}
;
_.onKeyTyped = function onKeyTyped_5(event_0){
}
;
_.onKeyUp = function onKeyUp_5(event_0){
}
;
_.onPointerDrag = function onPointerDrag_7(event_0){
}
;
_.onPointerEnd = function onPointerEnd_7(event_0){
}
;
_.onPointerStart = function onPointerStart_7(event_0){
}
;
_.onTouchEnd = function onTouchEnd_4(touches){
}
;
_.onTouchMove = function onTouchMove_4(touches){
}
;
_.onTouchStart = function onTouchStart_4(touches){
}
;
_.paint = function paint_13(alpha){
}
;
_.update = function update_19(delta){
}
;
_.bomberman = null;
_.pauseLayer = null;
_.pauseOverlay = null;
function $show_4(this$static){
  this$static.startScreenLayer = platform_1.graphics.createImageLayer(this$static.background);
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).backgroundLayer.add_1(this$static.startScreenLayer);
}

function StartScreen_0(bomberman){
  this.startTextComponent = new TextGuiComponent_0((!instance_1 && (instance_1 = new LayerManager_0) , instance_1).overlayLayer, platform_1.graphics.width_2() / 2, platform_1.graphics.height_2() / 2 + 100, true);
  this.instructionsTextComponent = new TextGuiComponent_0((!instance_1 && (instance_1 = new LayerManager_0) , instance_1).overlayLayer, platform_1.graphics.width_2() / 2, platform_1.graphics.height_2() / 2 + 200, true);
  this.bomberman = bomberman;
}

defineSeed(76, 1, makeCastMap([Q$UIScreen, Q$Keyboard$Listener, Q$Pointer$Listener, Q$Touch$Listener]), StartScreen_0);
_.drawSurface = function drawSurface_14(surface){
}
;
_.loadAssets = function loadAssets_4(a){
  this.background = $getImage(platform_1.assets, $get_4((!instance && (instance = new PropertiesManager_0(null)) , instance).settings, 'startScreen'), ($clinit_Scale() , ONE_0));
  $add_13(a, this.background);
  this.text = $get_4((!instance && (instance = new PropertiesManager_0(null)) , instance).settings, 'startText');
  this.instructions = $get_4((!instance && (instance = new PropertiesManager_0(null)) , instance).settings, 'instructionsText');
}
;
_.onKeyDown = function onKeyDown_6(event_0){
}
;
_.onKeyTyped = function onKeyTyped_6(event_0){
}
;
_.onKeyUp = function onKeyUp_6(event_0){
  event_0.key_0 == ($clinit_Key() , SPACE)?$startNewRound(this.bomberman, true):event_0.key_0 == I_0 && $showInstructions(this.bomberman);
}
;
_.onPointerDrag = function onPointerDrag_8(event_0){
}
;
_.onPointerEnd = function onPointerEnd_8(event_0){
}
;
_.onPointerStart = function onPointerStart_8(event_0){
  $startNewRound(this.bomberman, true);
}
;
_.onTouchEnd = function onTouchEnd_5(touches){
}
;
_.onTouchMove = function onTouchMove_5(touches){
}
;
_.onTouchStart = function onTouchStart_5(touches){
  $startNewRound(this.bomberman, false);
}
;
_.paint = function paint_14(alpha){
}
;
_.update = function update_20(delta){
  (this.color == -16777216 || this.color == -65536) && (this.increment *= -1);
  this.color += this.increment;
  $update_4(this.startTextComponent, this.text, 28, this.color, 1);
  $update_4(this.instructionsTextComponent, this.instructions, 18, 2130706432, 2);
}
;
_.background = null;
_.bomberman = null;
_.color = -65536;
_.increment = 1114112;
_.instructions = null;
_.instructionsTextComponent = null;
_.startScreenLayer = null;
_.startTextComponent = null;
_.text = null;
function $createTextLayer(layout, color, fx){
  var image;
  image = $createImage(platform_1.graphics, ceil(layout.width_0), ceil(layout.height_0));
  switch (fx) {
    case 1:
      {
        image.canvas.ctx.lineWidth = 5;
        $setStrokeColor(image.canvas, -16777216);
        $setLineCap(image.canvas.ctx, $convertLineCap().value_0);
        $setLineJoin(image.canvas.ctx, $convertLineJoin().value_0);
        $strokeText_0(image.canvas, layout);
      }

      break;
    case 2:
      {
        $setFillColor(image.canvas, -2236963);
        $fillText_0(image.canvas, layout, 2, -2);
      }

  }
  $setFillColor(image.canvas, color);
  $fillText_0(image.canvas, layout, 0, 0);
  return platform_1.graphics.createImageLayer(image);
}

function $update_4(this$static, content_0, fontSize, color, fx){
  var font, format, layout, x, y;
  !!this$static.current && this$static.current.destroy();
  x = this$static.x;
  y = this$static.y;
  font = new HtmlFont_0('Pusab', ($clinit_Font$Style() , PLAIN), fontSize);
  format = $withFont(new TextFormat_0, font);
  layout = $layoutText(platform_1.graphics, content_0, format);
  this$static.current = $createTextLayer(layout, color, fx);
  if (this$static.centered) {
    x = this$static.x - layout.width_0 / 2;
    y = this$static.y - layout.height_0 / 2;
  }
  this$static.current.setTranslation(x, y);
  this$static.parent_0.add_1(this$static.current);
}

function TextGuiComponent_0(parent_0, x, y, centered){
  this.parent_0 = parent_0;
  this.x = x;
  this.y = y;
  this.centered = centered;
}

defineSeed(77, 1, {}, TextGuiComponent_0);
_.centered = false;
_.current = null;
_.parent_0 = null;
_.x = 0;
_.y = 0;
function $show_5(this$static){
  this$static.winLayer = platform_1.graphics.createImageLayer(this$static.winOverlay);
  this$static.winLayer.setTranslation(104, 122);
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).overlayLayer.add_1(this$static.winLayer);
}

function WinScreen_0(bomberman){
  this.bomberman = bomberman;
}

defineSeed(78, 1, makeCastMap([Q$UIScreen, Q$Keyboard$Listener, Q$Pointer$Listener, Q$Touch$Listener]), WinScreen_0);
_.drawSurface = function drawSurface_15(surface){
}
;
_.loadAssets = function loadAssets_5(a){
  this.winOverlay = $getImage(platform_1.assets, $get_4((!instance && (instance = new PropertiesManager_0(null)) , instance).settings, 'winScreenOverlay'), ($clinit_Scale() , ONE_0));
  $add_13(a, this.winOverlay);
}
;
_.onKeyDown = function onKeyDown_7(event_0){
  event_0.key_0 == ($clinit_Key() , SPACE) && $startNewRound(this.bomberman, false);
  event_0.key_0 == ENTER && $start(this.bomberman);
}
;
_.onKeyTyped = function onKeyTyped_7(event_0){
}
;
_.onKeyUp = function onKeyUp_7(event_0){
}
;
_.onPointerDrag = function onPointerDrag_9(event_0){
}
;
_.onPointerEnd = function onPointerEnd_9(event_0){
}
;
_.onPointerStart = function onPointerStart_9(event_0){
}
;
_.onTouchEnd = function onTouchEnd_6(touches){
}
;
_.onTouchMove = function onTouchMove_6(touches){
}
;
_.onTouchStart = function onTouchStart_6(touches){
}
;
_.paint = function paint_15(alpha){
}
;
_.update = function update_21(delta){
}
;
_.bomberman = null;
_.winLayer = null;
_.winOverlay = null;
function $clinit_Constants(){
  $clinit_Constants = nullMethod;
  TEXTURES = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['bomberUp', 'bomberDown', 'bomberLeft', 'bomberRight', 'bomberIdle', 'bomberDying', 'baromIdle', 'baromDying', 'maronIdle', 'maronDying', 'pontanIdle', 'pontanDying', 'onilIdle', 'onilDying', 'minboIdle', 'minboDying', 'bomb', 'fire', 'Door', 'PowerUpBomb', 'PowerUpBombKick', 'PowerUpBombPass', 'PowerUpBombRangeUp', 'PowerUpBombRangeDown', 'PowerUpLife', 'PowerUpSkull', 'PowerUpSpeedUp', 'PowerUpSpeedDown', 'PowerUpTimeUp', 'PowerUpTimeDown', 'dynamicGroundImage']);
}

var TEXTURES;
function $toString(this$static){
  var seconds;
  seconds = round_int(this$static.time % 60);
  return round_int(this$static.time / 60) + ':' + (seconds < 10?'0' + seconds:valueOf(seconds));
}

function $update_5(this$static, delta){
  this$static.time -= delta / 1000;
}

function Timer_0(){
  this.time = 150;
}

defineSeed(80, 1, {}, Timer_0);
_.toString$ = function toString_2(){
  return $toString(this);
}
;
_.time = 0;
function $clinit_Vector2(){
  $clinit_Vector2 = nullMethod;
  new Vector2_0(0, 0);
}

function $add_1(this$static){
  return new Vector2_0(this$static.x + 16, this$static.y + 16);
}

function $add_2(this$static, v){
  return new Vector2_0(this$static.x + v.x, this$static.y + v.y);
}

function $div(this$static, a){
  return new Vector2_0(this$static.x / a, this$static.y / a);
}

function $getVec2(this$static){
  return new Vec2_1(this$static.x, this$static.y);
}

function $mul(this$static){
  return new Vector2_0(this$static.x * 100, this$static.y * 100);
}

function $sub(this$static, v){
  return new Vector2_0(this$static.x - v.x, this$static.y - v.y);
}

function $toInt(this$static){
  return new Vector2_0(round(this$static.x), round(this$static.y));
}

function Vector2_0(x, y){
  $clinit_Vector2();
  this.x = x;
  this.y = y;
}

function Vector2_1(position){
  $clinit_Vector2();
  Vector2_0.call(this, position.x, position.y);
}

defineSeed(81, 1, makeCastMap([Q$Vector2]), Vector2_0, Vector2_1);
_.equals$ = function equals_2(v){
  return instanceOf(v, Q$Vector2) && this.x == v.x && this.y == v.y;
}
;
_.toString$ = function toString_3(){
  return this.x + ' - ' + this.y;
}
;
_.x = 0;
_.y = 0;
function $logMessage(logLevel, message){
  logLevel >= 40000?$wnd.console.error(message):logLevel >= 30000?$wnd.console.warn(message):logLevel >= 20000?$wnd.console.info(message):$wnd.console.debug(message);
}

function ConsoleLogger_0(){
}

defineSeed(84, 1, {}, ConsoleLogger_0);
_.clear_0 = function clear_0(){
}
;
_.isSupported = function isSupported(){
  if ($wnd.console == null || typeof $wnd.console.log != 'function' && typeof $wnd.console.log != 'object') {
    return false;
  }
  typeof $wnd.console.error == 'undefined' && ($wnd.console.error = $wnd.console.log);
  typeof $wnd.console.warn == 'undefined' && ($wnd.console.warn = $wnd.console.log);
  typeof $wnd.console.info == 'undefined' && ($wnd.console.info = $wnd.console.log);
  typeof $wnd.console.debug == 'undefined' && ($wnd.console.debug = $wnd.console.log);
  return true;
}
;
_.log_1 = function log_0(record){
  $logMessage(record.level, $getFormattedMessage(record) + stackTraceToString(record.throwable?record.throwable:getInstanceOrNull(record.wrappedClientThrowable)));
}
;
_.setCurrentLogLevel = function setCurrentLogLevel(level){
}
;
function $clinit_Log(){
  $clinit_Log = nullMethod;
  impl_0 = new LogImplDebug_0;
  $init(impl_0);
}

function diagnostic(message, e){
  $clinit_Log();
  $log(impl_0, 2147483647, message, e);
}

var impl_0 = null;
function $format(logLevelText, message){
  var len;
  message == null && (message = '<null message>');
  return '(-:-) ' + formatDate(new Date_1) + ' [' + ($clinit_LogUtil() , len = logLevelText.length , len < 5?logLevelText + $substring_0(SPACES, 0, 5 - len):logLevelText) + '] ' + message + '\n';
}

function LogMessageFormatterImpl_0(){
  currentTimeMillis();
}

defineSeed(86, 1, {}, LogMessageFormatterImpl_0);
function $clinit_LogUtil(){
  $clinit_LogUtil = nullMethod;
  var b, i;
  b = new StringBuffer_0;
  for (i = 0; i < 500; ++i) {
    b.impl.string += ' ';
  }
  SPACES = b.impl.string;
}

function formatDate(date){
  $clinit_LogUtil();
  return $format_0(($clinit_DateTimeFormat_0() , getFormat($getDateTimeFormatInfo(($clinit_LocaleInfo() , $clinit_LocaleInfo() , instance_3)))), date, null);
}

function levelToString(level){
  $clinit_LogUtil();
  switch (level) {
    case 5000:
      return 'TRACE';
    case 10000:
      return 'DEBUG';
    case 20000:
      return 'INFO';
    case 30000:
      return 'WARN';
    case 40000:
      return 'ERROR';
    case 50000:
      return 'FATAL';
    case 2147483647:
      return 'OFF';
    default:throw new IllegalArgumentException_0;
  }
}

function stackTraceToString(throwable){
  $clinit_LogUtil();
  var element, element$index, element$max, stackTraceElements, text, text1;
  text = '';
  if (throwable) {
    while (throwable) {
      text1 = '';
      text1 += throwable.toString$() + '\n';
      stackTraceElements = $getStackTrace(throwable);
      for (element$index = 0 , element$max = stackTraceElements.length; element$index < element$max; ++element$index) {
        element = stackTraceElements[element$index];
        text1 += '    at ' + element + '\n';
      }
      text += text1;
      throwable = throwable.getCause();
      !!throwable && (text += 'Caused by: ');
    }
  }
  return text;
}

function stringToLevel(logLevelString){
  $clinit_LogUtil();
  if ($equals('TRACE', logLevelString)) {
    return 5000;
  }
   else if ($equals('DEBUG', logLevelString)) {
    return 10000;
  }
   else if ($equals('INFO', logLevelString)) {
    return 20000;
  }
   else if ($equals('WARN', logLevelString)) {
    return 30000;
  }
   else if ($equals('ERROR', logLevelString)) {
    return 40000;
  }
   else if ($equals('FATAL', logLevelString)) {
    return 50000;
  }
   else if ($equals('OFF', logLevelString)) {
    return 2147483647;
  }
   else {
    throw new IllegalArgumentException_0;
  }
}

var SPACES = null;
function NullLogger_0(){
}

defineSeed(88, 1, {}, NullLogger_0);
_.clear_0 = function clear_1(){
}
;
_.isSupported = function isSupported_0(){
  return false;
}
;
_.log_1 = function log_1(record){
}
;
_.setCurrentLogLevel = function setCurrentLogLevel_0(level){
}
;
function $loggersAdd(this$static, logger){
  logger.isSupported() && $add_4(this$static.loggers, logger);
}

function $loggersClear(this$static){
  var $e0, e, iterator, logger;
  for (iterator = new AbstractList$IteratorImpl_0(this$static.loggers); iterator.i < iterator.this$0_0.size_0();) {
    logger = $next_2(iterator);
    try {
      logger.clear_0();
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$RuntimeException)) {
        e = $e0;
        $reportAndRemoveLogger(this$static, iterator, logger, e);
      }
       else 
        throw $e0;
    }
  }
}

function $loggersLog(this$static, record){
  var $e0, e1, iterator, logger;
  for (iterator = new AbstractList$IteratorImpl_0(this$static.loggers); iterator.i < iterator.this$0_0.size_0();) {
    logger = $next_2(iterator);
    try {
      logger.log_1(record);
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$RuntimeException)) {
        e1 = $e0;
        $reportAndRemoveLogger(this$static, iterator, logger, e1);
      }
       else 
        throw $e0;
    }
  }
}

function $loggersSetCurrentLogLevel(this$static, level){
  var $e0, e, iterator, logger;
  for (iterator = new AbstractList$IteratorImpl_0(this$static.loggers); iterator.i < iterator.this$0_0.size_0();) {
    logger = $next_2(iterator);
    try {
      logger.setCurrentLogLevel(level);
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$RuntimeException)) {
        e = $e0;
        $reportAndRemoveLogger(this$static, iterator, logger, e);
      }
       else 
        throw $e0;
    }
  }
}

function $reportAndRemoveLogger(this$static, iterator, logger, e){
  $remove_11(iterator);
  $remove_3(this$static.loggers, logger);
  diagnostic("Removing '" + logger.___clazz$.typeName + "' due to unexecpted exception", e);
}

function RemoteLogger_0(){
  this.loggers = new ArrayList_0;
}

defineSeed(89, 88, {}, RemoteLogger_0);
function SystemLogger_0(){
}

defineSeed(90, 1, {}, SystemLogger_0);
_.clear_0 = function clear_2(){
}
;
_.isSupported = function isSupported_1(){
  return false;
}
;
_.log_1 = function log_2(record){
  record.level >= 40000?($getFormattedMessage(record) + stackTraceToString(record.throwable?record.throwable:getInstanceOrNull(record.wrappedClientThrowable)) , undefined):($getFormattedMessage(record) + stackTraceToString(record.throwable?record.throwable:getInstanceOrNull(record.wrappedClientThrowable)) , undefined);
}
;
_.setCurrentLogLevel = function setCurrentLogLevel_1(level){
}
;
defineSeed(91, 1, {});
function $clinit_LogImplBase(){
  $clinit_LogImplBase = nullMethod;
  levelToString(10000);
  levelToString(40000);
  levelToString(50000);
  levelToString(20000);
  levelToString(2147483647);
  levelToString(5000);
  levelToString(30000);
  $wnd.$GWT_LOG_VERSION = '3.1.6';
  $clinit_StyleInjector();
  injectAtStart(($clinit_LocaleInfo() , '.log-panel{background-color:#ecf2fc;border:1px solid red;margin:0;filter:alpha(opacity \\= 95);opacity:0.95;z-index:1000;}.log-panel .GCK1R1LCI{font-size:10pt;margin:0;text-align:left;}.log-panel BUTTON{font-size:10pt;margin:0;}.log-panel .GCK1R1LCJ{cursor:move;font-weight:bold;}.log-panel .GCK1R1LCB{margin:0 1.2em;}.log-panel BUTTON.GCK1R1LCA{color:#444 !important;}.log-panel .GCK1R1LCH{white-space:nowrap;}.log-panel .GCK1R1LCC{white-space:pre;font-family:monospace;cursor:help;}.log-panel .GCK1R1LCD{background-color:#f0f0f0;}.log-panel .GCK1R1LCG{background-color:#fff;}.log-panel .GCK1R1LCF{cursor:se-resize;}'));
}

function $addLogger(this$static, logger){
  $loggersAdd(this$static.remoteLogger, logger);
}

function $init(this$static){
  var $e0, ex, logLevelString;
  $addLogger(this$static, new NullLogger_0);
  $addLogger(this$static, new SystemLogger_0);
  $addLogger(this$static, new ConsoleLogger_0);
  try {
    $addLogger(this$static, new NullLogger_0);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Throwable)) {
      ex = $e0;
      alert_0("WARNING: Unable to instantiate '" + Lcom_allen_1sauer_gwt_log_client_DivLogger_2_classLit + "' due to " + ex.toString$());
    }
     else 
      throw $e0;
  }
  try {
    $addLogger(this$static, new NullLogger_0);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Throwable)) {
      ex = $e0;
      alert_0("WARNING: Unable to instantiate '" + Lcom_allen_1sauer_gwt_log_client_WindowLogger_2_classLit + "' due to " + ex.toString$());
    }
     else 
      throw $e0;
  }
  $setCurrentLogLevelLoggers(this$static, (logLevelString = (ensureParameterMap() , $get_4(paramMap, 'log_level')) , $clinit_Log() , logLevelString == null?10000:max_0(10000, stringToLevel(logLevelString))));
  $loggersClear(this$static.remoteLogger);
}

function $log(this$static, level, message, e){
  var record;
  record = new LogRecord_0(level, message, e);
  $loggersLog(this$static.remoteLogger, record);
}

function $setCurrentLogLevelLoggers(this$static, level){
  if (level < 10000) {
    $wnd.alert('Unable to lower runtime log level to ' + level + ' due to compile time minimum of 10000');
    level = 10000;
  }
  $loggersSetCurrentLogLevel(this$static.remoteLogger, level);
  return level;
}

function $setErrorHandler(){
  $wnd != window && (window.onerror = handleOnError);
  var oldOnError = $wnd.onerror;
  $wnd.onerror = function(msg, url, line){
    var result, oldResult;
    try {
      result = ($clinit_Log() , $log(impl_0, 50000, 'Uncaught JavaScript exception [' + msg + '] in ' + url + ', line ' + line, null) , true);
    }
     finally {
      oldResult = oldOnError && oldOnError(msg, url, line);
    }
    if (result != null)
      return result;
    if (oldResult != null)
      return oldResult;
  }
  ;
}

function handleOnError(msg, url, line){
  $clinit_Log();
  $log(impl_0, 50000, 'Uncaught JavaScript exception [' + msg + '] in ' + url + ', line ' + line, null);
  return true;
}

defineSeed(92, 91, {});
function LogImplBase$1_0(){
}

defineSeed(93, 1, {}, LogImplBase$1_0);
_.onUncaughtException = function onUncaughtException(e){
  $clinit_Log();
  $log(impl_0, 50000, 'Uncaught Exception:', e);
}
;
function LogImplDebug_0(){
  $clinit_LogImplBase();
  this.remoteLogger = new RemoteLogger_0;
}

defineSeed(94, 92, {}, LogImplDebug_0);
function $clinit_LogRecord(){
  $clinit_LogRecord = nullMethod;
  new LogMessageFormatterImpl_0;
}

function $getFormattedMessage(this$static){
  if (this$static.formattedMessage != null) {
    return this$static.formattedMessage;
  }
  getInstanceOrNull(this$static.wrappedClientThrowable?this$static.wrappedClientThrowable:this$static.wrappedBookmarkThrowable);
  this$static.formattedMessage = this$static.level == 2147483647?this$static.message_0:$format(levelToString(this$static.level), this$static.message_0);
  return this$static.formattedMessage;
}

--></script>
<script><!--
function LogRecord_0(level, message, throwable){
  $clinit_LogRecord();
  this.category = 'gwt-log';
  this.throwable = throwable;
  ++gloablRecordSequence;
  this.level = level;
  this.message_0 = message;
  this.wrappedClientThrowable = !throwable?null:new WrappedClientThrowable_0(throwable);
  if (!throwable) {
    this.bookmarkThrowable = new Throwable_0;
    this.wrappedBookmarkThrowable = getInstanceOrNull_0(this.bookmarkThrowable);
  }
}

defineSeed(95, 1, makeCastMap([Q$Serializable]), LogRecord_0);
_.bookmarkThrowable = null;
_.category = null;
_.formattedMessage = null;
_.level = 0;
_.message_0 = null;
_.throwable = null;
_.wrappedBookmarkThrowable = null;
_.wrappedClientThrowable = null;
var gloablRecordSequence = 0;
function $getStackTrace(this$static){
  if (this$static.stackTrace == null) {
    return initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$StackTraceElement, 0, 0);
  }
  return this$static.stackTrace;
}

function $printStackTrace(this$static){
  var causeMessage, currentCause, msg;
  msg = new StringBuffer_0;
  currentCause = this$static;
  while (currentCause) {
    causeMessage = currentCause.getMessage();
    currentCause != this$static && (msg.impl.string += 'Caused by: ' , msg);
    $append_5(msg, currentCause.___clazz$.typeName);
    msg.impl.string += ': ';
    $append_3(msg.impl, causeMessage == null?'(No exception detail)':causeMessage);
    msg.impl.string += '\n';
    currentCause = currentCause.getCause();
  }
}

function $setStackTrace(this$static, stackTrace){
  var c, copy, i;
  copy = initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$StackTraceElement, stackTrace.length, 0);
  for (i = 0 , c = stackTrace.length; i < c; ++i) {
    if (!stackTrace[i]) {
      throw new NullPointerException_0;
    }
    copy[i] = stackTrace[i];
  }
  this$static.stackTrace = copy;
}

function Throwable_0(){
  this.fillInStackTrace();
}

function Throwable_1(cause){
  this.fillInStackTrace();
  this.detailMessage = !cause?null:cause.toString$();
  this.cause_0 = cause;
}

defineSeed(97, 1, makeCastMap([Q$Serializable, Q$Throwable]), Throwable_0);
_.fillInStackTrace = function fillInStackTrace(){
  $fillInStackTrace(($clinit_StackTraceCreator$CollectorChrome() , this));
  return this;
}
;
_.getCause = function getCause(){
  return this.cause_0;
}
;
_.getMessage = function getMessage(){
  return this.detailMessage;
}
;
_.toString$ = function toString_4(){
  var className, msg;
  className = this.___clazz$.typeName;
  msg = this.getMessage();
  return msg != null?className + ': ' + msg:className;
}
;
_.cause_0 = null;
_.detailMessage = null;
_.stackTrace = null;
function UnwrappedClientThrowable_0(wrapped){
  var clientStackTrace, i, stackTrace, wrappedcause;
  this.fillInStackTrace();
  this.originalToString = wrapped.originalToString;
  this.message_0 = wrapped.message_0;
  clientStackTrace = wrapped.clientStackTrace;
  if (clientStackTrace != null) {
    stackTrace = initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$StackTraceElement, clientStackTrace.length, 0);
    for (i = 0; i < clientStackTrace.length; ++i) {
      stackTrace[i] = new StackTraceElement_0(clientStackTrace[i].className, clientStackTrace[i].methodName, clientStackTrace[i].fileName, clientStackTrace[i].lineNumber);
    }
    $setStackTrace(this, stackTrace);
  }
  wrappedcause = wrapped.cause;
  !!wrappedcause && (this.cause = new UnwrappedClientThrowable_0(wrappedcause));
}

function getInstanceOrNull(wrapped){
  return !wrapped?null:new UnwrappedClientThrowable_0(wrapped);
}

defineSeed(96, 97, makeCastMap([Q$Serializable, Q$Throwable]), UnwrappedClientThrowable_0);
_.fillInStackTrace = function fillInStackTrace_0(){
  return this;
}
;
_.getCause = function getCause_0(){
  return this.cause;
}
;
_.getMessage = function getMessage_0(){
  return this.message_0;
}
;
_.toString$ = function toString_5(){
  return this.originalToString;
}
;
_.cause = null;
_.message_0 = null;
_.originalToString = null;
function $setCause(this$static, cause){
  this$static.cause = cause;
}

function WrappedClientThrowable_0(ex){
  var i, stackTrace;
  if (ex) {
    this.originalToString = ex.toString$();
    this.message_0 = ex.getMessage();
    stackTrace = $getStackTrace(ex);
    this.clientStackTrace = initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$StackTraceElement, stackTrace.length, 0);
    for (i = 0; i < stackTrace.length; ++i) {
      this.clientStackTrace[i] = new StackTraceElement_0(stackTrace[i].className, stackTrace[i].methodName, stackTrace[i].fileName, stackTrace[i].lineNumber);
    }
    $setCause(this, getInstanceOrNull_0(ex.getCause()));
  }
}

function getInstanceOrNull_0(ex){
  return !ex?null:new WrappedClientThrowable_0(ex);
}

defineSeed(98, 1, makeCastMap([Q$Serializable]), WrappedClientThrowable_0);
_.cause = null;
_.clientStackTrace = null;
_.message_0 = null;
_.originalToString = null;
function $clinit_AbstractSound(){
  $clinit_AbstractSound = nullMethod;
  INITIAL_LOAD_STATE = ($clinit_Sound$LoadState() , LOAD_STATE_UNINITIALIZED);
}

function $addEventHandler(this$static, handler){
  $add_4(this$static.soundHandlerCollection, handler);
  this$static.loadState != INITIAL_LOAD_STATE && $onSoundLoadStateChange(handler, new SoundLoadStateChangeEvent_0(this$static));
}

function $setLoadState(this$static, loadState){
  if (loadState != this$static.loadState) {
    this$static.loadState = loadState;
    loadState != INITIAL_LOAD_STATE && $fireOnSoundLoadStateChange(this$static.soundHandlerCollection, this$static);
  }
}

function AbstractSound_0(url){
  $clinit_AbstractSound();
  this.soundHandlerCollection = new SoundHandlerCollection_0;
  this.loadState = INITIAL_LOAD_STATE;
  this.mimeType = 'audio/mpeg';
  this.url = url;
  this.streaming = false;
  this.crossOrigin = false;
}

defineSeed(99, 1, {});
_.toString$ = function toString_6(){
  return this.getSoundType() + '("' + this.mimeType + '", "' + this.url + '", ' + (this.streaming?'streaming':'not streaming') + ', ' + (this.crossOrigin?'cross origin':'same origin') + ')';
}
;
_.crossOrigin = false;
_.mimeType = null;
_.streaming = false;
_.url = null;
var INITIAL_LOAD_STATE;
function $clinit_FlashSound(){
  $clinit_FlashSound = nullMethod;
  $clinit_AbstractSound();
  soundList = new ArrayList_0;
}

function $playbackCompleted(this$static){
  $fireOnPlaybackComplete(this$static.soundHandlerCollection, this$static);
}

function $registerSound(this$static){
  if (!this$static.soundRegistered) {
    $registerSound_0(this$static.voicesMovie, this$static);
    this$static.soundRegistered = true;
  }
}

function $soundLoaded(this$static){
  $setLoadState(this$static, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY));
  this$static.volume_0 != 100 && $setVolume(this$static.voicesMovie, this$static.soundNumber, this$static.volume_0);
  this$static.looping && $setLooping(this$static.voicesMovie, this$static.soundNumber, this$static.looping);
}

function FlashSound_0(url, voicesMovie){
  $clinit_FlashSound();
  AbstractSound_0.call(this, url);
  this.voicesMovie = voicesMovie;
  this.soundNumber = soundList.size;
  $add_4(soundList, this);
  $registerSound(this);
}

defineSeed(100, 99, {}, FlashSound_0);
_.getSoundType = function getSoundType(){
  return $clinit_SoundType() , FLASH;
}
;
_.play_0 = function play(){
  $registerSound(this);
  if (this.loadState == ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY)) {
    return $playSound(this.voicesMovie, this.soundNumber);
  }
  return false;
}
;
_.setLooping_0 = function setLooping(looping){
  this.looping = looping;
  this.loadState == ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY) && $setLooping(this.voicesMovie, this.soundNumber, looping);
}
;
_.setVolume_0 = function setVolume(volume){
  this.volume_0 = volume;
  this.loadState == ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY) && $setVolume(this.voicesMovie, this.soundNumber, volume);
}
;
_.stop_0 = function stop_0(){
  this.loadState == ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY) && $stopSound(this.voicesMovie, this.soundNumber);
}
;
_.looping = false;
_.soundNumber = 0;
_.soundRegistered = false;
_.voicesMovie = null;
_.volume_0 = 100;
var soundList;
function FlashSound$1_0(val$index){
  this.val$index = val$index;
}

defineSeed(101, 1, {}, FlashSound$1_0);
_.execute = function execute(){
  $playbackCompleted($get(($clinit_FlashSound() , soundList), this.val$index));
}
;
_.val$index = 0;
function FlashSound$2_0(val$index){
  this.val$index = val$index;
}

defineSeed(102, 1, {}, FlashSound$2_0);
_.execute = function execute_0(){
  $soundLoaded($get(($clinit_FlashSound() , soundList), this.val$index));
}
;
_.val$index = 0;
function $createAudioElement(this$static){
  var elem;
  !!this$static.endedRegistration && $removeHandler(this$static.endedRegistration.real);
  !!this$static.audio && $removeFromParent(this$static.audio);
  this$static.audio = createIfSupported();
  elem = this$static.audio.element;
  this$static.endedRegistration = $addBitlessDomHandler(this$static.audio, this$static.endedHandler, ($clinit_EndedEvent() , $clinit_EndedEvent() , TYPE));
  $add_6(($clinit_RootPanel() , get_2()), this$static.audio);
  this$static.crossOrigin && (elem.setAttribute('crossOrigin', 'anonymous') , undefined);
  $setSrc(elem, this$static.url);
}

function Html5Sound_0(url){
  $clinit_AbstractSound();
  var mimeTypeSupport;
  AbstractSound_0.call(this, url);
  this.endedHandler = new Html5Sound$1_0(this);
  $createAudioElement(this);
  mimeTypeSupport = getMimeTypeSupport();
  switch (mimeTypeSupport.ordinal) {
    case 2:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_MAYBE_READY));
      break;
    case 0:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
      break;
    case 3:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORT_NOT_KNOWN));
      throw new IllegalArgumentException_1('unexpected MIME type support ' + mimeTypeSupport);
    default:throw new IllegalArgumentException_1('unknown MIME type support ' + mimeTypeSupport);
  }
}

function getMimeTypeSupport(){
  var canPlayType;
  $clinit_AbstractSound();
  var support;
  if (!isSupported_2()) {
    return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_NOT_SUPPORTED;
  }
  support = (canPlayType = createIfSupported().element.canPlayType('audio/mpeg') , canPlayType == 'no'?'':canPlayType);
  if ($equals('probably', support)) {
    return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY;
  }
  if ($equals('maybe', support)) {
    return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY;
  }
  return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_UNKNOWN;
}

defineSeed(103, 99, {}, Html5Sound_0);
_.getSoundType = function getSoundType_0(){
  return $clinit_SoundType() , HTML5;
}
;
_.play_0 = function play_0(){
  var $e0, elem;
  elem = this.audio.element;
  elem.pause();
  try {
    elem.currentTime = 0;
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (!instanceOf($e0, Q$Exception))
      throw $e0;
  }
  elem.currentTime != 0 && $createAudioElement(this);
  elem.play();
  return true;
}
;
_.setLooping_0 = function setLooping_0(looping){
  $setBooleanAttr(this.audio.element, looping);
}
;
_.setVolume_0 = function setVolume_0(volume){
  $setVolume_1(this.audio.element, volume / 100);
}
;
_.stop_0 = function stop_1(){
  this.audio.element.pause();
}
;
_.audio = null;
_.endedRegistration = null;
function Html5Sound$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(104, 1, {}, Html5Sound$1_0);
_.this$0 = null;
function NativeSound_0(url, soundControllerElement){
  var elem, m_0;
  $clinit_AbstractSound();
  var mimeTypeSupport;
  AbstractSound_0.call(this, url);
  this.soundControllerElement = soundControllerElement;
  elem = $createElement(url);
  $setVolume_0(elem, 0);
  $play(soundControllerElement, elem);
  this.element = $createElement(url);
  mimeTypeSupport = (m_0 = navigator.mimeTypes['audio/mpeg'] , m_0 != null && m_0.enabledPlugin != null?($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY):($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_NOT_SUPPORTED));
  switch (mimeTypeSupport.ordinal) {
    case 2:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_MAYBE_READY));
      break;
    case 0:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
      break;
    case 3:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORT_NOT_KNOWN));
      break;
    case 1:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_NOT_READY));
      break;
    default:throw new IllegalArgumentException_1('unknown MIME type support ' + mimeTypeSupport);
  }
}

defineSeed(105, 99, {}, NativeSound_0);
_.getSoundType = function getSoundType_1(){
  return $clinit_SoundType() , NATIVE;
}
;
_.play_0 = function play_1(){
  return $play(this.soundControllerElement, this.element);
}
;
_.setLooping_0 = function setLooping_1(looping){
  this.element.setAttribute('loop', 'infinite');
}
;
_.setVolume_0 = function setVolume_1(volume){
  $setVolume_0(this.element, volume);
}
;
_.stop_0 = function stop_2(){
  $stop(this.element);
}
;
_.element = null;
_.soundControllerElement = null;
function $clinit_Sound$LoadState(){
  $clinit_Sound$LoadState = nullMethod;
  LOAD_STATE_NOT_SUPPORTED = new Sound$LoadState_0('LOAD_STATE_NOT_SUPPORTED', 0);
  LOAD_STATE_SUPPORT_NOT_KNOWN = new Sound$LoadState_0('LOAD_STATE_SUPPORT_NOT_KNOWN', 1);
  LOAD_STATE_SUPPORTED_AND_READY = new Sound$LoadState_0('LOAD_STATE_SUPPORTED_AND_READY', 2);
  LOAD_STATE_SUPPORTED_MAYBE_READY = new Sound$LoadState_0('LOAD_STATE_SUPPORTED_MAYBE_READY', 3);
  LOAD_STATE_SUPPORTED_NOT_READY = new Sound$LoadState_0('LOAD_STATE_SUPPORTED_NOT_READY', 4);
  LOAD_STATE_UNINITIALIZED = new Sound$LoadState_0('LOAD_STATE_UNINITIALIZED', 5);
  $VALUES_1 = initValues(_3Lcom_allen_1sauer_gwt_voices_client_Sound$LoadState_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Sound$LoadState, [LOAD_STATE_NOT_SUPPORTED, LOAD_STATE_SUPPORT_NOT_KNOWN, LOAD_STATE_SUPPORTED_AND_READY, LOAD_STATE_SUPPORTED_MAYBE_READY, LOAD_STATE_SUPPORTED_NOT_READY, LOAD_STATE_UNINITIALIZED]);
}

function Sound$LoadState_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_2(){
  $clinit_Sound$LoadState();
  return $VALUES_1;
}

defineSeed(106, 39, makeCastMap([Q$Sound$LoadState, Q$Serializable, Q$Comparable, Q$Enum]), Sound$LoadState_0);
var $VALUES_1, LOAD_STATE_NOT_SUPPORTED, LOAD_STATE_SUPPORTED_AND_READY, LOAD_STATE_SUPPORTED_MAYBE_READY, LOAD_STATE_SUPPORTED_NOT_READY, LOAD_STATE_SUPPORT_NOT_KNOWN, LOAD_STATE_UNINITIALIZED;
function $clinit_SoundController(){
  $clinit_SoundController = nullMethod;
  $wnd.$GWT_VOICES_VERSION = '3.2.0';
}

function $createSound(this$static, url){
  var sound;
  sound = $createSoundImpl(this$static, url);
  sound.setVolume_0(100);
  return sound;
}

function $createSoundImpl(this$static, url){
  var c, c$array, c$index, c$max, sound;
  sound = null;
  for (c$array = this$static.preferredSoundTypes , c$index = 0 , c$max = c$array.length; c$index < c$max; ++c$index) {
    c = c$array[c$index];
    switch (c.ordinal) {
      case 1:
        sound = $createSoundImplHtml5(url);
        break;
      case 0:
        sound = $createSoundImplFlash(this$static, url);
        break;
      case 2:
        sound = $createSoundImplWebAudio(url);
        break;
      case 3:
        sound = $createSoundImplWebAudio(url);
    }
    if (sound) {
      return sound;
    }
  }
  sound = $createSoundImplWebAudio(url);
  if (sound) {
    return sound;
  }
  sound = $createSoundImplFlash(this$static, url);
  if (sound) {
    return sound;
  }
  sound = $createSoundImplHtml5(url);
  if (sound) {
    return sound;
  }
  sound = new NativeSound_0(url, this$static.soundContainer);
  return sound;
}

function $createSoundImplFlash(this$static, url){
  var mimeTypeSupport, sound, vm;
  if (url.indexOf('data:') == 0) {
    return null;
  }
  $clinit_FlashMovie();
  if (impl_1.impl.getMajorVersion() >= 9) {
    vm = $getVoicesMovie(this$static);
    mimeTypeSupport = $getMimeTypeSupport(vm);
    if (mimeTypeSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY) || mimeTypeSupport == MIME_TYPE_SUPPORT_NOT_READY) {
      sound = new FlashSound_0(url, vm);
      return sound;
    }
  }
  return null;
}

function $createSoundImplHtml5(url){
  if (getMimeTypeSupport() == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY)) {
    return new Html5Sound_0(url);
  }
  return null;
}

function $createSoundImplWebAudio(url){
  if (getMimeTypeSupport_0() == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY)) {
    return new WebAudioSound_0(url);
  }
  return null;
}

function $getVoicesMovie(this$static){
  if (!this$static.voicesWrapper) {
    this$static.voicesWrapper = new VoicesMovie_0('gwtVoices' + uniqueId++, this$static.gwtVoicesSwfBaseUrl);
    $appendChild(this$static.soundContainer, ($clinit_PotentialElement() , $resolve(this$static.voicesWrapper.element)));
  }
  return this$static.voicesWrapper;
}

function $setPreferredSoundTypes(this$static, soundTypes){
  var s$index, s$max;
  for (s$index = 0 , s$max = soundTypes.length; s$index < s$max; ++s$index) {
  }
  this$static.preferredSoundTypes = soundTypes;
}

function SoundController_0(){
  var s, i, gwtVoices, style;
  $clinit_SoundController();
  this.soundContainer = $doc.createElement('div');
  this.gwtVoicesSwfBaseUrl = (s = $doc.location.href , i = s.indexOf('#') , i != -1 && (s = s.substring(0, i)) , i = s.indexOf('?') , i != -1 && (s = s.substring(0, i)) , i = s.lastIndexOf('/') , i != -1 && (s = s.substring(0, i)) , s.length > 0?s + '/':'') + $moduleName + '/';
  gwtVoices = (ensureParameterMap() , $get_4(paramMap, 'gwt-voices'));
  $equals(($clinit_SoundType() , FLASH).queryParameterValue, gwtVoices)?$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [FLASH])):$equals(HTML5.queryParameterValue, gwtVoices)?$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [HTML5])):$equals(WEB_AUDIO.queryParameterValue, gwtVoices)?$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [WEB_AUDIO])):$equals(NATIVE.queryParameterValue, gwtVoices)?$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [NATIVE])):$setPreferredSoundTypes(this, initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [WEB_AUDIO, FLASH, HTML5]));
  $appendChild(getBodyElement(), this.soundContainer);
  style = this.soundContainer.style;
  style['position'] = ($clinit_Style$Position() , 'absolute');
  style['overflow'] = ($clinit_Style$Overflow() , 'hidden');
  style['left'] = -500 + ($clinit_Style$Unit() , 'px');
  style['top'] = '-500px';
  style['width'] = '0px';
  style['height'] = '0px';
}

defineSeed(107, 1, {}, SoundController_0);
_.preferredSoundTypes = null;
_.voicesWrapper = null;
function $clinit_SoundController$MimeTypeSupport(){
  $clinit_SoundController$MimeTypeSupport = nullMethod;
  MIME_TYPE_NOT_SUPPORTED = new SoundController$MimeTypeSupport_0('MIME_TYPE_NOT_SUPPORTED', 0);
  MIME_TYPE_SUPPORT_NOT_READY = new SoundController$MimeTypeSupport_0('MIME_TYPE_SUPPORT_NOT_READY', 1);
  MIME_TYPE_SUPPORT_READY = new SoundController$MimeTypeSupport_0('MIME_TYPE_SUPPORT_READY', 2);
  MIME_TYPE_SUPPORT_UNKNOWN = new SoundController$MimeTypeSupport_0('MIME_TYPE_SUPPORT_UNKNOWN', 3);
  $VALUES_2 = initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundController$MimeTypeSupport_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundController$MimeTypeSupport, [MIME_TYPE_NOT_SUPPORTED, MIME_TYPE_SUPPORT_NOT_READY, MIME_TYPE_SUPPORT_READY, MIME_TYPE_SUPPORT_UNKNOWN]);
}

function SoundController$MimeTypeSupport_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_3(){
  $clinit_SoundController$MimeTypeSupport();
  return $VALUES_2;
}

defineSeed(108, 39, makeCastMap([Q$SoundController$MimeTypeSupport, Q$Serializable, Q$Comparable, Q$Enum]), SoundController$MimeTypeSupport_0);
var $VALUES_2, MIME_TYPE_NOT_SUPPORTED, MIME_TYPE_SUPPORT_NOT_READY, MIME_TYPE_SUPPORT_READY, MIME_TYPE_SUPPORT_UNKNOWN;
function $clinit_SoundType(){
  $clinit_SoundType = nullMethod;
  FLASH = new SoundType_0('FLASH', 0, 'flash');
  HTML5 = new SoundType_0('HTML5', 1, 'html5');
  NATIVE = new SoundType_0('NATIVE', 2, 'native');
  WEB_AUDIO = new SoundType_0('WEB_AUDIO', 3, 'webaudio');
  $VALUES_3 = initValues(_3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$SoundType, [FLASH, HTML5, NATIVE, WEB_AUDIO]);
}

function SoundType_0(enum$name, enum$ordinal, queryParameterValue){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.queryParameterValue = queryParameterValue;
}

function values_4(){
  $clinit_SoundType();
  return $VALUES_3;
}

defineSeed(109, 39, makeCastMap([Q$SoundType, Q$Serializable, Q$Comparable, Q$Enum]), SoundType_0);
_.queryParameterValue = null;
var $VALUES_3, FLASH, HTML5, NATIVE, WEB_AUDIO;
function $clinit_WebAudioSound(){
  $clinit_WebAudioSound = nullMethod;
  $clinit_AbstractSound();
  audioContext = createAudioContext();
}

function $createVoice(this$static, url){
  var context = audioContext;
  var request = new $wnd.XMLHttpRequest;
  request.open('GET', url, true);
  request.responseType = 'arraybuffer';
  var self_0 = this$static;
  request.onload = function(){
    try {
      self_0.buffer_0 = context.createBuffer(request.response, false);
      self_0.soundLoaded_0();
    }
     catch (e) {
      self_0.soundLoadFailed();
    }
  }
  ;
  request.send();
}

function WebAudioSound_0(url){
  $clinit_WebAudioSound();
  var $e0, mimeTypeSupport;
  AbstractSound_0.call(this, url);
  try {
    $createVoice(this, url);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Throwable)) {
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
    }
     else 
      throw $e0;
  }
  mimeTypeSupport = getMimeTypeSupport_0();
  switch (mimeTypeSupport.ordinal) {
    case 1:
    case 2:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_NOT_READY));
      break;
    case 0:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
      break;
    case 3:
      $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORT_NOT_KNOWN));
      break;
    default:throw new IllegalArgumentException_1('unknown MIME type support ' + mimeTypeSupport);
  }
}

function createAudioContext(){
  try {
    return new AudioContext;
  }
   catch (ignore) {
  }
  try {
    return new webkitAudioContext;
  }
   catch (ignore) {
  }
  return null;
}

function getMimeTypeSupport_0(){
  $clinit_WebAudioSound();
  if (!audioContext) {
    return $clinit_SoundController$MimeTypeSupport() , MIME_TYPE_NOT_SUPPORTED;
  }
  return getMimeTypeSupport();
}

defineSeed(110, 99, {}, WebAudioSound_0);
_.getSoundType = function getSoundType_2(){
  return $clinit_SoundType() , WEB_AUDIO;
}
;
_.plackbackCompleted = function plackbackCompleted(){
  $fireOnPlaybackComplete(this.soundHandlerCollection, this);
}
;
_.play_0 = function play_2(){
  var buffer = this.buffer_0;
  if (buffer == null) {
    return false;
  }
  this.stop_0();
  var context = audioContext;
  var voice = context.createBufferSource();
  this.voice = voice;
  this.looping && (voice.loop = true);
  var node = voice;
  var volume = this.volume_0;
  if (volume != 100) {
    var gainNode = context.createGainNode();
    gainNode.gain.value = volume / 100;
    node.connect(gainNode);
    node = gainNode;
  }
  node.connect(context.destination);
  voice.buffer = buffer;
  voice.noteOn(context.currentTime);
  if (!voice.loop) {
    var self_0 = this;
    setTimeout(function(){
      self_0.plackbackCompleted();
    }
    , voice.buffer.duration * 1000);
  }
  return true;
}
;
_.setLooping_0 = function setLooping_2(looping){
  this.looping = looping;
}
;
_.setVolume_0 = function setVolume_2(volume){
  this.volume_0 = volume;
}
;
_.soundLoadFailed = function soundLoadFailed(){
  $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
}
;
_.soundLoaded_0 = function soundLoaded(){
  $setLoadState(this, ($clinit_Sound$LoadState() , LOAD_STATE_SUPPORTED_AND_READY));
}
;
_.stop_0 = function stop_3(){
  var context = audioContext;
  var voice = this.voice;
  if (voice == null) {
    return;
  }
  voice.noteOff(context.currentTime);
  this.voice = null;
}
;
_.buffer_0 = null;
_.looping = false;
_.voice = null;
_.volume_0 = 0;
var audioContext = null;
defineSeed(112, 1, {});
_.source = null;
function PlaybackCompleteEvent_0(source){
  this.source = source;
}

defineSeed(111, 112, {}, PlaybackCompleteEvent_0);
_.toString$ = function toString_7(){
  var sound;
  sound = this.source;
  return getSimpleName(Lcom_allen_1sauer_gwt_voices_client_handler_PlaybackCompleteEvent_2_classLit) + ': ' + sound;
}
;
function $advanceToFind(iter, o){
  var t;
  while (iter.hasNext()) {
    t = iter.next_0();
    if (o == null?t == null:equals__devirtual$(o, t)) {
      return iter;
    }
  }
  return null;
}

function $remove_1(this$static, o){
  var iter;
  iter = $advanceToFind(this$static.iterator(), o);
  if (iter) {
    iter.remove_2();
    return true;
  }
   else {
    return false;
  }
}

function $removeAll_0(this$static, c){
  var changed, iter;
  iter = new AbstractList$IteratorImpl_0(this$static);
  changed = false;
  while (iter.i < iter.this$0_0.size_0()) {
    if (c.contains_0($next_2(iter))) {
      $remove_11(iter);
      changed = true;
    }
  }
  return changed;
}

function $toString_0(this$static){
  var comma, iter, sb, value;
  sb = new StringBuffer_0;
  comma = null;
  sb.impl.string += '[';
  iter = this$static.iterator();
  while (iter.hasNext()) {
    comma != null?($append_3(sb.impl, comma) , sb):(comma = ', ');
    value = iter.next_0();
    $append_3(sb.impl, value === this$static?'(this Collection)':'' + value);
  }
  sb.impl.string += ']';
  return sb.impl.string;
}

defineSeed(116, 1, {});
_.add = function add(o){
  throw new UnsupportedOperationException_1('Add not supported on this collection');
}
;
_.contains_0 = function contains(o){
  var iter;
  iter = $advanceToFind(this.iterator(), o);
  return !!iter;
}
;
_.isEmpty = function isEmpty(){
  return this.size_0() == 0;
}
;
_.remove = function remove_0(o){
  return $remove_1(this, o);
}
;
_.retainAll = function retainAll(c){
  var changed, iter;
  iter = this.iterator();
  changed = false;
  while (iter.hasNext()) {
    if (!c.contains_0(iter.next_0())) {
      iter.remove_2();
      changed = true;
    }
  }
  return changed;
}
;
_.toString$ = function toString_8(){
  return $toString_0(this);
}
;
function checkIndex(index, size){
  (index < 0 || index >= size) && indexOutOfBounds(index, size);
}

function indexOutOfBounds(index, size){
  throw new IndexOutOfBoundsException_1('Index: ' + index + ', Size: ' + size);
}

defineSeed(115, 116, makeCastMap([Q$List]));
_.add_0 = function add_0(index, element){
  throw new UnsupportedOperationException_1('Add not supported on this list');
}
;
_.add = function add_1(obj){
  this.add_0(this.size_0(), obj);
  return true;
}
;
_.equals$ = function equals_3(o){
  var elem, elemOther, iter, iterOther, other;
  if (o === this) {
    return true;
  }
  if (!instanceOf(o, Q$List)) {
    return false;
  }
  other = o;
  if (this.size_0() != other.size_0()) {
    return false;
  }
  iter = this.iterator();
  iterOther = other.iterator();
  while (iter.hasNext()) {
    elem = iter.next_0();
    elemOther = iterOther.next_0();
    if (!(elem == null?elemOther == null:equals__devirtual$(elem, elemOther))) {
      return false;
    }
  }
  return true;
}
;
_.hashCode$ = function hashCode_2(){
  var iter, k, obj;
  k = 1;
  iter = this.iterator();
  while (iter.hasNext()) {
    obj = iter.next_0();
    k = 31 * k + (obj == null?0:hashCode__devirtual$(obj));
    k = ~~k;
  }
  return k;
}
;
_.iterator = function iterator_0(){
  return new AbstractList$IteratorImpl_0(this);
}
;
_.listIterator = function listIterator(){
  return this.listIterator_0(0);
}
;
_.listIterator_0 = function listIterator_0(from){
  return new AbstractList$ListIteratorImpl_0(this, from);
}
;
_.remove_0 = function remove_1(index){
  throw new UnsupportedOperationException_1('Remove not supported on this list');
}
;
function $$init(this$static){
  this$static.array = initDim(_3Ljava_lang_Object_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Object, 0, 0);
}

function $add_3(this$static, index, o){
  (index < 0 || index > this$static.size) && indexOutOfBounds(index, this$static.size);
  splice_0(this$static.array, index, 0, o);
  ++this$static.size;
}

function $add_4(this$static, o){
  setCheck(this$static.array, this$static.size++, o);
  return true;
}

function $clear(this$static){
  this$static.array = initDim(_3Ljava_lang_Object_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Object, 0, 0);
  this$static.size = 0;
}

function $get(this$static, index){
  checkIndex(index, this$static.size);
  return this$static.array[index];
}

--></script>
<script><!--
function $indexOf(this$static, o, index){
  for (; index < this$static.size; ++index) {
    if (equalsWithNullCheck(o, this$static.array[index])) {
      return index;
    }
  }
  return -1;
}

function $remove_2(this$static, index){
  var previous;
  previous = (checkIndex(index, this$static.size) , this$static.array[index]);
  splice(this$static.array, index, 1);
  --this$static.size;
  return previous;
}

function $remove_3(this$static, o){
  var i;
  i = $indexOf(this$static, o, 0);
  if (i == -1) {
    return false;
  }
  $remove_2(this$static, i);
  return true;
}

function $toArray(this$static, out){
  var i;
  out.length < this$static.size && (out = createFrom(out, this$static.size));
  for (i = 0; i < this$static.size; ++i) {
    setCheck(out, i, this$static.array[i]);
  }
  out.length > this$static.size && setCheck(out, this$static.size, null);
  return out;
}

function ArrayList_0(){
  $$init(this);
}

function ArrayList_1(c){
  $$init(this);
  spliceArray(this.array, 0, 0, cloneSubrange(c.array, 0, c.size));
  this.size = this.array.length;
}

function splice(array, index, deleteCount){
  array.splice(index, deleteCount);
}

function splice_0(array, index, deleteCount, value){
  array.splice(index, deleteCount, value);
}

function spliceArray(array, index, deleteCount, values){
  Array.prototype.splice.apply(array, [index, deleteCount].concat(values));
}

defineSeed(114, 115, makeCastMap([Q$Serializable, Q$List]), ArrayList_0, ArrayList_1);
_.add_0 = function add_2(index, o){
  $add_3(this, index, o);
}
;
_.add = function add_3(o){
  return $add_4(this, o);
}
;
_.contains_0 = function contains_0(o){
  return $indexOf(this, o, 0) != -1;
}
;
_.get = function get(index){
  return $get(this, index);
}
;
_.isEmpty = function isEmpty_0(){
  return this.size == 0;
}
;
_.remove_0 = function remove_2(index){
  return $remove_2(this, index);
}
;
_.remove = function remove_3(o){
  return $remove_3(this, o);
}
;
_.size_0 = function size_0(){
  return this.size;
}
;
_.size = 0;
function $fireOnPlaybackComplete(this$static, sender){
  var handler, handler$iterator;
  new PlaybackCompleteEvent_0(sender);
  for (handler$iterator = new AbstractList$IteratorImpl_0(this$static); handler$iterator.i < handler$iterator.this$0_0.size_0();) {
    handler = $next_2(handler$iterator);
    handler.this$0.playing = false;
  }
}

function $fireOnSoundLoadStateChange(this$static, sender){
  var event_0, handler, handler$iterator;
  event_0 = new SoundLoadStateChangeEvent_0(sender);
  for (handler$iterator = new AbstractList$IteratorImpl_0(this$static); handler$iterator.i < handler$iterator.this$0_0.size_0();) {
    handler = $next_2(handler$iterator);
    $onSoundLoadStateChange(handler, event_0);
  }
}

function SoundHandlerCollection_0(){
  $$init(this);
}

defineSeed(113, 114, makeCastMap([Q$Serializable, Q$List]), SoundHandlerCollection_0);
function SoundLoadStateChangeEvent_0(source){
  this.source = source;
  this.loadState = source.loadState;
}

defineSeed(117, 112, {}, SoundLoadStateChangeEvent_0);
_.toString$ = function toString_9(){
  var sound;
  sound = this.source;
  return getSimpleName(Lcom_allen_1sauer_gwt_voices_client_handler_SoundLoadStateChangeEvent_2_classLit) + ': ' + sound + '; ' + this.loadState.name_1;
}
;
_.loadState = null;
function $clinit_FlashMovie(){
  $clinit_FlashMovie = nullMethod;
  impl_1 = new FlashMovieImplPlayN_0;
}

defineSeed(118, 1, {});
_.element = null;
var impl_1 = null;
function $clinit_VoicesMovie(){
  $clinit_VoicesMovie = nullMethod;
  $clinit_FlashMovie();
  FLASH_SUPPORTED_MIME_TYPES = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['audio/mpeg', 'audio/mpeg; codecs=MP3']);
}

function $callCreateSound(this$static, id, soundURL, checkPolicyFile){
  var elem = this$static.element;
  elem.createSound(id, soundURL, checkPolicyFile);
}

function $getMimeTypeSupport(this$static){
  switch (this$static.flashSupport.ordinal) {
    case 2:
    case 1:
      return contains_1(FLASH_SUPPORTED_MIME_TYPES)?($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY):($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_NOT_SUPPORTED);
    case 3:
    case 0:
      return this$static.flashSupport;
    default:throw new RuntimeException_0('Unhandled flash support value ' + this$static.flashSupport);
  }
}

function $installFlashCallbackHooks(this$static, id_0){
  $doc.VoicesMovie === undefined && ($doc.VoicesMovie = {});
  var self_0 = this$static;
  $doc.VoicesMovie[id_0] = {};
  $doc.VoicesMovie[id_0].ready = function(){
    self_0.movieReady();
  }
  ;
  $doc.VoicesMovie[id_0].soundLoaded = function(id){
    $clinit_FlashSound();
    $scheduleDeferred(($clinit_SchedulerImpl() , INSTANCE), new FlashSound$2_0(id));
    return true;
  }
  ;
  $doc.VoicesMovie[id_0].playbackCompleted = function(id){
    $clinit_FlashSound();
    $scheduleDeferred(($clinit_SchedulerImpl() , INSTANCE), new FlashSound$1_0(id));
  }
  ;
  $doc.VoicesMovie[id_0].log = function(text){
    self_0.debug_0('FLASH[' + id_0 + ']: ' + text);
  }
  ;
}

function $movieUnsupported(this$static){
  var flashSound, flashSound$iterator;
  for (flashSound$iterator = new AbstractList$IteratorImpl_0(this$static.unitializedSoundList); flashSound$iterator.i < flashSound$iterator.this$0_0.size_0();) {
    flashSound = $next_2(flashSound$iterator);
    $setLoadState(flashSound, ($clinit_Sound$LoadState() , LOAD_STATE_NOT_SUPPORTED));
  }
}

function $playSound(this$static, id){
  var elem;
  if (this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY)) {
    return elem = this$static.element , elem.playSound(id);
  }
  return false;
}

function $registerSound_0(this$static, flashSound){
  this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY)?$callCreateSound(this$static, flashSound.soundNumber, flashSound.url, flashSound.crossOrigin):$add_4(this$static.unitializedSoundList, flashSound);
}

function $setLooping(this$static, id, looping){
  var elem;
  this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY) && (elem = this$static.element , elem.setLooping(id, looping?2147483647:0) , undefined);
}

function $setVolume(this$static, id, volume){
  var elem;
  this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY) && (elem = this$static.element , elem.setVolume(id, volume / 100) , undefined);
}

function $stopSound(this$static, id){
  var elem;
  this$static.flashSupport == ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY) && (elem = this$static.element , elem.stopSound(id) , undefined);
}

function VoicesMovie_0(id, gwtVoicesSwfBaseUrl){
  $clinit_VoicesMovie();
  this.element = $createElementMaybeSetURL(impl_1, id, gwtVoicesSwfBaseUrl + 'gwt-voices.swf');
  this.flashSupport = ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_UNKNOWN);
  this.unitializedSoundList = new ArrayList_0;
  $installFlashCallbackHooks(this, id);
  if (impl_1.impl.getMajorVersion() >= 9) {
    this.flashSupport = MIME_TYPE_SUPPORT_NOT_READY;
  }
   else {
    this.flashSupport = MIME_TYPE_NOT_SUPPORTED;
    $scheduleDeferred(($clinit_SchedulerImpl() , INSTANCE), new VoicesMovie$1_0(this));
  }
}

defineSeed(119, 118, {}, VoicesMovie_0);
_.debug_0 = function debug(text){
}
;
_.movieReady = function movieReady(){
  var flashSound, iterator;
  this.flashSupport = ($clinit_SoundController$MimeTypeSupport() , MIME_TYPE_SUPPORT_READY);
  for (iterator = new AbstractList$IteratorImpl_0(this.unitializedSoundList); iterator.i < iterator.this$0_0.size_0();) {
    flashSound = $next_2(iterator);
    $callCreateSound(this, flashSound.soundNumber, flashSound.url, flashSound.crossOrigin);
    $remove_11(iterator);
  }
}
;
var FLASH_SUPPORTED_MIME_TYPES;
function VoicesMovie$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(120, 1, {}, VoicesMovie$1_0);
_.execute = function execute_1(){
  $movieUnsupported(this.this$0);
}
;
_.this$0 = null;
defineSeed(121, 1, {});
_.getMajorVersion = function getMajorVersion(){
  var versionString;
  versionString = this.getVersionString();
  return versionString == null?0:__parseAndValidateInt($replaceFirst(versionString, ',.*', ''));
}
;
_.getVersionString = function getVersionString(){
  var rawVersionString;
  rawVersionString = this.getRawVersionString();
  return rawVersionString == null?null:$replaceFirst($replaceAll(rawVersionString, '\\D*(\\d+)', '$1,'), ',$', '');
}
;
function FlashMovieImplIE6_0(){
}

defineSeed(122, 121, {}, FlashMovieImplIE6_0);
_.createElementMaybeSetURL = function createElementMaybeSetURL(id, url){
  var elem = $doc.createElement('object');
  elem.tabIndex = -1;
  elem.id = id;
  elem.classid = 'clsid:d27cdb6e-ae6d-11cf-96b8-444553540000';
  elem.codebase = 'http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0';
  elem.FlashVars = 'id=' + id;
  elem.Movie = url;
  return elem;
}
;
_.getRawVersionString = function getRawVersionString(){
  try {
    return (new ActiveXObject('ShockwaveFlash.ShockwaveFlash')).GetVariable('$version');
  }
   catch (e) {
    return null;
  }
}
;
function $createElementMaybeSetURL(this$static, id, url){
  return this$static.impl.createElementMaybeSetURL(id, url);
}

function FlashMovieImplPlayN_0(){
  $wnd.navigator.userAgent.indexOf('MSIE') != -1?(this.impl = new FlashMovieImplIE6_0):(this.impl = new FlashMovieImplSafari_0);
  $logImpl((platform_1.log_0 , 0), 'CHOSE: ' + this.impl.___clazz$.typeName, null);
}

defineSeed(123, 121, {}, FlashMovieImplPlayN_0);
_.createElementMaybeSetURL = function createElementMaybeSetURL_0(id, url){
  return this.impl.createElementMaybeSetURL(id, url);
}
;
_.getMajorVersion = function getMajorVersion_0(){
  return this.impl.getMajorVersion();
}
;
_.getRawVersionString = function getRawVersionString_0(){
  return this.impl.getRawVersionString();
}
;
_.getVersionString = function getVersionString_0(){
  return this.impl.getVersionString();
}
;
_.impl = null;
defineSeed(125, 121, {});
_.createElementMaybeSetURL = function createElementMaybeSetURL_1(id, url){
  var elem = $doc.createElement('object');
  elem.setAttribute('id', id);
  elem.setAttribute('type', 'application/x-shockwave-flash');
  elem.setAttribute('data', url);
  var param = $doc.createElement('param');
  param.setAttribute('name', 'FlashVars');
  param.setAttribute('value', 'id=' + id);
  elem.appendChild(param);
  return elem;
}
;
_.getRawVersionString = function getRawVersionString_1(){
  var p = navigator.plugins['Shockwave Flash'];
  return p == null?null:p.description;
}
;
function FlashMovieImplSafari_0(){
}

defineSeed(124, 125, {}, FlashMovieImplSafari_0);
function $stop(elem){
  var parent_0 = elem.parentNode;
  parent_0 != null && parent_0.removeChild(elem);
}

function $createElement(url){
  var elem = $doc.createElement('object');
  elem.setAttribute('data', url);
  elem.setAttribute('autostart', 'true');
  return elem;
}

function $setVolume_0(elem, volume){
  elem.setAttribute('volume', '' + volume);
}

function $play(soundControllerElement, elem){
  var parent_0 = elem.parentNode;
  parent_0 != null && parent_0.removeChild(elem);
  soundControllerElement.appendChild(elem);
  return true;
}

var uniqueId = 1000;
function contains_1(arr){
  var element, element$index, element$max;
  for (element$index = 0 , element$max = arr.length; element$index < element$max; ++element$index) {
    element = arr[element$index];
    if ($equals(element, 'audio/mpeg')) {
      return true;
    }
  }
  return false;
}

function getSimpleName(clazz){
  var name_0;
  name_0 = clazz.typeName;
  return $substring(name_0, $lastIndexOf(name_0, fromCodePoint(46)) + 1);
}

function equals__devirtual$(this$static, other){
  var maybeJsoInvocation;
  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.equals$(other):maybeJsoInvocation === other;
}

function getClass__devirtual$(this$static){
  var maybeJsoInvocation;
  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.___clazz$:Lcom_google_gwt_core_client_JavaScriptObject_2_classLit;
}

function hashCode__devirtual$(this$static){
  var maybeJsoInvocation;
  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.hashCode$():getHashCode(maybeJsoInvocation);
}

function toString__devirtual$(this$static){
  var maybeJsoInvocation;
  return maybeJsoInvocation = this$static , isJavaObject(maybeJsoInvocation)?maybeJsoInvocation.toString$():maybeJsoInvocation.toString?maybeJsoInvocation.toString():'[JavaScriptObject]';
}

function $arcTo(this$static, x1, y1, x2, y2, radius){
  this$static.arcTo(x1, y1, x2, y2, radius);
}

function $clearRect(this$static, x, y, w, h_0){
  this$static.clearRect(x, y, w, h_0);
}

function $createPattern(this$static, image, repetition){
  return this$static.createPattern(image, repetition);
}

function $drawImage(this$static, image, dx, dy, dw, dh){
  this$static.drawImage(image, dx, dy, dw, dh);
}

function $drawImage_0(this$static, image, sx, sy, sw, sh, dx, dy, dw, dh){
  this$static.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
}

function $fillRect(this$static, x, y, w, h_0){
  this$static.fillRect(x, y, w, h_0);
}

function $fillText(this$static, text, x, y){
  this$static.fillText && this$static.fillText(text, x, y);
}

function $moveTo(this$static, x, y){
  this$static.moveTo(x, y);
}

function $scale(this$static, x, y){
  this$static.scale(x, y);
}

function $setFillStyleWeb(this$static, fillStyle){
  this$static.fillStyle = fillStyle;
}

function $setFont(this$static, f){
  this$static.font = f;
}

function $setGlobalAlpha(this$static, alpha){
  this$static.globalAlpha = alpha;
}

function $setLineCap(this$static, lineCap){
  this$static.lineCap = lineCap;
}

function $setLineJoin(this$static, lineJoin){
  this$static.lineJoin = lineJoin;
}

function $setStrokeStyleWeb(this$static, strokeStyle){
  this$static.strokeStyle = strokeStyle;
}

function $setTextBaseline(this$static, baseline){
  this$static.textBaseline = baseline;
}

function $strokeText(this$static, text, x, y){
  this$static.strokeText(text, x, y);
}

function $transform(this$static, m11, m12, m21, m22, dx, dy){
  this$static.transform(m11, m12, m21, m22, dx, dy);
}

function $translate(this$static, x, y){
  this$static.translate(x, y);
}

function $clinit_Context2d$LineCap(){
  $clinit_Context2d$LineCap = nullMethod;
  BUTT = new Context2d$LineCap_0('BUTT', 0, 'butt');
  ROUND = new Context2d$LineCap_0('ROUND', 1, 'round');
  SQUARE = new Context2d$LineCap_0('SQUARE', 2, 'square');
  $VALUES_4 = initValues(_3Lcom_google_gwt_canvas_dom_client_Context2d$LineCap_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Context2d$LineCap, [BUTT, ROUND, SQUARE]);
}

function Context2d$LineCap_0(enum$name, enum$ordinal, value){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.value_0 = value;
}

function values_5(){
  $clinit_Context2d$LineCap();
  return $VALUES_4;
}

defineSeed(135, 39, makeCastMap([Q$Context2d$LineCap, Q$Serializable, Q$Comparable, Q$Enum]), Context2d$LineCap_0);
_.value_0 = null;
var $VALUES_4, BUTT, ROUND, SQUARE;
function $clinit_Context2d$LineJoin(){
  $clinit_Context2d$LineJoin = nullMethod;
  BEVEL = new Context2d$LineJoin_0('BEVEL', 0, 'bevel');
  MITER = new Context2d$LineJoin_0('MITER', 1, 'miter');
  ROUND_0 = new Context2d$LineJoin_0('ROUND', 2, 'round');
  $VALUES_5 = initValues(_3Lcom_google_gwt_canvas_dom_client_Context2d$LineJoin_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Context2d$LineJoin, [BEVEL, MITER, ROUND_0]);
}

function Context2d$LineJoin_0(enum$name, enum$ordinal, value){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.value_0 = value;
}

function values_6(){
  $clinit_Context2d$LineJoin();
  return $VALUES_5;
}

defineSeed(136, 39, makeCastMap([Q$Context2d$LineJoin, Q$Serializable, Q$Comparable, Q$Enum]), Context2d$LineJoin_0);
_.value_0 = null;
var $VALUES_5, BEVEL, MITER, ROUND_0;
function $clinit_Context2d$Repetition(){
  $clinit_Context2d$Repetition = nullMethod;
  NO_REPEAT = new Context2d$Repetition_0('NO_REPEAT', 0, 'no-repeat');
  REPEAT = new Context2d$Repetition_0('REPEAT', 1, 'repeat');
  REPEAT_X = new Context2d$Repetition_0('REPEAT_X', 2, 'repeat-x');
  REPEAT_Y = new Context2d$Repetition_0('REPEAT_Y', 3, 'repeat-y');
  $VALUES_6 = initValues(_3Lcom_google_gwt_canvas_dom_client_Context2d$Repetition_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Context2d$Repetition, [NO_REPEAT, REPEAT, REPEAT_X, REPEAT_Y]);
}

function Context2d$Repetition_0(enum$name, enum$ordinal, value){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.value_0 = value;
}

function values_7(){
  $clinit_Context2d$Repetition();
  return $VALUES_6;
}

defineSeed(137, 39, makeCastMap([Q$Context2d$Repetition, Q$Serializable, Q$Comparable, Q$Enum]), Context2d$Repetition_0);
_.value_0 = null;
var $VALUES_6, NO_REPEAT, REPEAT, REPEAT_X, REPEAT_Y;
function $clinit_Context2d$TextBaseline(){
  $clinit_Context2d$TextBaseline = nullMethod;
  ALPHABETIC = new Context2d$TextBaseline_0('ALPHABETIC', 0, 'alphabetic');
  BOTTOM = new Context2d$TextBaseline_0('BOTTOM', 1, 'bottom');
  HANGING = new Context2d$TextBaseline_0('HANGING', 2, 'hanging');
  IDEOGRAPHIC = new Context2d$TextBaseline_0('IDEOGRAPHIC', 3, 'ideographic');
  MIDDLE = new Context2d$TextBaseline_0('MIDDLE', 4, 'middle');
  TOP = new Context2d$TextBaseline_0('TOP', 5, 'top');
  $VALUES_7 = initValues(_3Lcom_google_gwt_canvas_dom_client_Context2d$TextBaseline_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Context2d$TextBaseline, [ALPHABETIC, BOTTOM, HANGING, IDEOGRAPHIC, MIDDLE, TOP]);
}

function Context2d$TextBaseline_0(enum$name, enum$ordinal, value){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.value_0 = value;
}

function values_8(){
  $clinit_Context2d$TextBaseline();
  return $VALUES_7;
}

defineSeed(138, 39, makeCastMap([Q$Context2d$TextBaseline, Q$Serializable, Q$Comparable, Q$Enum]), Context2d$TextBaseline_0);
_.value_0 = null;
var $VALUES_7, ALPHABETIC, BOTTOM, HANGING, IDEOGRAPHIC, MIDDLE, TOP;
function currentTimeMillis(){
  return (new Date).getTime();
}

function setUncaughtExceptionHandler(handler){
  sUncaughtExceptionHandler = handler;
}

var sUncaughtExceptionHandler = null;
defineSeed(145, 97, makeCastMap([Q$Serializable, Q$Exception, Q$Throwable]));
function RuntimeException_0(message){
  this.fillInStackTrace();
  this.detailMessage = message;
}

function RuntimeException_1(message, cause){
  this.fillInStackTrace();
  this.cause_0 = cause;
  this.detailMessage = message;
}

function RuntimeException_2(cause){
  Throwable_1.call(this, cause);
}

defineSeed(144, 145, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), RuntimeException_0, RuntimeException_2);
function JavaScriptException_0(e){
  this.fillInStackTrace();
  this.e = e;
  this.description_0 = '';
  $createStackTrace(new StackTraceCreator$CollectorChromeNoSourceMap_0, this);
}

function getExceptionDescription(e){
  return instanceOfJso(e)?e == null?null:e.message:e + '';
}

function getExceptionName(e){
  return e == null?'null':instanceOfJso(e)?e == null?null:e.name:instanceOf(e, Q$String)?'String':getClass__devirtual$(e).typeName;
}

function getExceptionProperties(e){
  return instanceOfJso(e)?$getProperties(($clinit_StackTraceCreator$CollectorChrome() , e)):'';
}

defineSeed(143, 144, makeCastMap([Q$JavaScriptException, Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), JavaScriptException_0);
_.getMessage = function getMessage_1(){
  this.message_0 == null && (this.name_0 = getExceptionName(this.e) , this.description_0 = this.description_0 + ': ' + getExceptionDescription(this.e) , this.message_0 = '(' + this.name_0 + ') ' + getExceptionProperties(this.e) + this.description_0 , undefined);
  return this.message_0;
}
;
_.description_0 = '';
_.e = null;
_.message_0 = null;
_.name_0 = null;
function $push(this$static, value){
  this$static[this$static.length] = value;
}

function $push_0(this$static, value){
  this$static[this$static.length] = value;
}

function $unshift(this$static, value){
  this$static.unshift(value);
}

function create(milliseconds){
  return new Date(milliseconds);
}

defineSeed(152, 1, {});
function apply_11(jsFunction, thisObj, arguments_0){
  return jsFunction.apply(thisObj, arguments_0);
  var __0;
}

function enter(){
  var now;
  if (entryDepth != 0) {
    now = currentTimeMillis();
    if (now - watchdogEntryDepthLastScheduled > 2000) {
      watchdogEntryDepthLastScheduled = now;
      watchdogEntryDepthTimerId = watchdogEntryDepthSchedule();
    }
  }
  if (entryDepth++ == 0) {
    $flushEntryCommands(($clinit_SchedulerImpl() , INSTANCE));
    return true;
  }
  return false;
}

function entry_0(jsFunction){
  return function(){
    try {
      return entry0(jsFunction, this, arguments);
    }
     catch (e) {
      throw e;
    }
  }
  ;
}

function entry0(jsFunction, thisObj, arguments_0){
  var $e0, initialEntry, t;
  initialEntry = enter();
  try {
    if (sUncaughtExceptionHandler) {
      try {
        return apply_11(jsFunction, thisObj, arguments_0);
      }
       catch ($e0) {
        $e0 = caught_0($e0);
        if (instanceOf($e0, Q$Throwable)) {
          t = $e0;
          sUncaughtExceptionHandler.onUncaughtException(t);
          return undefined;
        }
         else 
          throw $e0;
      }
    }
     else {
      return apply_11(jsFunction, thisObj, arguments_0);
    }
  }
   finally {
    exit(initialEntry);
  }
}

function exit(initialEntry){
  initialEntry && $flushFinallyCommands(($clinit_SchedulerImpl() , INSTANCE));
  --entryDepth;
  if (initialEntry) {
    if (watchdogEntryDepthTimerId != -1) {
      watchdogEntryDepthCancel(watchdogEntryDepthTimerId);
      watchdogEntryDepthTimerId = -1;
    }
  }
}

function getHashCode(o){
  return o.$H || (o.$H = ++sNextHashId);
}

function watchdogEntryDepthCancel(timerId){
  $wnd.clearTimeout(timerId);
}

function watchdogEntryDepthSchedule(){
  return $wnd.setTimeout(function(){
    entryDepth != 0 && (entryDepth = 0);
    watchdogEntryDepthTimerId = -1;
  }
  , 10);
}

var entryDepth = 0, sNextHashId = 0, watchdogEntryDepthLastScheduled = 0, watchdogEntryDepthTimerId = -1;
function $clinit_SchedulerImpl(){
  $clinit_SchedulerImpl = nullMethod;
  INSTANCE = new SchedulerImpl_0;
}

function $flushEntryCommands(this$static){
  var oldQueue, rescheduled;
  if (this$static.entryCommands) {
    rescheduled = null;
    do {
      oldQueue = this$static.entryCommands;
      this$static.entryCommands = null;
      rescheduled = runScheduledTasks(oldQueue, rescheduled);
    }
     while (this$static.entryCommands);
    this$static.entryCommands = rescheduled;
  }
}

function $flushFinallyCommands(this$static){
  var oldQueue, rescheduled;
  if (this$static.finallyCommands) {
    rescheduled = null;
    do {
      oldQueue = this$static.finallyCommands;
      this$static.finallyCommands = null;
      rescheduled = runScheduledTasks(oldQueue, rescheduled);
    }
     while (this$static.finallyCommands);
    this$static.finallyCommands = rescheduled;
  }
}

function $flushPostEventPumpCommands(this$static){
  var oldDeferred;
  if (this$static.deferredCommands) {
    oldDeferred = this$static.deferredCommands;
    this$static.deferredCommands = null;
    !this$static.incrementalCommands && (this$static.incrementalCommands = []);
    runScheduledTasks(oldDeferred, this$static.incrementalCommands);
  }
  !!this$static.incrementalCommands && (this$static.incrementalCommands = runRepeatingTasks(this$static.incrementalCommands));
}

function $isWorkQueued(this$static){
  return !!this$static.deferredCommands || !!this$static.incrementalCommands;
}

function $maybeSchedulePostEventPumpCommands(this$static){
  if (!this$static.shouldBeRunning) {
    this$static.shouldBeRunning = true;
    !this$static.flusher && (this$static.flusher = new SchedulerImpl$Flusher_0(this$static));
    scheduleFixedDelayImpl(this$static.flusher, 1);
    !this$static.rescue && (this$static.rescue = new SchedulerImpl$Rescuer_0(this$static));
    scheduleFixedDelayImpl(this$static.rescue, 50);
  }
}

function $scheduleDeferred(this$static, cmd){
  this$static.deferredCommands = push(this$static.deferredCommands, [cmd, false]);
  $maybeSchedulePostEventPumpCommands(this$static);
}

function $scheduleFinally(this$static, cmd){
  this$static.finallyCommands = push(this$static.finallyCommands, [cmd, false]);
}

function SchedulerImpl_0(){
}

function execute_2(cmd){
  return cmd.execute_0();
}

function push(queue, task){
  !queue && (queue = []);
  $push(queue, task);
  return queue;
}

function runRepeatingTasks(tasks){
  var canceledSomeTasks, i, length_0, newTasks, start, t;
  length_0 = tasks.length;
  if (length_0 == 0) {
    return null;
  }
  canceledSomeTasks = false;
  start = currentTimeMillis();
  while (currentTimeMillis() - start < 100) {
    for (i = 0; i < length_0; ++i) {
      t = tasks[i];
      if (!t) {
        continue;
      }
      if (!t[0].execute_0()) {
        tasks[i] = null;
        canceledSomeTasks = true;
      }
    }
  }
  if (canceledSomeTasks) {
    newTasks = [];
    for (i = 0; i < length_0; ++i) {
      !!tasks[i] && (newTasks[newTasks.length] = tasks[i] , undefined);
    }
    return newTasks.length == 0?null:newTasks;
  }
   else {
    return tasks;
  }
}

function runScheduledTasks(tasks, rescheduled){
  var $e0, e, i, j, t;
  for (i = 0 , j = tasks.length; i < j; ++i) {
    t = tasks[i];
    try {
      t[1]?t[0].execute_0() && (rescheduled = push(rescheduled, t)):t[0].execute();
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$Throwable)) {
        e = $e0;
        !!sUncaughtExceptionHandler && sUncaughtExceptionHandler.onUncaughtException(e);
      }
       else 
        throw $e0;
    }
  }
  return rescheduled;
}

function scheduleFixedDelayImpl(cmd, delayMs){
  $clinit_SchedulerImpl();
  $wnd.setTimeout(function(){
    var ret = $entry(execute_2)(cmd);
    ret && $wnd.setTimeout(arguments.callee, delayMs);
  }
  , delayMs);
}

defineSeed(154, 152, {}, SchedulerImpl_0);
_.deferredCommands = null;
_.entryCommands = null;
_.finallyCommands = null;
_.flushRunning = false;
_.flusher = null;
_.incrementalCommands = null;
_.rescue = null;
_.shouldBeRunning = false;
var INSTANCE;
function SchedulerImpl$Flusher_0(this$0){
  this.this$0 = this$0;
}

defineSeed(155, 1, {}, SchedulerImpl$Flusher_0);
_.execute_0 = function execute_3(){
  this.this$0.flushRunning = true;
  $flushPostEventPumpCommands(this.this$0);
  this.this$0.flushRunning = false;
  return this.this$0.shouldBeRunning = $isWorkQueued(this.this$0);
}
;
_.this$0 = null;
function SchedulerImpl$Rescuer_0(this$0){
  this.this$0 = this$0;
}

defineSeed(156, 1, {}, SchedulerImpl$Rescuer_0);
_.execute_0 = function execute_4(){
  this.this$0.flushRunning && scheduleFixedDelayImpl(this.this$0.flusher, 1);
  return this.this$0.shouldBeRunning;
}
;
_.this$0 = null;
function extractNameFromToString(fnToString){
  var index, start, toReturn;
  toReturn = '';
  fnToString = $trim(fnToString);
  index = fnToString.indexOf('(');
  start = fnToString.indexOf('function') == 0?8:0;
  if (index == -1) {
    index = $indexOf_1(fnToString, fromCodePoint(64));
    start = fnToString.indexOf('function ') == 0?9:0;
  }
  index != -1 && (toReturn = $trim(fnToString.substr(start, index - start)));
  return toReturn.length > 0?toReturn:'anonymous';
}

function parseInt_0(number){
  return parseInt(number) || -1;
}

function splice_1(arr, length_0){
  arr.length >= length_0 && arr.splice(0, length_0);
  return arr;
}

function $getProperties(e){
  var result = '';
  try {
    for (var prop in e) {
      if (prop != 'name' && prop != 'message' && prop != 'toString') {
        try {
          result += '\n ' + prop + ': ' + e[prop];
        }
         catch (ignored) {
        }
      }
    }
  }
   catch (ignored) {
  }
  return result;
}

function $makeException(){
  try {
    null.a();
  }
   catch (e) {
    return e;
  }
}

function StackTraceCreator$Collector_0(){
}

defineSeed(159, 1, {}, StackTraceCreator$Collector_0);
_.collect = function collect(){
  var seen = {};
  var toReturn = [];
  var callee = arguments.callee.caller.caller;
  while (callee) {
    var name_0 = this.extractName(callee.toString());
    toReturn.push(name_0);
    var keyName = ':' + name_0;
    var withThisName = seen[keyName];
    if (withThisName) {
      var i, j;
      for (i = 0 , j = withThisName.length; i < j; i++) {
        if (withThisName[i] === callee) {
          return toReturn;
        }
      }
    }
    (withThisName || (seen[keyName] = [])).push(callee);
    callee = callee.caller;
  }
  return toReturn;
}
;
_.extractName = function extractName(fnToString){
  return extractNameFromToString(fnToString);
}
;
_.inferFrom = function inferFrom(e){
  return [];
}
;
function $inferFrom(this$static, e){
  var i, j, stack;
  stack = e && e.stack?e.stack.split('\n'):[];
  for (i = 0 , j = stack.length; i < j; ++i) {
    stack[i] = this$static.extractName(stack[i]);
  }
  return stack;
}

defineSeed(161, 159, {});
_.collect = function collect_0(){
  return splice_1(this.inferFrom($makeException()), this.toSplice());
}
;
_.inferFrom = function inferFrom_0(e){
  return $inferFrom(this, e);
}
;
_.toSplice = function toSplice(){
  return 2;
}
;
function $clinit_StackTraceCreator$CollectorChrome(){
  $clinit_StackTraceCreator$CollectorChrome = nullMethod;
  Error.stackTraceLimit = 128;
}

function $collect(this$static){
  var res;
  res = splice_1($inferFrom_0(this$static, $makeException()), 3);
  res.length == 0 && (res = splice_1((new StackTraceCreator$Collector_0).collect(), 1));
  return res;
}

--></script>
<script><!--
function $createStackTrace(this$static, e){
  var stack;
  stack = $inferFrom_0(this$static, instanceOfJso(e.e)?e.e:null);
  $parseStackTrace(e, stack);
}

function $fillInStackTrace(t){
  var stack;
  stack = $collect(new StackTraceCreator$CollectorChromeNoSourceMap_0);
  $parseStackTrace(t, stack);
}

function $inferFrom_0(this$static, e){
  var stack;
  stack = $inferFrom(this$static, e);
  return stack.length == 0?(new StackTraceCreator$Collector_0).inferFrom(e):splice_1(stack, 1);
}

function $parseStackTrace(e, stack){
  var col, endFileUrl, fileName, i, j, lastColon, location_0, stackElements, stackTrace;
  stackTrace = initDim(_3Ljava_lang_StackTraceElement_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$StackTraceElement, stack.length, 0);
  for (i = 0 , j = stackTrace.length; i < j; ++i) {
    stackElements = $split(stack[i], '@@', 0);
    col = -1;
    fileName = 'Unknown';
    if (stackElements.length == 2 && stackElements[1] != null) {
      location_0 = stackElements[1];
      lastColon = $lastIndexOf(location_0, fromCodePoint(58));
      endFileUrl = $lastIndexOf_0(location_0, fromCodePoint(58), lastColon - 1);
      fileName = location_0.substr(0, endFileUrl - 0);
      if (lastColon != -1 && endFileUrl != -1) {
        parseInt_0(location_0.substr(endFileUrl + 1, lastColon - (endFileUrl + 1)));
        col = parseInt_0($substring(location_0, lastColon + 1));
      }
    }
    stackTrace[i] = new StackTraceElement_0('Unknown', stackElements[0], fileName + '@' + col, -1);
  }
  $setStackTrace(e, stackTrace);
}

defineSeed(160, 161, {});
_.collect = function collect_1(){
  return $collect(this);
}
;
_.extractName = function extractName_0(fnToString){
  var closeParen, index, location_0, toReturn;
  if (fnToString.length == 0) {
    return 'anonymous';
  }
  toReturn = $trim(fnToString);
  toReturn.indexOf('at ') == 0 && (toReturn = $substring(toReturn, 3));
  index = toReturn.indexOf('[');
  index != -1 && (toReturn = $trim(toReturn.substr(0, index - 0)) + $trim($substring(toReturn, toReturn.indexOf(']', index) + 1)));
  index = toReturn.indexOf('(');
  if (index == -1) {
    location_0 = toReturn;
    toReturn = '';
  }
   else {
    closeParen = toReturn.indexOf(')', index);
    location_0 = toReturn.substr(index + 1, closeParen - (index + 1));
    toReturn = $trim(toReturn.substr(0, index - 0));
  }
  index = $indexOf_1(toReturn, fromCodePoint(46));
  index != -1 && (toReturn = $substring(toReturn, index + 1));
  return (toReturn.length > 0?toReturn:'anonymous') + '@@' + location_0;
}
;
_.inferFrom = function inferFrom_1(e){
  return $inferFrom_0(this, e);
}
;
_.toSplice = function toSplice_0(){
  return 3;
}
;
function StackTraceCreator$CollectorChromeNoSourceMap_0(){
  $clinit_StackTraceCreator$CollectorChrome();
}

defineSeed(162, 160, {}, StackTraceCreator$CollectorChromeNoSourceMap_0);
defineSeed(163, 1, {});
function $append(this$static, x){
  this$static.string += x;
}

function $append_0(this$static, x){
  this$static.string += x;
}

function $append_1(this$static, x){
  this$static.string += x;
}

function $append_2(this$static, x){
  this$static.string += x;
}

function $append_3(this$static, x){
  this$static.string += x;
}

function $appendNonNull(this$static, x){
  this$static.string += x;
}

function $replace(this$static, start, end, toInsert){
  this$static.string = $substring_0(this$static.string, 0, start) + toInsert + $substring(this$static.string, end);
}

function StringBufferImplAppend_0(){
}

defineSeed(164, 163, {}, StringBufferImplAppend_0);
_.string = '';
function $appendChild(this$static, newChild){
  return this$static.appendChild(newChild);
}

function $insertBefore(this$static, newChild, refChild){
  return this$static.insertBefore(newChild, refChild);
}

function $removeChild(this$static, oldChild){
  return this$static.removeChild(oldChild);
}

function $setBooleanAttr(this$static, value){
  value?(this$static.setAttribute('loop', '') , undefined):(this$static.removeAttribute('loop') , undefined);
}

function $setSrc(this$static, url){
  this$static.src = url;
}

function $setVolume_1(this$static, volume){
  this$static.volume = volume;
}

function $setHeight(this$static, height){
  this$static.height = height;
}

function $setWidth(this$static, width){
  this$static.width = width;
}

function $eventGetButton(evt){
  var button = evt.button;
  if (button == 1) {
    return 4;
  }
   else if (button == 2) {
    return 2;
  }
  return 1;
}

function $isOrHasChild(parent_0, child){
  return parent_0.contains(child);
}

function $setInnerText(elem, text){
  elem.textContent = text || '';
}

function $getAbsoluteLeft(elem){
  var rect;
  rect = getBoundingClientRect(elem);
  return rect?rect.left + $getScrollLeft(elem.ownerDocument.body):getAbsoluteLeftUsingOffsets(elem);
}

function $getAbsoluteTop(elem){
  var rect;
  rect = getBoundingClientRect(elem);
  return rect?rect.top + (elem.ownerDocument.body.scrollTop || 0):getAbsoluteTopUsingOffsets(elem);
}

function $getScrollLeft(elem){
  if (elem.ownerDocument.defaultView.getComputedStyle(elem, '').direction == 'rtl') {
    return (elem.scrollLeft || 0) - ((elem.scrollWidth || 0) - elem.clientWidth);
  }
  return elem.scrollLeft || 0;
}

function $getTabIndex(elem){
  return typeof elem.tabIndex != 'undefined'?elem.tabIndex:-1;
}

function getAbsoluteLeftUsingOffsets(elem){
  if (elem.offsetLeft == null) {
    return 0;
  }
  var left = 0;
  var doc = elem.ownerDocument;
  var curr = elem.parentNode;
  if (curr) {
    while (curr.offsetParent) {
      left -= curr.scrollLeft;
      doc.defaultView.getComputedStyle(curr, '').getPropertyValue('direction') == 'rtl' && (left += curr.scrollWidth - curr.clientWidth);
      curr = curr.parentNode;
    }
  }
  while (elem) {
    left += elem.offsetLeft;
    if (doc.defaultView.getComputedStyle(elem, '')['position'] == 'fixed') {
      left += doc.body.scrollLeft;
      return left;
    }
    var parent_0 = elem.offsetParent;
    parent_0 && $wnd.devicePixelRatio && (left += parseInt(doc.defaultView.getComputedStyle(parent_0, '').getPropertyValue('border-left-width')));
    if (parent_0 && parent_0.tagName == 'BODY' && elem.style.position == 'absolute') {
      break;
    }
    elem = parent_0;
  }
  return left;
}

function getAbsoluteTopUsingOffsets(elem){
  if (elem.offsetTop == null) {
    return 0;
  }
  var top_0 = 0;
  var doc = elem.ownerDocument;
  var curr = elem.parentNode;
  if (curr) {
    while (curr.offsetParent) {
      top_0 -= curr.scrollTop;
      curr = curr.parentNode;
    }
  }
  while (elem) {
    top_0 += elem.offsetTop;
    if (doc.defaultView.getComputedStyle(elem, '')['position'] == 'fixed') {
      top_0 += doc.body.scrollTop;
      return top_0;
    }
    var parent_0 = elem.offsetParent;
    parent_0 && $wnd.devicePixelRatio && (top_0 += parseInt(doc.defaultView.getComputedStyle(parent_0, '').getPropertyValue('border-top-width')));
    if (parent_0 && parent_0.tagName == 'BODY' && elem.style.position == 'absolute') {
      break;
    }
    elem = parent_0;
  }
  return top_0;
}

function getBoundingClientRect(element){
  return element.getBoundingClientRect && element.getBoundingClientRect();
}

function $clinit_Style$FontStyle(){
  $clinit_Style$FontStyle = nullMethod;
  NORMAL = new Style$FontStyle$1_0;
  ITALIC = new Style$FontStyle$2_0;
  OBLIQUE = new Style$FontStyle$3_0;
  $VALUES_8 = initValues(_3Lcom_google_gwt_dom_client_Style$FontStyle_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$FontStyle, [NORMAL, ITALIC, OBLIQUE]);
}

function values_9(){
  $clinit_Style$FontStyle();
  return $VALUES_8;
}

defineSeed(183, 39, makeCastMap([Q$Style$FontStyle, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_8, ITALIC, NORMAL, OBLIQUE;
function Style$FontStyle$1_0(){
  Enum_0.call(this, 'NORMAL', 0);
}

defineSeed(184, 183, makeCastMap([Q$Style$FontStyle, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontStyle$1_0);
function Style$FontStyle$2_0(){
  Enum_0.call(this, 'ITALIC', 1);
}

defineSeed(185, 183, makeCastMap([Q$Style$FontStyle, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontStyle$2_0);
function Style$FontStyle$3_0(){
  Enum_0.call(this, 'OBLIQUE', 2);
}

defineSeed(186, 183, makeCastMap([Q$Style$FontStyle, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontStyle$3_0);
function $clinit_Style$FontWeight(){
  $clinit_Style$FontWeight = nullMethod;
  NORMAL_0 = new Style$FontWeight$1_0;
  BOLD = new Style$FontWeight$2_0;
  BOLDER = new Style$FontWeight$3_0;
  LIGHTER = new Style$FontWeight$4_0;
  $VALUES_9 = initValues(_3Lcom_google_gwt_dom_client_Style$FontWeight_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$FontWeight, [NORMAL_0, BOLD, BOLDER, LIGHTER]);
}

function values_10(){
  $clinit_Style$FontWeight();
  return $VALUES_9;
}

defineSeed(187, 39, makeCastMap([Q$Style$FontWeight, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_9, BOLD, BOLDER, LIGHTER, NORMAL_0;
function Style$FontWeight$1_0(){
  Enum_0.call(this, 'NORMAL', 0);
}

defineSeed(188, 187, makeCastMap([Q$Style$FontWeight, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontWeight$1_0);
function Style$FontWeight$2_0(){
  Enum_0.call(this, 'BOLD', 1);
}

defineSeed(189, 187, makeCastMap([Q$Style$FontWeight, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontWeight$2_0);
function Style$FontWeight$3_0(){
  Enum_0.call(this, 'BOLDER', 2);
}

defineSeed(190, 187, makeCastMap([Q$Style$FontWeight, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontWeight$3_0);
function Style$FontWeight$4_0(){
  Enum_0.call(this, 'LIGHTER', 3);
}

defineSeed(191, 187, makeCastMap([Q$Style$FontWeight, Q$Style$HasCssName, Q$Serializable, Q$Comparable, Q$Enum]), Style$FontWeight$4_0);
function $clinit_Style$Overflow(){
  $clinit_Style$Overflow = nullMethod;
  VISIBLE = new Style$Overflow$1_0;
  HIDDEN = new Style$Overflow$2_0;
  SCROLL = new Style$Overflow$3_0;
  AUTO = new Style$Overflow$4_0;
  $VALUES_10 = initValues(_3Lcom_google_gwt_dom_client_Style$Overflow_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$Overflow, [VISIBLE, HIDDEN, SCROLL, AUTO]);
}

function values_11(){
  $clinit_Style$Overflow();
  return $VALUES_10;
}

defineSeed(192, 39, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_10, AUTO, HIDDEN, SCROLL, VISIBLE;
function Style$Overflow$1_0(){
  Enum_0.call(this, 'VISIBLE', 0);
}

defineSeed(193, 192, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]), Style$Overflow$1_0);
function Style$Overflow$2_0(){
  Enum_0.call(this, 'HIDDEN', 1);
}

defineSeed(194, 192, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]), Style$Overflow$2_0);
function Style$Overflow$3_0(){
  Enum_0.call(this, 'SCROLL', 2);
}

defineSeed(195, 192, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]), Style$Overflow$3_0);
function Style$Overflow$4_0(){
  Enum_0.call(this, 'AUTO', 3);
}

defineSeed(196, 192, makeCastMap([Q$Style$HasCssName, Q$Style$Overflow, Q$Serializable, Q$Comparable, Q$Enum]), Style$Overflow$4_0);
function $clinit_Style$Position(){
  $clinit_Style$Position = nullMethod;
  STATIC = new Style$Position$1_0;
  RELATIVE = new Style$Position$2_0;
  ABSOLUTE = new Style$Position$3_0;
  FIXED = new Style$Position$4_0;
  $VALUES_11 = initValues(_3Lcom_google_gwt_dom_client_Style$Position_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$Position, [STATIC, RELATIVE, ABSOLUTE, FIXED]);
}

function values_12(){
  $clinit_Style$Position();
  return $VALUES_11;
}

defineSeed(197, 39, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_11, ABSOLUTE, FIXED, RELATIVE, STATIC;
function Style$Position$1_0(){
  Enum_0.call(this, 'STATIC', 0);
}

defineSeed(198, 197, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]), Style$Position$1_0);
function Style$Position$2_0(){
  Enum_0.call(this, 'RELATIVE', 1);
}

defineSeed(199, 197, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]), Style$Position$2_0);
function Style$Position$3_0(){
  Enum_0.call(this, 'ABSOLUTE', 2);
}

defineSeed(200, 197, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]), Style$Position$3_0);
function Style$Position$4_0(){
  Enum_0.call(this, 'FIXED', 3);
}

defineSeed(201, 197, makeCastMap([Q$Style$HasCssName, Q$Style$Position, Q$Serializable, Q$Comparable, Q$Enum]), Style$Position$4_0);
function $clinit_Style$Unit(){
  $clinit_Style$Unit = nullMethod;
  PX = new Style$Unit$1_0;
  PCT = new Style$Unit$2_0;
  EM = new Style$Unit$3_0;
  EX = new Style$Unit$4_0;
  PT = new Style$Unit$5_0;
  PC = new Style$Unit$6_0;
  IN = new Style$Unit$7_0;
  CM = new Style$Unit$8_0;
  MM = new Style$Unit$9_0;
  $VALUES_12 = initValues(_3Lcom_google_gwt_dom_client_Style$Unit_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$Unit, [PX, PCT, EM, EX, PT, PC, IN, CM, MM]);
}

function values_13(){
  $clinit_Style$Unit();
  return $VALUES_12;
}

defineSeed(202, 39, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_12, CM, EM, EX, IN, MM, PC, PCT, PT, PX;
function Style$Unit$1_0(){
  Enum_0.call(this, 'PX', 0);
}

defineSeed(203, 202, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$1_0);
function Style$Unit$2_0(){
  Enum_0.call(this, 'PCT', 1);
}

defineSeed(204, 202, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$2_0);
function Style$Unit$3_0(){
  Enum_0.call(this, 'EM', 2);
}

defineSeed(205, 202, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$3_0);
function Style$Unit$4_0(){
  Enum_0.call(this, 'EX', 3);
}

defineSeed(206, 202, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$4_0);
function Style$Unit$5_0(){
  Enum_0.call(this, 'PT', 4);
}

defineSeed(207, 202, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$5_0);
function Style$Unit$6_0(){
  Enum_0.call(this, 'PC', 5);
}

defineSeed(208, 202, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$6_0);
function Style$Unit$7_0(){
  Enum_0.call(this, 'IN', 6);
}

defineSeed(209, 202, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$7_0);
function Style$Unit$8_0(){
  Enum_0.call(this, 'CM', 7);
}

defineSeed(210, 202, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$8_0);
function Style$Unit$9_0(){
  Enum_0.call(this, 'MM', 8);
}

defineSeed(211, 202, makeCastMap([Q$Style$Unit, Q$Serializable, Q$Comparable, Q$Enum]), Style$Unit$9_0);
function $clinit_Style$Visibility(){
  $clinit_Style$Visibility = nullMethod;
  VISIBLE_0 = new Style$Visibility$1_0;
  HIDDEN_0 = new Style$Visibility$2_0;
  $VALUES_13 = initValues(_3Lcom_google_gwt_dom_client_Style$Visibility_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Style$Visibility, [VISIBLE_0, HIDDEN_0]);
}

function values_14(){
  $clinit_Style$Visibility();
  return $VALUES_13;
}

defineSeed(212, 39, makeCastMap([Q$Style$HasCssName, Q$Style$Visibility, Q$Serializable, Q$Comparable, Q$Enum]));
var $VALUES_13, HIDDEN_0, VISIBLE_0;
function Style$Visibility$1_0(){
  Enum_0.call(this, 'VISIBLE', 0);
}

defineSeed(213, 212, makeCastMap([Q$Style$HasCssName, Q$Style$Visibility, Q$Serializable, Q$Comparable, Q$Enum]), Style$Visibility$1_0);
function Style$Visibility$2_0(){
  Enum_0.call(this, 'HIDDEN', 1);
}

defineSeed(214, 212, makeCastMap([Q$Style$HasCssName, Q$Style$Visibility, Q$Serializable, Q$Comparable, Q$Enum]), Style$Visibility$2_0);
function $clinit_StyleInjector(){
  $clinit_StyleInjector = nullMethod;
  toInject = [];
  toInjectAtEnd = [];
  toInjectAtStart = [];
  flusher = new StyleInjector$1_0;
}

function flush(){
  $clinit_StyleInjector();
  var css, maybeReturn, toReturn;
  toReturn = null;
  if (toInjectAtStart.length != 0) {
    css = toInjectAtStart.join('');
    maybeReturn = $injectStyleSheetAtStart(($clinit_StyleInjector$StyleInjectorImpl() , IMPL), css);
    !toInjectAtStart && (toReturn = maybeReturn);
    toInjectAtStart.length = 0;
  }
  if (toInject.length != 0) {
    css = toInject.join('');
    maybeReturn = $injectStyleSheet(($clinit_StyleInjector$StyleInjectorImpl() , IMPL), css);
    !toInject && (toReturn = maybeReturn);
    toInject.length = 0;
  }
  if (toInjectAtEnd.length != 0) {
    css = toInjectAtEnd.join('');
    maybeReturn = $injectStyleSheet(($clinit_StyleInjector$StyleInjectorImpl() , IMPL), css);
    !toInjectAtEnd && (toReturn = maybeReturn);
    toInjectAtEnd.length = 0;
  }
  needsInjection = false;
  return toReturn;
}

function injectAtStart(css){
  $clinit_StyleInjector();
  $unshift(toInjectAtStart, css);
  schedule();
}

function schedule(){
  if (!needsInjection) {
    needsInjection = true;
    $scheduleFinally(($clinit_SchedulerImpl() , INSTANCE), flusher);
  }
}

var flusher, needsInjection = false, toInject, toInjectAtEnd, toInjectAtStart;
function StyleInjector$1_0(){
}

defineSeed(217, 1, {}, StyleInjector$1_0);
_.execute = function execute_5(){
  ($clinit_StyleInjector() , needsInjection) && flush();
}
;
function $clinit_StyleInjector$StyleInjectorImpl(){
  $clinit_StyleInjector$StyleInjectorImpl = nullMethod;
  IMPL = new StyleInjector$StyleInjectorImpl_0;
}

function $createElement_0(contents){
  var style;
  style = $doc.createElement('style');
  style['language'] = 'text/css';
  $setInnerText(style, contents);
  return style;
}

function $getHead(this$static){
  var elt;
  if (!this$static.head) {
    elt = $doc.getElementsByTagName('head')[0];
    this$static.head = elt;
  }
  return this$static.head;
}

function $injectStyleSheet(this$static, contents){
  var style;
  style = $createElement_0(contents);
  $appendChild($getHead(this$static), style);
  return style;
}

function $injectStyleSheetAtStart(this$static, contents){
  var style;
  style = $createElement_0(contents);
  $insertBefore($getHead(this$static), style, this$static.head.firstChild);
  return style;
}

function StyleInjector$StyleInjectorImpl_0(){
}

defineSeed(218, 1, {}, StyleInjector$StyleInjectorImpl_0);
_.head = null;
var IMPL;
function $getRelativeX(this$static, target){
  return this$static.clientX - $getAbsoluteLeft(target) + $getScrollLeft(target) + $getScrollLeft(target.ownerDocument.body);
}

function $getRelativeY(this$static, target){
  return this$static.clientY - $getAbsoluteTop(target) + (target.scrollTop || 0) + (target.ownerDocument.body.scrollTop || 0);
}

defineSeed(222, 1, {});
_.toString$ = function toString_10(){
  return 'An event type';
}
;
_.source = null;
function $overrideSource(this$static, source){
  this$static.source = source;
}

defineSeed(221, 222, {});
_.dead = false;
function $setNativeEvent(this$static, nativeEvent){
  this$static.nativeEvent = nativeEvent;
}

function $setRelativeElement(this$static, relativeElem){
  this$static.relativeElem = relativeElem;
}

function fireNativeEvent(nativeEvent, handlerSource, relativeElem){
  var currentNative, currentRelativeElem, typeKey;
  if (registered) {
    typeKey = $unsafeGet(registered, nativeEvent.type);
    if (typeKey) {
      currentNative = typeKey.flyweight.nativeEvent;
      currentRelativeElem = typeKey.flyweight.relativeElem;
      $setNativeEvent(typeKey.flyweight, nativeEvent);
      $setRelativeElement(typeKey.flyweight, relativeElem);
      $fireEvent_0(handlerSource, typeKey.flyweight);
      $setNativeEvent(typeKey.flyweight, currentNative);
      $setRelativeElement(typeKey.flyweight, currentRelativeElem);
    }
  }
}

defineSeed(220, 221, {});
_.getAssociatedType = function getAssociatedType(){
  return $clinit_EndedEvent() , TYPE;
}
;
_.nativeEvent = null;
_.relativeElem = null;
var registered = null;
defineSeed(225, 1, {});
_.hashCode$ = function hashCode_3(){
  return this.index_0;
}
;
_.toString$ = function toString_11(){
  return 'Event type';
}
;
_.index_0 = 0;
var nextHashCode = 0;
function GwtEvent$Type_0(){
  this.index_0 = ++nextHashCode;
}

defineSeed(224, 225, {}, GwtEvent$Type_0);
function DomEvent$Type_0(flyweight){
  GwtEvent$Type_0.call(this);
  this.flyweight = flyweight;
  !registered && (registered = new PrivateMap_0);
  registered.map['ended'] = this;
  this.name_0 = 'ended';
}

defineSeed(223, 224, {}, DomEvent$Type_0);
_.flyweight = null;
_.name_0 = null;
function $clinit_EndedEvent(){
  $clinit_EndedEvent = nullMethod;
  TYPE = new DomEvent$Type_0(new EndedEvent_0);
}

function EndedEvent_0(){
}

defineSeed(226, 220, {}, EndedEvent_0);
_.dispatch = function dispatch(handler){
  $fireOnPlaybackComplete(handler.this$0.soundHandlerCollection, handler.this$0);
}
;
var TYPE;
function $unsafeGet(this$static, key){
  return this$static.map[key];
}

function PrivateMap_0(){
  this.map = {};
}

defineSeed(227, 1, {}, PrivateMap_0);
_.map = null;
function CloseEvent_0(){
}

function fire(source){
  var event_0;
  if (TYPE_0) {
    event_0 = new CloseEvent_0;
    $fireEvent(source, event_0);
  }
}

defineSeed(229, 221, {}, CloseEvent_0);
_.dispatch = function dispatch_0(handler){
  detachWidgets();
}
;
_.getAssociatedType = function getAssociatedType_0(){
  return TYPE_0;
}
;
var TYPE_0 = null;
function $addHandler(this$static, type, handler){
  return new LegacyHandlerWrapper_0($doAdd_1(this$static.eventBus, type, handler));
}

function $fireEvent(this$static, event_0){
  var $e0, e, oldSource;
  !event_0.dead || (event_0.dead = false , event_0.source = null);
  oldSource = event_0.source;
  $overrideSource(event_0, this$static.source);
  try {
    $doFire(this$static.eventBus, event_0);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$UmbrellaException)) {
      e = $e0;
      throw new UmbrellaException_2(e.causes);
    }
     else 
      throw $e0;
  }
   finally {
    oldSource == null?(event_0.dead = true , event_0.source = null):(event_0.source = oldSource);
  }
}

function HandlerManager_0(source){
  this.eventBus = new HandlerManager$Bus_0;
  this.source = source;
}

defineSeed(230, 1, makeCastMap([Q$HasHandlers]), HandlerManager_0);
_.eventBus = null;
_.source = null;
defineSeed(233, 1, {});
function $defer(this$static, command){
  !this$static.deferredDeltas && (this$static.deferredDeltas = new ArrayList_0);
  $add_4(this$static.deferredDeltas, command);
}

function $doAdd_1(this$static, type, handler){
  if (!type) {
    throw new NullPointerException_1('Cannot add a handler with a null type');
  }
  if (!handler) {
    throw new NullPointerException_1('Cannot add a null handler');
  }
  this$static.firingDepth > 0?$defer(this$static, new SimpleEventBus$2_0(this$static, type, handler)):$doAddNow(this$static, type, null, handler);
  return new SimpleEventBus$1_0(this$static, type, handler);
}

function $doAddNow(this$static, type, source, handler){
  var l_0;
  l_0 = $ensureHandlerList(this$static, type, source);
  l_0.add(handler);
}

function $doFire(this$static, event_0){
  var $e0, causes, e, handler, handlers, it;
  if (!event_0) {
    throw new NullPointerException_1('Cannot fire null event');
  }
  try {
    ++this$static.firingDepth;
    handlers = $getDispatchList(this$static, event_0.getAssociatedType());
    causes = null;
    it = this$static.isReverseOrder?handlers.listIterator_0(handlers.size_0()):handlers.listIterator();
    while (this$static.isReverseOrder?it.hasPrevious():it.hasNext()) {
      handler = this$static.isReverseOrder?it.previous():it.next_0();
      try {
        event_0.dispatch(handler);
      }
       catch ($e0) {
        $e0 = caught_0($e0);
        if (instanceOf($e0, Q$Throwable)) {
          e = $e0;
          !causes && (causes = new HashSet_0);
          $add_8(causes, e);
        }
         else 
          throw $e0;
      }
    }
    if (causes) {
      throw new UmbrellaException_1(causes);
    }
  }
   finally {
    --this$static.firingDepth;
    this$static.firingDepth == 0 && $handleQueuedAddsAndRemoves(this$static);
  }
}

function $doRemoveNow(this$static, type, source, handler){
  var l_0, removed, sourceMap;
  l_0 = $getHandlerList(this$static, type, source);
  removed = l_0.remove(handler);
  removed && l_0.isEmpty() && (sourceMap = $get_4(this$static.map, type) , sourceMap.remove_1(source) , sourceMap.isEmpty() && $remove_9(this$static.map, type) , undefined);
}

function $ensureHandlerList(this$static, type, source){
  var handlers, sourceMap;
  sourceMap = $get_4(this$static.map, type);
  if (!sourceMap) {
    sourceMap = new HashMap_0;
    $put_2(this$static.map, type, sourceMap);
  }
  handlers = sourceMap.get_0(source);
  if (!handlers) {
    handlers = new ArrayList_0;
    sourceMap.put(source, handlers);
  }
  return handlers;
}

function $getDispatchList(this$static, type){
  var directHandlers;
  directHandlers = $getHandlerList(this$static, type, null);
  return directHandlers;
}

function $getHandlerList(this$static, type, source){
  var handlers, sourceMap;
  sourceMap = $get_4(this$static.map, type);
  if (!sourceMap) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
  handlers = sourceMap.get_0(source);
  if (!handlers) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
  return handlers;
}

function $handleQueuedAddsAndRemoves(this$static){
  var c, c$iterator;
  if (this$static.deferredDeltas) {
    try {
      for (c$iterator = new AbstractList$IteratorImpl_0(this$static.deferredDeltas); c$iterator.i < c$iterator.this$0_0.size_0();) {
        c = $next_2(c$iterator);
        c.execute();
      }
    }
     finally {
      this$static.deferredDeltas = null;
    }
  }
}

defineSeed(232, 233, {});
_.deferredDeltas = null;
_.firingDepth = 0;
_.isReverseOrder = false;
function $doRemove_1(this$static, type, source, handler){
  this$static.firingDepth > 0?$defer(this$static, new SimpleEventBus$3_0(this$static, type, source, handler)):$doRemoveNow(this$static, type, source, handler);
}

function HandlerManager$Bus_0(){
  this.map = new HashMap_0;
  this.isReverseOrder = false;
}

defineSeed(231, 232, {}, HandlerManager$Bus_0);
function LegacyHandlerWrapper_0(real){
  this.real = real;
}

defineSeed(234, 1, {}, LegacyHandlerWrapper_0);
_.real = null;
function UmbrellaException_1(causes){
  RuntimeException_1.call(this, makeMessage(causes), makeCause(causes));
  this.causes = causes;
}

function makeCause(causes){
  var iterator;
  iterator = causes.iterator();
  if (!iterator.hasNext()) {
    return null;
  }
  return iterator.next_0();
}

function makeMessage(causes){
  var b, count, first, t, t$iterator;
  count = causes.size_0();
  if (count == 0) {
    return null;
  }
  b = new StringBuilder_1(count == 1?'Exception caught: ':count + ' exceptions caught: ');
  first = true;
  for (t$iterator = causes.iterator(); t$iterator.hasNext();) {
    t = t$iterator.next_0();
    first?(first = false):(b.impl.string += '; ' , b);
    $append_12(b, t.getMessage());
  }
  return b.impl.string;
}

defineSeed(236, 144, makeCastMap([Q$UmbrellaException, Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), UmbrellaException_1);
_.causes = null;
function UmbrellaException_2(causes){
  UmbrellaException_1.call(this, causes);
}

defineSeed(235, 236, makeCastMap([Q$UmbrellaException, Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), UmbrellaException_2);
function throwIfNull(value){
  if (null == value) {
    throw new NullPointerException_1('encodedURLComponent cannot be null');
  }
}

function setDirectionOnElement(elem){
  switch (0) {
    case 0:
      {
        elem['dir'] = 'rtl';
        break;
      }

  }
}

function $clinit_DateTimeFormat(){
  $clinit_DateTimeFormat = nullMethod;
  new HashMap_0;
}

function $addPart(this$static, buf, count){
  var oldLength;
  if (buf.impl.string.length > 0) {
    $add_4(this$static.patternParts, new DateTimeFormat$PatternPart_0(buf.impl.string, count));
    oldLength = buf.impl.string.length;
    0 < oldLength?($replace(buf.impl, 0, oldLength, '') , buf):0 > oldLength && $append_6(buf, initDim(_3C_classLit, makeCastMap([Q$Serializable]), -1, -oldLength, 1));
  }
}

--></script>
<script><!--
function $format_0(this$static, date, timeZone){
  var ch, diff, i, j, keepDate, keepTime, n, toAppendTo, trailQuote;
  !timeZone && (timeZone = createTimeZone(date.jsdate.getTimezoneOffset()));
  diff = (date.jsdate.getTimezoneOffset() - timeZone.standardOffset) * 60000;
  keepDate = new Date_2(add_4(fromDouble(date.jsdate.getTime()), fromInt(diff)));
  keepTime = keepDate;
  if (keepDate.jsdate.getTimezoneOffset() != date.jsdate.getTimezoneOffset()) {
    diff > 0?(diff -= 86400000):(diff += 86400000);
    keepTime = new Date_2(add_4(fromDouble(date.jsdate.getTime()), fromInt(diff)));
  }
  toAppendTo = new StringBuffer_1;
  n = this$static.pattern.length;
  for (i = 0; i < n;) {
    ch = $charAt(this$static.pattern, i);
    if (ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90) {
      for (j = i + 1; j < n && $charAt(this$static.pattern, j) == ch; ++j) {
      }
      $subFormat(toAppendTo, ch, j - i, keepDate, keepTime, timeZone);
      i = j;
    }
     else if (ch == 39) {
      ++i;
      if (i < n && $charAt(this$static.pattern, i) == 39) {
        toAppendTo.impl.string += "'";
        ++i;
        continue;
      }
      trailQuote = false;
      while (!trailQuote) {
        j = i;
        while (j < n && $charAt(this$static.pattern, j) != 39) {
          ++j;
        }
        if (j >= n) {
          throw new IllegalArgumentException_1("Missing trailing '");
        }
        j + 1 < n && $charAt(this$static.pattern, j + 1) == 39?++j:(trailQuote = true);
        $append_5(toAppendTo, $substring_0(this$static.pattern, i, j));
        i = j + 1;
      }
    }
     else {
      $appendNonNull(toAppendTo.impl, String.fromCharCode(ch));
      ++i;
    }
  }
  return toAppendTo.impl.string;
}

function $formatFractionalSeconds(buf, count, date){
  var time, value;
  time = fromDouble(date.jsdate.getTime());
  if (lt(time, P0_longLit)) {
    value = 1000 - toInt(mod(neg(time), P3e8_longLit));
    value == 1000 && (value = 0);
  }
   else {
    value = toInt(mod(time, P3e8_longLit));
  }
  if (count == 1) {
    value = ~~((value + 50) / 100) < 9?~~((value + 50) / 100):9;
    $appendNonNull(buf.impl, String.fromCharCode(48 + value & 65535));
  }
   else if (count == 2) {
    value = ~~((value + 5) / 10) < 99?~~((value + 5) / 10):99;
    $zeroPaddingNumber(buf, value, 2);
  }
   else {
    $zeroPaddingNumber(buf, value, 3);
    count > 3 && $zeroPaddingNumber(buf, 0, count - 3);
  }
}

function $formatMonth(buf, count, date){
  var value;
  value = date.jsdate.getMonth();
  switch (count) {
    case 5:
      $append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'])[value]);
      break;
    case 4:
      $append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'])[value]);
      break;
    case 3:
      $append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])[value]);
      break;
    default:$zeroPaddingNumber(buf, value + 1, count);
  }
}

function $formatYear(buf, count, date){
  var value;
  value = date.jsdate.getFullYear() - 1900 + 1900;
  value < 0 && (value = -value);
  switch (count) {
    case 1:
      $append_1(buf.impl, value);
      break;
    case 2:
      $zeroPaddingNumber(buf, value % 100, 2);
      break;
    default:$zeroPaddingNumber(buf, value, count);
  }
}

function $getNextCharCountInPattern(start){
  var ch, next;
  ch = 'yyyy-MM-dd HH:mm:ss,SSS'.charCodeAt(start);
  next = start + 1;
  while (next < 23 && 'yyyy-MM-dd HH:mm:ss,SSS'.charCodeAt(next) == ch) {
    ++next;
  }
  return next - start;
}

function $identifyAbutStart(this$static){
  var abut, i, len;
  abut = false;
  len = this$static.patternParts.size;
  for (i = 0; i < len; ++i) {
    if ($isNumeric($get(this$static.patternParts, i))) {
      if (!abut && i + 1 < len && $isNumeric($get(this$static.patternParts, i + 1))) {
        abut = true;
        $get(this$static.patternParts, i).abutStart = true;
      }
    }
     else {
      abut = false;
    }
  }
}

function $isNumeric(part){
  var i;
  if (part.count <= 0) {
    return false;
  }
  i = $indexOf_1('MLydhHmsSDkK', fromCodePoint(part.text.charCodeAt(0)));
  return i > 1 || i >= 0 && part.count < 3;
}

function $parsePattern(this$static){
  var buf, ch, count, i, inQuote;
  buf = new StringBuffer_1;
  inQuote = false;
  for (i = 0; i < 23; ++i) {
    ch = 'yyyy-MM-dd HH:mm:ss,SSS'.charCodeAt(i);
    if (ch == 32) {
      $addPart(this$static, buf, 0);
      buf.impl.string += ' ';
      $addPart(this$static, buf, 0);
      while (i + 1 < 23 && 'yyyy-MM-dd HH:mm:ss,SSS'.charCodeAt(i + 1) == 32) {
        ++i;
      }
      continue;
    }
    if (inQuote) {
      if (ch == 39) {
        if (i + 1 < 23 && 'yyyy-MM-dd HH:mm:ss,SSS'.charCodeAt(i + 1) == 39) {
          buf.impl.string += "'";
          ++i;
        }
         else {
          inQuote = false;
        }
      }
       else {
        $appendNonNull(buf.impl, String.fromCharCode(ch));
      }
      continue;
    }
    if ($indexOf_1('GyMLdkHmsSEcDahKzZv', fromCodePoint(ch)) > 0) {
      $addPart(this$static, buf, 0);
      $appendNonNull(buf.impl, String.fromCharCode(ch));
      count = $getNextCharCountInPattern(i);
      $addPart(this$static, buf, count);
      i += count - 1;
      continue;
    }
    if (ch == 39) {
      if (i + 1 < 23 && 'yyyy-MM-dd HH:mm:ss,SSS'.charCodeAt(i + 1) == 39) {
        buf.impl.string += "'";
        ++i;
      }
       else {
        inQuote = true;
      }
    }
     else {
      $appendNonNull(buf.impl, String.fromCharCode(ch));
    }
  }
  $addPart(this$static, buf, 0);
  $identifyAbutStart(this$static);
}

function $subFormat(buf, ch, count, adjustedDate, adjustedTime, timezone){
  var value, value_0, value_1, value_2, value_3, value_4, value_5, value_6, value_7, value_8, value_9, value_10;
  switch (ch) {
    case 71:
      value = adjustedDate.jsdate.getFullYear() - 1900 >= -1900?1:0;
      count >= 4?$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Before Christ', 'Anno Domini'])[value]):$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['BC', 'AD'])[value]);
      break;
    case 121:
      $formatYear(buf, count, adjustedDate);
      break;
    case 77:
      $formatMonth(buf, count, adjustedDate);
      break;
    case 107:
      value_0 = adjustedTime.jsdate.getHours();
      value_0 == 0?$zeroPaddingNumber(buf, 24, count):$zeroPaddingNumber(buf, value_0, count);
      break;
    case 83:
      $formatFractionalSeconds(buf, count, adjustedTime);
      break;
    case 69:
      value_1 = adjustedDate.jsdate.getDay();
      count == 5?$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['S', 'M', 'T', 'W', 'T', 'F', 'S'])[value_1]):count == 4?$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'])[value_1]):$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'])[value_1]);
      break;
    case 97:
      adjustedTime.jsdate.getHours() >= 12 && adjustedTime.jsdate.getHours() < 24?$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['AM', 'PM'])[1]):$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['AM', 'PM'])[0]);
      break;
    case 104:
      value_2 = adjustedTime.jsdate.getHours() % 12;
      value_2 == 0?$zeroPaddingNumber(buf, 12, count):$zeroPaddingNumber(buf, value_2, count);
      break;
    case 75:
      value_3 = adjustedTime.jsdate.getHours() % 12;
      $zeroPaddingNumber(buf, value_3, count);
      break;
    case 72:
      value_4 = adjustedTime.jsdate.getHours();
      $zeroPaddingNumber(buf, value_4, count);
      break;
    case 99:
      value_5 = adjustedDate.jsdate.getDay();
      count == 5?$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['S', 'M', 'T', 'W', 'T', 'F', 'S'])[value_5]):count == 4?$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'])[value_5]):count == 3?$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'])[value_5]):$zeroPaddingNumber(buf, value_5, 1);
      break;
    case 76:
      value_6 = adjustedDate.jsdate.getMonth();
      count == 5?$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'])[value_6]):count == 4?$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'])[value_6]):count == 3?$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])[value_6]):$zeroPaddingNumber(buf, value_6 + 1, count);
      break;
    case 81:
      value_7 = ~~(adjustedDate.jsdate.getMonth() / 3);
      count < 4?$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Q1', 'Q2', 'Q3', 'Q4'])[value_7]):$append_5(buf, initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'])[value_7]);
      break;
    case 100:
      value_8 = adjustedDate.jsdate.getDate();
      $zeroPaddingNumber(buf, value_8, count);
      break;
    case 109:
      value_9 = adjustedTime.jsdate.getMinutes();
      $zeroPaddingNumber(buf, value_9, count);
      break;
    case 115:
      value_10 = adjustedTime.jsdate.getSeconds();
      $zeroPaddingNumber(buf, value_10, count);
      break;
    case 122:
      count < 4?$append_5(buf, timezone.tzNames[0]):$append_5(buf, timezone.tzNames[1]);
      break;
    case 118:
      $append_5(buf, timezone.timezoneID);
      break;
    case 90:
      count < 3?$append_5(buf, $getRFCTimeZoneString(timezone)):count == 3?$append_5(buf, $getISOTimeZoneString(timezone)):$append_5(buf, composeGMTString(timezone.standardOffset));
      break;
    default:return false;
  }
  return true;
}

function $zeroPaddingNumber(buf, value, minWidth){
  var b, i;
  b = 10;
  for (i = 0; i < minWidth - 1; ++i) {
    value < b && (buf.impl.string += '0' , buf);
    b *= 10;
  }
  $append_1(buf.impl, value);
}

defineSeed(241, 1, {});
_.pattern = null;
function $clinit_DateTimeFormat_0(){
  $clinit_DateTimeFormat_0 = nullMethod;
  $clinit_DateTimeFormat();
  cache_0 = new HashMap_0;
}

function DateTimeFormat_1(){
  $clinit_DateTimeFormat();
  this.patternParts = new ArrayList_0;
  this.pattern = 'yyyy-MM-dd HH:mm:ss,SSS';
  $parsePattern(this);
}

function getFormat(dtfi){
  $clinit_DateTimeFormat_0();
  var defaultDtfi, dtf;
  defaultDtfi = $getDateTimeFormatInfo(($clinit_LocaleInfo() , $clinit_LocaleInfo() , instance_3));
  dtf = null;
  dtfi == defaultDtfi && (dtf = $get_4(cache_0, 'yyyy-MM-dd HH:mm:ss,SSS'));
  if (!dtf) {
    dtf = new DateTimeFormat_1;
    dtfi == defaultDtfi && $put_2(cache_0, 'yyyy-MM-dd HH:mm:ss,SSS', dtf);
  }
  return dtf;
}

defineSeed(240, 241, {}, DateTimeFormat_1);
var cache_0 = null;
defineSeed(243, 1, {});
defineSeed(242, 243, {});
function $clinit_LocaleInfo(){
  $clinit_LocaleInfo = nullMethod;
  instance_3 = new LocaleInfo_0;
}

function $getDateTimeFormatInfo(this$static){
  !this$static.dateTimeFormatInfo && (this$static.dateTimeFormatInfo = new DateTimeFormatInfoImpl_0);
  return this$static.dateTimeFormatInfo;
}

function LocaleInfo_0(){
}

defineSeed(244, 1, {}, LocaleInfo_0);
_.dateTimeFormatInfo = null;
var instance_3;
function $getISOTimeZoneString(this$static){
  var data, offset;
  offset = -this$static.standardOffset;
  data = initValues(_3C_classLit, makeCastMap([Q$Serializable]), -1, [43, 48, 48, 58, 48, 48]);
  if (offset < 0) {
    data[0] = 45;
    offset = -offset;
  }
  data[1] = data[1] + ~~(~~(offset / 60) / 10) & 65535;
  data[2] = data[2] + ~~(offset / 60) % 10 & 65535;
  data[4] = data[4] + ~~(offset % 60 / 10) & 65535;
  data[5] = data[5] + offset % 10 & 65535;
  return valueOf_1(data);
}

function $getRFCTimeZoneString(this$static){
  var data, offset;
  offset = -this$static.standardOffset;
  data = initValues(_3C_classLit, makeCastMap([Q$Serializable]), -1, [43, 48, 48, 48, 48]);
  if (offset < 0) {
    data[0] = 45;
    offset = -offset;
  }
  data[1] = data[1] + ~~(~~(offset / 60) / 10) & 65535;
  data[2] = data[2] + ~~(offset / 60) % 10 & 65535;
  data[3] = data[3] + ~~(offset % 60 / 10) & 65535;
  data[4] = data[4] + offset % 10 & 65535;
  return valueOf_1(data);
}

function TimeZone_0(){
}

function composeGMTString(offset){
  var data;
  data = initValues(_3C_classLit, makeCastMap([Q$Serializable]), -1, [71, 77, 84, 45, 48, 48, 58, 48, 48]);
  if (offset <= 0) {
    data[3] = 43;
    offset = -offset;
  }
  data[4] = data[4] + ~~(~~(offset / 60) / 10) & 65535;
  data[5] = data[5] + ~~(offset / 60) % 10 & 65535;
  data[7] = data[7] + ~~(offset % 60 / 10) & 65535;
  data[8] = data[8] + offset % 10 & 65535;
  return valueOf_1(data);
}

function composePOSIXTimeZoneID(offset){
  var str;
  if (offset == 0) {
    return 'Etc/GMT';
  }
  if (offset < 0) {
    offset = -offset;
    str = 'Etc/GMT-';
  }
   else {
    str = 'Etc/GMT+';
  }
  return str + offsetDisplay(offset);
}

function composeUTCString(offset){
  var str;
  if (offset == 0) {
    return 'UTC';
  }
  if (offset < 0) {
    offset = -offset;
    str = 'UTC+';
  }
   else {
    str = 'UTC-';
  }
  return str + offsetDisplay(offset);
}

function createTimeZone(timeZoneOffsetInMinutes){
  var tz;
  tz = new TimeZone_0;
  tz.standardOffset = timeZoneOffsetInMinutes;
  tz.timezoneID = composePOSIXTimeZoneID(timeZoneOffsetInMinutes);
  tz.tzNames = initDim(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, 2, 0);
  tz.tzNames[0] = composeUTCString(timeZoneOffsetInMinutes);
  tz.tzNames[1] = composeUTCString(timeZoneOffsetInMinutes);
  return tz;
}

function offsetDisplay(offset){
  var hour, mins;
  hour = ~~(offset / 60);
  mins = offset % 60;
  if (mins == 0) {
    return '' + hour;
  }
  return '' + hour + ':' + mins;
}

defineSeed(245, 1, {}, TimeZone_0);
_.standardOffset = 0;
_.timezoneID = null;
_.tzNames = null;
function DateTimeFormatInfoImpl_0(){
}

defineSeed(246, 242, {}, DateTimeFormatInfoImpl_0);
function DateTimeFormat$PatternPart_0(txt, cnt){
  this.text = txt;
  this.count = cnt;
  this.abutStart = false;
}

defineSeed(247, 1, {}, DateTimeFormat$PatternPart_0);
_.abutStart = false;
_.count = 0;
_.text = null;
function Array_0(){
}

function cloneSubrange(array, fromIndex, toIndex){
  var a, result;
  a = array;
  result = a.slice(fromIndex, toIndex);
  initValues(a.___clazz$, a.castableTypeMap$, a.queryId$, result);
  return result;
}

function createFrom(array, length_0){
  var a, result;
  a = array;
  result = createFromSeed(0, length_0);
  initValues(a.___clazz$, a.castableTypeMap$, a.queryId$, result);
  return result;
}

function createFromSeed(seedType, length_0){
  var array = new Array(length_0);
  if (seedType == 3) {
    for (var i = 0; i < length_0; ++i) {
      var value = new Object;
      value.l = value.m = value.h = 0;
      array[i] = value;
    }
  }
   else if (seedType > 0) {
    var value = [null, 0, false][seedType];
    for (var i = 0; i < length_0; ++i) {
      array[i] = value;
    }
  }
  return array;
}

function initDim(arrayClass, castableTypeMap, queryId, length_0, seedType){
  var result;
  result = createFromSeed(seedType, length_0);
  initValues(arrayClass, castableTypeMap, queryId, result);
  return result;
}

function initDims(arrayClasses, castableTypeMapExprs, queryIdExprs, dimExprs, count, seedType){
  return initDims_0(arrayClasses, castableTypeMapExprs, queryIdExprs, dimExprs, 0, count, seedType);
}

function initDims_0(arrayClasses, castableTypeMapExprs, queryIdExprs, dimExprs, index, count, seedType){
  var i, isLastDim, length_0, result;
  length_0 = dimExprs[index];
  isLastDim = index == count - 1;
  result = createFromSeed(isLastDim?seedType:0, length_0);
  initValues(arrayClasses[index], castableTypeMapExprs[index], queryIdExprs[index], result);
  if (!isLastDim) {
    ++index;
    for (i = 0; i < length_0; ++i) {
      result[i] = initDims_0(arrayClasses, castableTypeMapExprs, queryIdExprs, dimExprs, index, count, seedType);
    }
  }
  return result;
}

function initValues(arrayClass, castableTypeMap, queryId, array){
  $clinit_Array$ExpandoWrapper();
  wrapArray(array, expandoNames_0, expandoValues_0);
  array.___clazz$ = arrayClass;
  array.castableTypeMap$ = castableTypeMap;
  array.queryId$ = queryId;
  return array;
}

function setCheck(array, index, value){
  if (value != null) {
    if (array.queryId$ > 0 && !canCastUnsafe(value, array.queryId$)) {
      throw new ArrayStoreException_0;
    }
     else if (array.queryId$ == -1 && (value.typeMarker$ == nullMethod || canCast(value, 1))) {
      throw new ArrayStoreException_0;
    }
     else if (array.queryId$ < -1 && !(value.typeMarker$ != nullMethod && !canCast(value, 1)) && !canCastUnsafe(value, -array.queryId$)) {
      throw new ArrayStoreException_0;
    }
  }
  return array[index] = value;
}

defineSeed(248, 1, {}, Array_0);
_.queryId$ = 0;
function $clinit_Array$ExpandoWrapper(){
  $clinit_Array$ExpandoWrapper = nullMethod;
  expandoNames_0 = [];
  expandoValues_0 = [];
  initExpandos(new Array_0, expandoNames_0, expandoValues_0);
}

function initExpandos(protoType, expandoNames, expandoValues){
  var i = 0, value;
  for (var name_0 in protoType) {
    if (value = protoType[name_0]) {
      expandoNames[i] = name_0;
      expandoValues[i] = value;
      ++i;
    }
  }
}

function wrapArray(array, expandoNames, expandoValues){
  $clinit_Array$ExpandoWrapper();
  for (var i = 0, c = expandoNames.length; i < c; ++i) {
    array[expandoNames[i]] = expandoValues[i];
  }
}

var expandoNames_0, expandoValues_0;
function canCast(src, dstId){
  return src.castableTypeMap$ && !!src.castableTypeMap$[dstId];
}

function canCastUnsafe(src, dstId){
  return src.castableTypeMap$ && src.castableTypeMap$[dstId];
}

function instanceOf(src, dstId){
  return src != null && canCast(src, dstId);
}

function instanceOfJso(src){
  return src != null && src.typeMarker$ != nullMethod && !canCast(src, 1);
}

function isJavaObject(src){
  return src.typeMarker$ == nullMethod || canCast(src, 1);
}

function maskUndefined(src){
  return src == null?null:src;
}

function round_int(x){
  return ~~Math.max(Math.min(x, 2147483647), -2147483648);
}

function init(){
  !!$stats && onModuleStart('com.google.gwt.useragent.client.UserAgentAsserter');
  !!$stats && onModuleStart('com.google.gwt.user.client.DocumentModeAsserter');
  $onModuleLoad();
  !!$stats && onModuleStart('bomberman.html.BomberManHtml');
  setUncaughtExceptionHandler(new HtmlGame$1_0);
  $scheduleDeferred(($clinit_SchedulerImpl() , INSTANCE), new HtmlGame$2_0);
}

function caught_0(e){
  if (instanceOf(e, Q$Throwable)) {
    return e;
  }
  return new JavaScriptException_0(e);
}

function create_0(value){
  var a0, a1, a2;
  a0 = value & 4194303;
  a1 = ~~value >> 22 & 4194303;
  a2 = value < 0?1048575:0;
  return create0(a0, a1, a2);
}

function create_1(a){
  return create0(a.l, a.m, a.h);
}

function create0(l_0, m_0, h_0){
  return _ = new LongLibBase$LongEmul_0 , _.l = l_0 , _.m = m_0 , _.h = h_0 , _;
}

function divMod(a, b, computeRemainder){
  var aIsCopy, aIsMinValue, aIsNegative, bpower, c, negative;
  if (b.l == 0 && b.m == 0 && b.h == 0) {
    throw new ArithmeticException_0;
  }
  if (a.l == 0 && a.m == 0 && a.h == 0) {
    computeRemainder && (remainder_0 = create0(0, 0, 0));
    return create0(0, 0, 0);
  }
  if (b.h == 524288 && b.m == 0 && b.l == 0) {
    return divModByMinValue(a, computeRemainder);
  }
  negative = false;
  if (~~b.h >> 19 != 0) {
    b = neg(b);
    negative = true;
  }
  bpower = powerOfTwo(b);
  aIsNegative = false;
  aIsMinValue = false;
  aIsCopy = false;
  if (a.h == 524288 && a.m == 0 && a.l == 0) {
    aIsMinValue = true;
    aIsNegative = true;
    if (bpower == -1) {
      a = create_1(($clinit_LongLib$Const() , MAX_VALUE));
      aIsCopy = true;
      negative = !negative;
    }
     else {
      c = shr(a, bpower);
      negative && negate(c);
      computeRemainder && (remainder_0 = create0(0, 0, 0));
      return c;
    }
  }
   else if (~~a.h >> 19 != 0) {
    aIsNegative = true;
    a = neg(a);
    aIsCopy = true;
    negative = !negative;
  }
  if (bpower != -1) {
    return divModByShift(a, bpower, negative, aIsNegative, computeRemainder);
  }
  if (!gte_0(a, b)) {
    computeRemainder && (aIsNegative?(remainder_0 = neg(a)):(remainder_0 = create0(a.l, a.m, a.h)));
    return create0(0, 0, 0);
  }
  return divModHelper(aIsCopy?a:create0(a.l, a.m, a.h), b, negative, aIsNegative, aIsMinValue, computeRemainder);
}

function divModByMinValue(a, computeRemainder){
  if (a.h == 524288 && a.m == 0 && a.l == 0) {
    computeRemainder && (remainder_0 = create0(0, 0, 0));
    return create_1(($clinit_LongLib$Const() , ONE));
  }
  computeRemainder && (remainder_0 = create0(a.l, a.m, a.h));
  return create0(0, 0, 0);
}

function divModByShift(a, bpower, negative, aIsNegative, computeRemainder){
  var c;
  c = shr(a, bpower);
  negative && negate(c);
  if (computeRemainder) {
    a = maskRight(a, bpower);
    aIsNegative?(remainder_0 = neg(a)):(remainder_0 = create0(a.l, a.m, a.h));
  }
  return c;
}

function divModHelper(a, b, negative, aIsNegative, aIsMinValue, computeRemainder){
  var bshift, gte, quotient, shift, a1, a2, a0;
  shift = numberOfLeadingZeros(b) - numberOfLeadingZeros(a);
  bshift = shl(b, shift);
  quotient = create0(0, 0, 0);
  while (shift >= 0) {
    gte = trialSubtract(a, bshift);
    if (gte) {
      shift < 22?(quotient.l |= 1 << shift , undefined):shift < 44?(quotient.m |= 1 << shift - 22 , undefined):(quotient.h |= 1 << shift - 44 , undefined);
      if (a.l == 0 && a.m == 0 && a.h == 0) {
        break;
      }
    }
    a1 = bshift.m;
    a2 = bshift.h;
    a0 = bshift.l;
    bshift.h = ~~a2 >>> 1;
    bshift.m = ~~a1 >>> 1 | (a2 & 1) << 21;
    bshift.l = ~~a0 >>> 1 | (a1 & 1) << 21;
    --shift;
  }
  negative && negate(quotient);
  if (computeRemainder) {
    if (aIsNegative) {
      remainder_0 = neg(a);
      aIsMinValue && (remainder_0 = sub(remainder_0, ($clinit_LongLib$Const() , ONE)));
    }
     else {
      remainder_0 = create0(a.l, a.m, a.h);
    }
  }
  return quotient;
}

function maskRight(a, bits){
  var b0, b1, b2;
  if (bits <= 22) {
    b0 = a.l & (1 << bits) - 1;
    b1 = b2 = 0;
  }
   else if (bits <= 44) {
    b0 = a.l;
    b1 = a.m & (1 << bits - 22) - 1;
    b2 = 0;
  }
   else {
    b0 = a.l;
    b1 = a.m;
    b2 = a.h & (1 << bits - 44) - 1;
  }
  return create0(b0, b1, b2);
}

function negate(a){
  var neg0, neg1, neg2;
  neg0 = ~a.l + 1 & 4194303;
  neg1 = ~a.m + (neg0 == 0?1:0) & 4194303;
  neg2 = ~a.h + (neg0 == 0 && neg1 == 0?1:0) & 1048575;
  a.l = neg0;
  a.m = neg1;
  a.h = neg2;
}

function numberOfLeadingZeros(a){
  var b1, b2;
  b2 = numberOfLeadingZeros_0(a.h);
  if (b2 == 32) {
    b1 = numberOfLeadingZeros_0(a.m);
    return b1 == 32?numberOfLeadingZeros_0(a.l) + 32:b1 + 20 - 10;
  }
   else {
    return b2 - 12;
  }
}

function powerOfTwo(a){
  var h_0, l_0, m_0;
  l_0 = a.l;
  if ((l_0 & l_0 - 1) != 0) {
    return -1;
  }
  m_0 = a.m;
  if ((m_0 & m_0 - 1) != 0) {
    return -1;
  }
  h_0 = a.h;
  if ((h_0 & h_0 - 1) != 0) {
    return -1;
  }
  if (h_0 == 0 && m_0 == 0 && l_0 == 0) {
    return -1;
  }
  if (h_0 == 0 && m_0 == 0 && l_0 != 0) {
    return numberOfTrailingZeros(l_0);
  }
  if (h_0 == 0 && m_0 != 0 && l_0 == 0) {
    return numberOfTrailingZeros(m_0) + 22;
  }
  if (h_0 != 0 && m_0 == 0 && l_0 == 0) {
    return numberOfTrailingZeros(h_0) + 44;
  }
  return -1;
}

function toDoubleHelper(a){
  return a.l + a.m * 4194304 + a.h * 17592186044416;
}

function trialSubtract(a, b){
  var sum0, sum1, sum2;
  sum2 = a.h - b.h;
  if (sum2 < 0) {
    return false;
  }
  sum0 = a.l - b.l;
  sum1 = a.m - b.m + (~~sum0 >> 22);
  sum2 += ~~sum1 >> 22;
  if (sum2 < 0) {
    return false;
  }
  a.l = sum0 & 4194303;
  a.m = sum1 & 4194303;
  a.h = sum2 & 1048575;
  return true;
}

var remainder_0 = null;
function add_4(a, b){
  var sum0, sum1, sum2;
  sum0 = a.l + b.l;
  sum1 = a.m + b.m + (~~sum0 >> 22);
  sum2 = a.h + b.h + (~~sum1 >> 22);
  return create0(sum0 & 4194303, sum1 & 4194303, sum2 & 1048575);
}

function and(a, b){
  return create0(a.l & b.l, a.m & b.m, a.h & b.h);
}

function eq(a, b){
  return a.l == b.l && a.m == b.m && a.h == b.h;
}

function fromDouble(value){
  var a0, a1, a2, negative, result;
  if (isNaN_0(value)) {
    return $clinit_LongLib$Const() , ZERO;
  }
  if (value < -9223372036854775808) {
    return $clinit_LongLib$Const() , MIN_VALUE;
  }
  if (value >= 9223372036854775807) {
    return $clinit_LongLib$Const() , MAX_VALUE;
  }
  negative = false;
  if (value < 0) {
    negative = true;
    value = -value;
  }
  a2 = 0;
  if (value >= 17592186044416) {
    a2 = round_int(value / 17592186044416);
    value -= a2 * 17592186044416;
  }
  a1 = 0;
  if (value >= 4194304) {
    a1 = round_int(value / 4194304);
    value -= a1 * 4194304;
  }
  a0 = round_int(value);
  result = create0(a0, a1, a2);
  negative && negate(result);
  return result;
}

function fromInt(value){
  var rebase, result;
  if (value > -129 && value < 128) {
    rebase = value + 128;
    boxedValues == null && (boxedValues = initDim(_3Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$LongLibBase$LongEmul, 256, 0));
    result = boxedValues[rebase];
    !result && (result = boxedValues[rebase] = create_0(value));
    return result;
  }
  return create_0(value);
}

function gt(a, b){
  var signa, signb;
  signa = ~~a.h >> 19;
  signb = ~~b.h >> 19;
  return signa == 0?signb != 0 || a.h > b.h || a.h == b.h && a.m > b.m || a.h == b.h && a.m == b.m && a.l > b.l:!(signb == 0 || a.h < b.h || a.h == b.h && a.m < b.m || a.h == b.h && a.m == b.m && a.l <= b.l);
}

function gte_0(a, b){
  var signa, signb;
  signa = ~~a.h >> 19;
  signb = ~~b.h >> 19;
  return signa == 0?signb != 0 || a.h > b.h || a.h == b.h && a.m > b.m || a.h == b.h && a.m == b.m && a.l >= b.l:!(signb == 0 || a.h < b.h || a.h == b.h && a.m < b.m || a.h == b.h && a.m == b.m && a.l < b.l);
}

function lt(a, b){
  return !gte_0(a, b);
}

function mod(a, b){
  divMod(a, b, true);
  return remainder_0;
}

function neg(a){
  var neg0, neg1, neg2;
  neg0 = ~a.l + 1 & 4194303;
  neg1 = ~a.m + (neg0 == 0?1:0) & 4194303;
  neg2 = ~a.h + (neg0 == 0 && neg1 == 0?1:0) & 1048575;
  return create0(neg0, neg1, neg2);
}

function or(a, b){
  return create0(a.l | b.l, a.m | b.m, a.h | b.h);
}

function shl(a, n){
  var res0, res1, res2;
  n &= 63;
  if (n < 22) {
    res0 = a.l << n;
    res1 = a.m << n | ~~a.l >> 22 - n;
    res2 = a.h << n | ~~a.m >> 22 - n;
  }
   else if (n < 44) {
    res0 = 0;
    res1 = a.l << n - 22;
    res2 = a.m << n - 22 | ~~a.l >> 44 - n;
  }
   else {
    res0 = 0;
    res1 = 0;
    res2 = a.l << n - 44;
  }
  return create0(res0 & 4194303, res1 & 4194303, res2 & 1048575);
}

function shr(a, n){
  var a2, negative, res0, res1, res2;
  n &= 63;
  a2 = a.h;
  negative = (a2 & 524288) != 0;
  negative && (a2 |= -1048576);
  if (n < 22) {
    res2 = ~~a2 >> n;
    res1 = ~~a.m >> n | a2 << 22 - n;
    res0 = ~~a.l >> n | a.m << 22 - n;
  }
   else if (n < 44) {
    res2 = negative?1048575:0;
    res1 = ~~a2 >> n - 22;
    res0 = ~~a.m >> n - 22 | a2 << 44 - n;
  }
   else {
    res2 = negative?1048575:0;
    res1 = negative?4194303:0;
    res0 = ~~a2 >> n - 44;
  }
  return create0(res0 & 4194303, res1 & 4194303, res2 & 1048575);
}

function shru(a, n){
  var a2, res0, res1, res2;
  n &= 63;
  a2 = a.h & 1048575;
  if (n < 22) {
    res2 = ~~a2 >>> n;
    res1 = ~~a.m >> n | a2 << 22 - n;
    res0 = ~~a.l >> n | a.m << 22 - n;
  }
   else if (n < 44) {
    res2 = 0;
    res1 = ~~a2 >>> n - 22;
    res0 = ~~a.m >> n - 22 | a.h << 44 - n;
  }
   else {
    res2 = 0;
    res1 = 0;
    res0 = ~~a2 >>> n - 44;
  }
  return create0(res0 & 4194303, res1 & 4194303, res2 & 1048575);
}

function sub(a, b){
  var sum0, sum1, sum2;
  sum0 = a.l - b.l;
  sum1 = a.m - b.m + (~~sum0 >> 22);
  sum2 = a.h - b.h + (~~sum1 >> 22);
  return create0(sum0 & 4194303, sum1 & 4194303, sum2 & 1048575);
}

function toDouble(a){
  if (eq(a, ($clinit_LongLib$Const() , MIN_VALUE))) {
    return -9223372036854775808;
  }
  if (!gte_0(a, ZERO)) {
    return -toDoubleHelper(neg(a));
  }
  return a.l + a.m * 4194304 + a.h * 17592186044416;
}

function toInt(a){
  return a.l | a.m << 22;
}

function xor(a, b){
  return create0(a.l ^ b.l, a.m ^ b.m, a.h ^ b.h);
}

var boxedValues = null;
--></script>
<script><!--
function $clinit_LongLib$Const(){
  $clinit_LongLib$Const = nullMethod;
  MAX_VALUE = create0(4194303, 4194303, 524287);
  MIN_VALUE = create0(0, 0, 524288);
  ONE = fromInt(1);
  fromInt(2);
  ZERO = fromInt(0);
}

var MAX_VALUE, MIN_VALUE, ONE, ZERO;
function LongLibBase$LongEmul_0(){
}

defineSeed(257, 1, makeCastMap([Q$LongLibBase$LongEmul]), LongLibBase$LongEmul_0);
function onModuleStart(mainClassName){
  return $stats({moduleName:$moduleName, sessionId:$sessionId, subSystem:'startup', evtGroup:'moduleStartup', millis:(new Date).getTime(), type:'onModuleLoadStart', className:mainClassName});
}

function $sinkBitlessEvent(this$static, eventTypeName){
  $sinkBitlessEvent_0(this$static.element, eventTypeName);
}

defineSeed(265, 1, makeCastMap([Q$HasVisibility, Q$UIObject]));
_.toString$ = function toString_12(){
  if (!this.element) {
    return '(null handle)';
  }
  return this.element.outerHTML;
}
;
_.element = null;
function $addBitlessDomHandler(this$static, handler, type){
  $sinkBitlessEvent(this$static, type.name_0);
  return $addHandler(!this$static.handlerManager?(this$static.handlerManager = new HandlerManager_0(this$static)):this$static.handlerManager, type, handler);
}

function $fireEvent_0(this$static, event_0){
  !!this$static.handlerManager && $fireEvent(this$static.handlerManager, event_0);
}

function $onAttach(this$static){
  var bitsToAdd;
  if (this$static.attached) {
    throw new IllegalStateException_1("Should only call onAttach when the widget is detached from the browser's document");
  }
  this$static.attached = true;
  $setEventListener(this$static.element, this$static);
  bitsToAdd = this$static.eventsToSink;
  this$static.eventsToSink = -1;
  bitsToAdd > 0 && (this$static.eventsToSink == -1?$sinkEvents(this$static.element, bitsToAdd | (this$static.element.__eventBits || 0)):(this$static.eventsToSink |= bitsToAdd));
  this$static.doAttachChildren();
}

function $onDetach(this$static){
  if (!this$static.attached) {
    throw new IllegalStateException_1("Should only call onDetach when the widget is attached to the browser's document");
  }
  try {
    this$static.doDetachChildren();
  }
   finally {
    this$static.element.__listener = null;
    this$static.attached = false;
  }
}

function $removeFromParent(this$static){
  if (!this$static.parent_0) {
    ($clinit_RootPanel() , $contains_2(widgetsToDetach, this$static)) && detachNow(this$static);
  }
   else if (this$static.parent_0) {
    $remove_6(this$static.parent_0, this$static);
  }
   else if (this$static.parent_0) {
    throw new IllegalStateException_1("This widget's parent does not implement HasWidgets");
  }
}

function $setParent(this$static, parent_0){
  var oldParent;
  oldParent = this$static.parent_0;
  if (!parent_0) {
    try {
      !!oldParent && oldParent.attached && $onDetach(this$static);
    }
     finally {
      this$static.parent_0 = null;
    }
  }
   else {
    if (oldParent) {
      throw new IllegalStateException_1('Cannot set a new parent without first clearing the old parent');
    }
    this$static.parent_0 = parent_0;
    parent_0.attached && this$static.onAttach();
  }
}

defineSeed(264, 265, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.doAttachChildren = function doAttachChildren(){
}
;
_.doDetachChildren = function doDetachChildren(){
}
;
_.onAttach = function onAttach(){
  $onAttach(this);
}
;
_.onBrowserEvent = function onBrowserEvent(event_0){
  var related;
  switch ($eventGetTypeInt(event_0.type)) {
    case 16:
    case 32:
      related = event_0.relatedTarget;
      if (!!related && $isOrHasChild(this.element, related)) {
        return;
      }

  }
  fireNativeEvent(event_0, this, this.element);
}
;
_.attached = false;
_.eventsToSink = 0;
_.handlerManager = null;
_.parent_0 = null;
defineSeed(263, 264, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.onAttach = function onAttach_0(){
  var tabIndex;
  $onAttach(this);
  tabIndex = $getTabIndex(this.element);
  -1 == tabIndex && (this.element.tabIndex = 0 , undefined);
}
;
defineSeed(262, 263, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
function Audio_0(element){
  this.element = element;
}

function createIfSupported(){
  var element;
  !detector && (detector = new Audio$AudioElementSupportDetectedMaybe_0);
  element = $doc.createElement('audio');
  if (!element.canPlayType) {
    return null;
  }
  return new Audio_0(element);
}

function isSupported_2(){
  var element;
  !detector && (detector = new Audio$AudioElementSupportDetectedMaybe_0);
  element = $doc.createElement('audio');
  if (!element.canPlayType) {
    return false;
  }
  return true;
}

defineSeed(261, 262, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]), Audio_0);
var detector = null;
defineSeed(267, 1, {});
function Audio$AudioElementSupportDetectedMaybe_0(){
}

defineSeed(266, 267, {}, Audio$AudioElementSupportDetectedMaybe_0);
function $exec(this$static, input){
  return this$static.exec(input);
}

function $getItem(this$static, key){
  return $getItem_0(this$static.storage, key);
}

function $key(this$static, index){
  return $key_0(this$static.storage, index);
}

function $removeItem(this$static, key){
  $removeItem_0(this$static.storage, key);
}

function $setItem(this$static, key, data){
  $setItem_0(this$static.storage, key, data);
}

function Storage_0(){
  this.storage = 'localStorage';
}

function getLocalStorageIfSupported(){
  if ((!supportDetectorImpl && (supportDetectorImpl = new Storage$StorageSupportDetector_0) , supportDetectorImpl).isLocalStorageSupported) {
    !localStorage_0 && (localStorage_0 = new Storage_0);
    return localStorage_0;
  }
  return null;
}

defineSeed(270, 1, {}, Storage_0);
_.storage = null;
var localStorage_0 = null, supportDetectorImpl = null;
function Storage$StorageSupportDetector_0(){
  this.isLocalStorageSupported = $wnd.localStorage != null;
  $wnd.sessionStorage != null;
}

defineSeed(271, 1, {}, Storage$StorageSupportDetector_0);
function $getItem_0(storage, key){
  return $wnd[storage].getItem(key);
}

function $getLength(storage){
  return $wnd[storage].length;
}

function $key_0(storage, index){
  return index >= 0 && index < $wnd[storage].length?$wnd[storage].key(index):null;
}

function $removeItem_0(storage, key){
  $wnd[storage].getItem(key);
  $wnd[storage].removeItem(key);
}

function $setItem_0(storage, key, data){
  $wnd[storage].getItem(key);
  $wnd[storage].setItem(key, data);
}

function $implFindEntry(this$static, key, remove){
  var entry, iter, k;
  for (iter = this$static.entrySet_0().iterator(); iter.hasNext();) {
    entry = iter.next_0();
    k = entry.getKey();
    if (key == null?k == null:equals__devirtual$(key, k)) {
      remove && iter.remove_2();
      return entry;
    }
  }
  return null;
}

function $keySet(this$static){
  var entrySet;
  entrySet = new AbstractHashMap$EntrySet_0(this$static);
  return new AbstractMap$1_0(this$static, entrySet);
}

defineSeed(275, 1, makeCastMap([Q$Map]));
_.containsKey = function containsKey(key){
  return !!$implFindEntry(this, key, false);
}
;
_.equals$ = function equals_4(obj){
  var entry, entry$iterator, otherKey, otherMap, otherValue;
  if (obj === this) {
    return true;
  }
  if (!instanceOf(obj, Q$Map)) {
    return false;
  }
  otherMap = obj;
  if (this.size_0() != otherMap.size_0()) {
    return false;
  }
  for (entry$iterator = otherMap.entrySet_0().iterator(); entry$iterator.hasNext();) {
    entry = entry$iterator.next_0();
    otherKey = entry.getKey();
    otherValue = entry.getValue();
    if (!this.containsKey(otherKey)) {
      return false;
    }
    if (!equalsWithNullCheck(otherValue, this.get_0(otherKey))) {
      return false;
    }
  }
  return true;
}
;
_.get_0 = function get_0(key){
  var entry;
  entry = $implFindEntry(this, key, false);
  return !entry?null:entry.getValue();
}
;
_.hashCode$ = function hashCode_4(){
  var entry, entry$iterator, hashCode;
  hashCode = 0;
  for (entry$iterator = this.entrySet_0().iterator(); entry$iterator.hasNext();) {
    entry = entry$iterator.next_0();
    hashCode += entry.hashCode$();
    hashCode = ~~hashCode;
  }
  return hashCode;
}
;
_.isEmpty = function isEmpty_1(){
  return this.size_0() == 0;
}
;
_.put = function put(key, value){
  throw new UnsupportedOperationException_1('Put not supported on this map');
}
;
_.remove_1 = function remove_4(key){
  var entry;
  entry = $implFindEntry(this, key, true);
  return !entry?null:entry.getValue();
}
;
_.size_0 = function size_1(){
  return this.entrySet_0().size_0();
}
;
_.toString$ = function toString_13(){
  var comma, entry, iter, s;
  s = '{';
  comma = false;
  for (iter = this.entrySet_0().iterator(); iter.hasNext();) {
    entry = iter.next_0();
    comma?(s += ', '):(comma = true);
    s += '' + entry.getKey();
    s += '=';
    s += '' + entry.getValue();
  }
  return s + '}';
}
;
function $containsKey(this$static, key){
  return $getItem(this$static.storage, toString__devirtual$(key)) != null;
}

function $eq(a, b){
  if (maskUndefined(a) === maskUndefined(b)) {
    return true;
  }
  if (a == null) {
    return false;
  }
  return $equals(a, b);
}

function $get_0(this$static, key){
  if (key == null) {
    return null;
  }
  return $getItem(this$static.storage, toString__devirtual$(key));
}

function $put(){
  throw new IllegalArgumentException_1('Key and value cannot be null!');
}

function $remove_4(this$static, key){
  var old;
  old = $getItem(this$static.storage, key);
  $removeItem(this$static.storage, key);
  return old;
}

function StorageMap_0(storage){
  this.storage = storage;
}

defineSeed(274, 275, makeCastMap([Q$Map]), StorageMap_0);
_.containsKey = function containsKey_0(key){
  return $containsKey(this, key);
}
;
_.entrySet_0 = function entrySet_0(){
  !this.entrySet && (this.entrySet = new StorageMap$StorageEntrySet_0(this));
  return this.entrySet;
}
;
_.get_0 = function get_1(key){
  return $get_0(this, key);
}
;
_.put = function put_0(key, value){
  return $put(value);
}
;
_.remove_1 = function remove_5(key){
  return $remove_4(this, key);
}
;
_.size_0 = function size_2(){
  return $getLength(this.storage.storage);
}
;
_.entrySet = null;
_.storage = null;
function StorageMap$StorageEntry_0(this$0, key){
  this.this$0 = this$0;
  this.key_0 = key;
}

defineSeed(276, 1, makeCastMap([Q$Map$Entry]), StorageMap$StorageEntry_0);
_.equals$ = function equals_5(obj){
  var e;
  if (obj == null) {
    return false;
  }
   else if (obj === this) {
    return true;
  }
   else if (!instanceOf(obj, Q$Map$Entry)) {
    return false;
  }
  e = obj;
  return $eq(this.key_0, e.getKey()) && $eq($getItem(this.this$0.storage, this.key_0), e.getValue());
}
;
_.getKey = function getKey(){
  return this.key_0;
}
;
_.getValue = function getValue(){
  return $getItem(this.this$0.storage, this.key_0);
}
;
_.hashCode$ = function hashCode_5(){
  var value;
  value = $getItem(this.this$0.storage, this.key_0);
  return (this.key_0 == null?0:getHashCode_0(this.key_0)) ^ (value == null?0:getHashCode_0(value));
}
;
_.setValue = function setValue(value){
  var oldValue;
  return oldValue = $getItem(this.this$0.storage, this.key_0) , $setItem(this.this$0.storage, this.key_0, value) , oldValue;
}
;
_.key_0 = null;
_.this$0 = null;
function $next(this$static){
  if (this$static.index_0 < $getLength(this$static.this$0.storage.storage) - 1) {
    ++this$static.index_0;
    this$static.removed = false;
    return new StorageMap$StorageEntry_0(this$static.this$0, $key(this$static.this$0.storage, this$static.index_0));
  }
  throw new NoSuchElementException_0;
}

function StorageMap$StorageEntryIterator_0(this$0){
  this.this$0 = this$0;
}

defineSeed(277, 1, {}, StorageMap$StorageEntryIterator_0);
_.hasNext = function hasNext(){
  return this.index_0 < $getLength(this.this$0.storage.storage) - 1;
}
;
_.next_0 = function next_0(){
  return $next(this);
}
;
_.remove_2 = function remove_6(){
  if (this.index_0 >= 0 && this.index_0 < $getLength(this.this$0.storage.storage)) {
    if (this.removed) {
      throw new IllegalStateException_1('Cannot remove() Entry - already removed!');
    }
    $removeItem(this.this$0.storage, $key(this.this$0.storage, this.index_0));
    this.removed = true;
    --this.index_0;
  }
   else {
    throw new IllegalStateException_1('Cannot remove() Entry - index=' + this.index_0 + ', size=' + $getLength(this.this$0.storage.storage));
  }
}
;
_.index_0 = -1;
_.removed = false;
_.this$0 = null;
defineSeed(279, 116, makeCastMap([Q$Set]));
_.equals$ = function equals_6(o){
  var iter, other, otherItem;
  if (o === this) {
    return true;
  }
  if (!instanceOf(o, Q$Set)) {
    return false;
  }
  other = o;
  if (other.size_0() != this.size_0()) {
    return false;
  }
  for (iter = other.iterator(); iter.hasNext();) {
    otherItem = iter.next_0();
    if (!this.contains_0(otherItem)) {
      return false;
    }
  }
  return true;
}
;
_.hashCode$ = function hashCode_6(){
  var hashCode, iter, next;
  hashCode = 0;
  for (iter = this.iterator(); iter.hasNext();) {
    next = iter.next_0();
    if (next != null) {
      hashCode += hashCode__devirtual$(next);
      hashCode = ~~hashCode;
    }
  }
  return hashCode;
}
;
function StorageMap$StorageEntrySet_0(this$0){
  this.this$0 = this$0;
}

defineSeed(278, 279, makeCastMap([Q$Set]), StorageMap$StorageEntrySet_0);
_.contains_0 = function contains_2(o){
  var e, key;
  if (o == null || !instanceOf(o, Q$Map$Entry)) {
    return false;
  }
  e = o;
  key = e.getKey();
  return key != null && $containsKey(this.this$0, key) && $eq($get_0(this.this$0, key), e.getValue());
}
;
_.iterator = function iterator_1(){
  return new StorageMap$StorageEntryIterator_0(this.this$0);
}
;
_.remove = function remove_7(o){
  var e, key, value;
  if (o == null || !instanceOf(o, Q$Map$Entry)) {
    return false;
  }
  e = o;
  if (e.getKey() == null) {
    return false;
  }
  key = toString__devirtual$(e.getKey());
  value = $getItem(this.this$0.storage, key);
  if ($eq(value, e.getValue())) {
    return $remove_4(this.this$0, key) != null;
  }
  return false;
}
;
_.size_0 = function size_3(){
  return $getLength(this.this$0.storage.storage);
}
;
_.this$0 = null;
function $set(this$static, array, offset){
  this$static.set(array, offset);
}

function $set_0(this$static, array){
  this$static.set(array);
}

function create_2(buffer, byteOffset, length_0){
  return new Float32Array(buffer, byteOffset, length_0);
}

function create_3(buffer, byteOffset, length_0){
  return new Int16Array(buffer, byteOffset, length_0);
}

function create_4(buffer, byteOffset, length_0){
  return new Int32Array(buffer, byteOffset, length_0);
}

function create_5(buffer, byteOffset, length_0){
  return new Int8Array(buffer, byteOffset, length_0);
}

function createFloat32Array(array){
  return new Float32Array(array);
}

function createInt32Array(array){
  return new Int32Array(array);
}

function createUint16Array(array){
  return new Uint16Array(array);
}

function createUint8Array(array){
  return new Uint8Array(array);
}

function create_6(buffer, byteOffset, length_0){
  return new Uint16Array(buffer, byteOffset, length_0);
}

function create_7(buffer, byteOffset, length_0){
  return new Uint8Array(buffer, byteOffset, length_0);
}

function dispatchEvent_0(evt, elem, listener){
  var prevCurrentEvent;
  prevCurrentEvent = currentEvent;
  currentEvent = evt;
  elem == sCaptureElem && $eventGetTypeInt(evt.type) == 8192 && (sCaptureElem = null);
  listener.onBrowserEvent(evt);
  currentEvent = prevCurrentEvent;
}

var currentEvent = null, sCaptureElem = null;
function $onModuleLoad(){
  var allowedModes, currentMode, i;
  currentMode = $doc.compatMode;
  allowedModes = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['CSS1Compat']);
  for (i = 0; i < allowedModes.length; ++i) {
    if ($equals(allowedModes[i], currentMode)) {
      return;
    }
  }
  allowedModes.length == 1 && $equals('CSS1Compat', allowedModes[0]) && $equals('BackCompat', currentMode)?"GWT no longer supports Quirks Mode (document.compatMode=' BackCompat').<br>Make sure your application's host HTML page has a Standards Mode (document.compatMode=' CSS1Compat') doctype,<br>e.g. by using &lt;!doctype html&gt; at the start of your application's HTML page.<br><br>To continue using this unsupported rendering mode and risk layout problems, suppress this message by adding<br>the following line to your*.gwt.xml module file:<br>&nbsp;&nbsp;&lt;extend-configuration-property name=\"document.compatMode\" value=\"" + currentMode + '"/&gt;':"Your *.gwt.xml module configuration prohibits the use of the current doucment rendering mode (document.compatMode=' " + currentMode + "').<br>Modify your application's host HTML page doctype, or update your custom 'document.compatMode' configuration property settings.";
}

function addCloseHandler(handler){
  maybeInitializeCloseHandlers();
  return addHandler(TYPE_0?TYPE_0:(TYPE_0 = new GwtEvent$Type_0), handler);
}

function addHandler(type, handler){
  return $addHandler((!handlers_0 && (handlers_0 = new Window$WindowHandlers_0) , handlers_0), type, handler);
}

function alert_0(msg){
  $wnd.alert(msg);
}

function maybeInitializeCloseHandlers(){
  if (!closeHandlersInitialized) {
    $initWindowCloseHandler();
    closeHandlersInitialized = true;
  }
}

function onClosing(){
  var event_0;
  if (closeHandlersInitialized) {
    event_0 = new Window$ClosingEvent_0;
    !!handlers_0 && $fireEvent(handlers_0, event_0);
    return null;
  }
  return null;
}

var closeHandlersInitialized = false, handlers_0 = null;
function $clinit_Window$ClosingEvent(){
  $clinit_Window$ClosingEvent = nullMethod;
  TYPE_1 = new GwtEvent$Type_0;
}

function Window$ClosingEvent_0(){
  $clinit_Window$ClosingEvent();
}

defineSeed(294, 221, {}, Window$ClosingEvent_0);
_.dispatch = function dispatch_1(handler){
  null.nullMethod();
}
;
_.getAssociatedType = function getAssociatedType_1(){
  return TYPE_1;
}
;
var TYPE_1;
function ensureParameterMap(){
  var kv, kvPair, kvPair$array, kvPair$index, kvPair$max, qs, queryString, regexp;
  if (!paramMap) {
    paramMap = new HashMap_0;
    queryString = $wnd.location.search;
    if (queryString != null && queryString.length > 1) {
      qs = $substring(queryString, 1);
      for (kvPair$array = $split(qs, '&', 0) , kvPair$index = 0 , kvPair$max = kvPair$array.length; kvPair$index < kvPair$max; ++kvPair$index) {
        kvPair = kvPair$array[kvPair$index];
        kv = $split(kvPair, '=', 2);
        kv.length > 1?$put_2(paramMap, kv[0], (throwIfNull(kv[1]) , regexp = /\+/g , decodeURIComponent(kv[1].replace(regexp, '%20')))):$put_2(paramMap, kv[0], '');
      }
    }
  }
}

var paramMap = null;
function Window$WindowHandlers_0(){
  HandlerManager_0.call(this, null);
}

defineSeed(297, 230, makeCastMap([Q$HasHandlers]), Window$WindowHandlers_0);
function $eventGetTypeInt(eventType){
  switch (eventType) {
    case 'blur':
      return 4096;
    case 'change':
      return 1024;
    case 'click':
      return 1;
    case 'dblclick':
      return 2;
    case 'focus':
      return 2048;
    case 'keydown':
      return 128;
    case 'keypress':
      return 256;
    case 'keyup':
      return 512;
    case 'load':
      return 32768;
    case 'losecapture':
      return 8192;
    case 'mousedown':
      return 4;
    case 'mousemove':
      return 64;
    case 'mouseout':
      return 32;
    case 'mouseover':
      return 16;
    case 'mouseup':
      return 8;
    case 'scroll':
      return 16384;
    case 'error':
      return 65536;
    case 'DOMMouseScroll':
    case 'mousewheel':
      return 131072;
    case 'contextmenu':
      return 262144;
    case 'paste':
      return 524288;
    case 'touchstart':
      return 1048576;
    case 'touchmove':
      return 2097152;
    case 'touchend':
      return 4194304;
    case 'touchcancel':
      return 8388608;
    case 'gesturestart':
      return 16777216;
    case 'gesturechange':
      return 33554432;
    case 'gestureend':
      return 67108864;
    default:return -1;
  }
}

function $maybeInitializeEventSystem(){
  if (!eventSystemIsInitialized) {
    $initEventSystem();
    eventSystemIsInitialized = true;
  }
}

function $setEventListener(elem, listener){
  elem.__listener = listener;
}

function isMyListener(object){
  return !instanceOfJso(object) && instanceOf(object, Q$EventListener);
}

var eventSystemIsInitialized = false;
function $initEventSystem(){
  dispatchCapturedEvent = $entry(function(evt){
    return true;
  }
  );
  dispatchEvent_1 = $entry(function(evt){
    var listener, curElem = this;
    while (curElem && !(listener = curElem.__listener)) {
      curElem = curElem.parentNode;
    }
    curElem && curElem.nodeType != 1 && (curElem = null);
    listener && isMyListener(listener) && dispatchEvent_0(evt, curElem, listener);
  }
  );
  dispatchDragEvent = $entry(function(evt){
    evt.preventDefault();
    dispatchEvent_1.call(this, evt);
  }
  );
  dispatchUnhandledEvent = $entry(function(evt){
    this.__gwtLastUnhandledEvent = evt.type;
    dispatchEvent_1.call(this, evt);
  }
  );
  dispatchCapturedMouseEvent = $entry(function(evt){
    var dispatchCapturedEventFn = dispatchCapturedEvent;
    if (dispatchCapturedEventFn(evt)) {
      var cap = captureElem;
      if (cap && cap.__listener) {
        if (isMyListener(cap.__listener)) {
          dispatchEvent_0(evt, cap, cap.__listener);
          evt.stopPropagation();
        }
      }
    }
  }
  );
  $wnd.addEventListener('click', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('dblclick', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mousedown', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mouseup', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mousemove', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mouseover', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mouseout', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('mousewheel', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('keydown', dispatchCapturedEvent, true);
  $wnd.addEventListener('keyup', dispatchCapturedEvent, true);
  $wnd.addEventListener('keypress', dispatchCapturedEvent, true);
  $wnd.addEventListener('touchstart', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('touchmove', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('touchend', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('touchcancel', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('gesturestart', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('gesturechange', dispatchCapturedMouseEvent, true);
  $wnd.addEventListener('gestureend', dispatchCapturedMouseEvent, true);
}

function $sinkBitlessEvent_0(elem, eventTypeName){
  $maybeInitializeEventSystem();
  $sinkBitlessEventImpl(elem, eventTypeName);
}

function $sinkBitlessEventImpl(elem, eventTypeName){
  switch (eventTypeName) {
    case 'drag':
      elem.ondrag = dispatchEvent_1;
      break;
    case 'dragend':
      elem.ondragend = dispatchEvent_1;
      break;
    case 'dragenter':
      elem.ondragenter = dispatchDragEvent;
      break;
    case 'dragleave':
      elem.ondragleave = dispatchEvent_1;
      break;
    case 'dragover':
      elem.ondragover = dispatchDragEvent;
      break;
    case 'dragstart':
      elem.ondragstart = dispatchEvent_1;
      break;
    case 'drop':
      elem.ondrop = dispatchEvent_1;
      break;
    case 'canplaythrough':
    case 'ended':
    case 'progress':
      elem.removeEventListener(eventTypeName, dispatchEvent_1, false);
      elem.addEventListener(eventTypeName, dispatchEvent_1, false);
      break;
    default:throw 'Trying to sink unknown event type ' + eventTypeName;
  }
}

function $sinkEvents(elem, bits){
  $maybeInitializeEventSystem();
  $sinkEventsImpl(elem, bits);
}

function $sinkEventsImpl(elem, bits){
  var chMask = (elem.__eventBits || 0) ^ bits;
  elem.__eventBits = bits;
  if (!chMask)
    return;
  chMask & 1 && (elem.onclick = bits & 1?dispatchEvent_1:null);
  chMask & 2 && (elem.ondblclick = bits & 2?dispatchEvent_1:null);
  chMask & 4 && (elem.onmousedown = bits & 4?dispatchEvent_1:null);
  chMask & 8 && (elem.onmouseup = bits & 8?dispatchEvent_1:null);
  chMask & 16 && (elem.onmouseover = bits & 16?dispatchEvent_1:null);
  chMask & 32 && (elem.onmouseout = bits & 32?dispatchEvent_1:null);
  chMask & 64 && (elem.onmousemove = bits & 64?dispatchEvent_1:null);
  chMask & 128 && (elem.onkeydown = bits & 128?dispatchEvent_1:null);
  chMask & 256 && (elem.onkeypress = bits & 256?dispatchEvent_1:null);
  chMask & 512 && (elem.onkeyup = bits & 512?dispatchEvent_1:null);
  chMask & 1024 && (elem.onchange = bits & 1024?dispatchEvent_1:null);
  chMask & 2048 && (elem.onfocus = bits & 2048?dispatchEvent_1:null);
  chMask & 4096 && (elem.onblur = bits & 4096?dispatchEvent_1:null);
  chMask & 8192 && (elem.onlosecapture = bits & 8192?dispatchEvent_1:null);
  chMask & 16384 && (elem.onscroll = bits & 16384?dispatchEvent_1:null);
  chMask & 32768 && (elem.onload = bits & 32768?dispatchUnhandledEvent:null);
  chMask & 65536 && (elem.onerror = bits & 65536?dispatchEvent_1:null);
  chMask & 131072 && (elem.onmousewheel = bits & 131072?dispatchEvent_1:null);
  chMask & 262144 && (elem.oncontextmenu = bits & 262144?dispatchEvent_1:null);
  chMask & 524288 && (elem.onpaste = bits & 524288?dispatchEvent_1:null);
  chMask & 1048576 && (elem.ontouchstart = bits & 1048576?dispatchEvent_1:null);
  chMask & 2097152 && (elem.ontouchmove = bits & 2097152?dispatchEvent_1:null);
  chMask & 4194304 && (elem.ontouchend = bits & 4194304?dispatchEvent_1:null);
  chMask & 8388608 && (elem.ontouchcancel = bits & 8388608?dispatchEvent_1:null);
  chMask & 16777216 && (elem.ongesturestart = bits & 16777216?dispatchEvent_1:null);
  chMask & 33554432 && (elem.ongesturechange = bits & 33554432?dispatchEvent_1:null);
  chMask & 67108864 && (elem.ongestureend = bits & 67108864?dispatchEvent_1:null);
}

var captureElem = null, dispatchCapturedEvent = null, dispatchCapturedMouseEvent = null, dispatchDragEvent = null, dispatchEvent_1 = null, dispatchUnhandledEvent = null;
function $initWindowCloseHandler(){
  var oldOnBeforeUnload = $wnd.onbeforeunload;
  var oldOnUnload = $wnd.onunload;
  $wnd.onbeforeunload = function(evt){
    var ret, oldRet;
    try {
      ret = $entry(onClosing)();
    }
     finally {
      oldRet = oldOnBeforeUnload && oldOnBeforeUnload(evt);
    }
    if (ret != null) {
      return ret;
    }
    if (oldRet != null) {
      return oldRet;
    }
  }
  ;
  $wnd.onunload = $entry(function(evt){
    try {
      closeHandlersInitialized && fire((!handlers_0 && (handlers_0 = new Window$WindowHandlers_0) , handlers_0));
    }
     finally {
      oldOnUnload && oldOnUnload(evt);
      $wnd.onresize = null;
      $wnd.onscroll = null;
      $wnd.onbeforeunload = null;
      $wnd.onunload = null;
    }
  }
  );
}

defineSeed(303, 264, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.doAttachChildren = function doAttachChildren_0(){
  tryCommand(this, ($clinit_AttachDetachException() , attachCommand));
}
;
_.doDetachChildren = function doDetachChildren_0(){
  tryCommand(this, ($clinit_AttachDetachException() , detachCommand));
}
;
function $add_5(this$static, child, container){
  $removeFromParent(child);
  $add_7(this$static.children, child);
  $appendChild(container, ($clinit_PotentialElement() , $resolve(child.element)));
  $setParent(child, this$static);
}

function $remove_5(this$static, w){
  var elem, parent_0;
  if (w.parent_0 != this$static) {
    return false;
  }
  try {
    $setParent(w, null);
  }
   finally {
    elem = w.element;
    $removeChild((parent_0 = elem.parentNode , (!parent_0 || parent_0.nodeType != 1) && (parent_0 = null) , parent_0), elem);
    $remove_8(this$static.children, w);
  }
  return true;
}

defineSeed(302, 303, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.iterator = function iterator_2(){
  return new WidgetCollection$WidgetIterator_0(this.children);
}
;
_.remove_3 = function remove_8(w){
  return $remove_5(this, w);
}
;
function $add_6(this$static, w){
  $add_5(this$static, w, this$static.element);
}

function $remove_6(this$static, w){
  var removed;
  removed = $remove_5(this$static, w);
  removed && changeToStaticPositioning(w.element);
  return removed;
}

function changeToStaticPositioning(elem){
  elem.style['left'] = '';
  elem.style['top'] = '';
  elem.style['position'] = '';
}

defineSeed(301, 302, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
_.remove_3 = function remove_9(w){
  return $remove_6(this, w);
}
;
function $clinit_AttachDetachException(){
  $clinit_AttachDetachException = nullMethod;
  attachCommand = new AttachDetachException$1_0;
  detachCommand = new AttachDetachException$2_0;
}

function AttachDetachException_0(causes){
  UmbrellaException_2.call(this, causes);
}

--></script>
<script><!--
function tryCommand(hasWidgets, c){
  $clinit_AttachDetachException();
  var $e0, caught, e, w, w$iterator;
  caught = null;
  for (w$iterator = hasWidgets.iterator(); w$iterator.hasNext();) {
    w = w$iterator.next_0();
    try {
      c.execute_1(w);
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$Throwable)) {
        e = $e0;
        !caught && (caught = new HashSet_0);
        $add_8(caught, e);
      }
       else 
        throw $e0;
    }
  }
  if (caught) {
    throw new AttachDetachException_0(caught);
  }
}

defineSeed(304, 235, makeCastMap([Q$UmbrellaException, Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), AttachDetachException_0);
var attachCommand, detachCommand;
function AttachDetachException$1_0(){
}

defineSeed(305, 1, {}, AttachDetachException$1_0);
_.execute_1 = function execute_6(w){
  w.onAttach();
}
;
function AttachDetachException$2_0(){
}

defineSeed(306, 1, {}, AttachDetachException$2_0);
_.execute_1 = function execute_7(w){
  $onDetach(w);
}
;
function $clinit_PotentialElement(){
  $clinit_PotentialElement = nullMethod;
  declareShim();
}

function $resolve(this$static){
  return this$static.__gwt_resolve?this$static.__gwt_resolve():this$static;
}

function declareShim(){
  var shim = function(){
  }
  ;
  shim.prototype = {className:'', clientHeight:0, clientWidth:0, dir:'', getAttribute:function(name_0, value){
    return this[name_0];
  }
  , href:'', id:'', lang:'', nodeType:1, removeAttribute:function(name_0, value){
    this[name_0] = undefined;
  }
  , setAttribute:function(name_0, value){
    this[name_0] = value;
  }
  , src:'', style:{}, title:''};
  $wnd.GwtPotentialElementShim = shim;
}

function $clinit_RootPanel(){
  $clinit_RootPanel = nullMethod;
  maybeDetachCommand = new RootPanel$1_0;
  rootPanels = new HashMap_0;
  widgetsToDetach = new HashSet_0;
}

function RootPanel_0(elem){
  this.children = new WidgetCollection_0(this);
  this.element = elem;
  $onAttach(this);
}

function detachNow(widget){
  $clinit_RootPanel();
  try {
    $onDetach(widget);
  }
   finally {
    $remove_12(widgetsToDetach, widget);
  }
}

function detachWidgets(){
  $clinit_RootPanel();
  try {
    tryCommand(widgetsToDetach, maybeDetachCommand);
  }
   finally {
    $clearImpl(widgetsToDetach.map);
    $clearImpl(rootPanels);
  }
}

function get_2(){
  $clinit_RootPanel();
  var rp;
  rp = $get_4(rootPanels, null);
  if (rp) {
    return rp;
  }
  if (rootPanels.size == 0) {
    addCloseHandler(new RootPanel$2_0);
    ($clinit_LocaleInfo() , false) && setDirectionOnElement($doc);
  }
  rp = new RootPanel$DefaultRootPanel_0;
  $put_2(rootPanels, null, rp);
  $add_8(widgetsToDetach, rp);
  return rp;
}

function getBodyElement(){
  $clinit_RootPanel();
  return $doc.body;
}

defineSeed(308, 301, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]));
var maybeDetachCommand, rootPanels, widgetsToDetach;
function RootPanel$1_0(){
}

defineSeed(309, 1, {}, RootPanel$1_0);
_.execute_1 = function execute_8(w){
  w.attached && $onDetach(w);
}
;
function RootPanel$2_0(){
}

defineSeed(310, 1, {}, RootPanel$2_0);
function RootPanel$DefaultRootPanel_0(){
  RootPanel_0.call(this, getBodyElement());
}

defineSeed(311, 308, makeCastMap([Q$HasAttachHandlers, Q$HasHandlers, Q$EventListener, Q$HasVisibility, Q$IsWidget, Q$UIObject, Q$Widget]), RootPanel$DefaultRootPanel_0);
function $add_7(this$static, w){
  $insert(this$static, w, this$static.size);
}

function $indexOf_0(this$static, w){
  var i;
  for (i = 0; i < this$static.size; ++i) {
    if (this$static.array[i] == w) {
      return i;
    }
  }
  return -1;
}

function $insert(this$static, w, beforeIndex){
  var i, newArray;
  if (beforeIndex < 0 || beforeIndex > this$static.size) {
    throw new IndexOutOfBoundsException_0;
  }
  if (this$static.size == this$static.array.length) {
    newArray = initDim(_3Lcom_google_gwt_user_client_ui_Widget_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Widget, this$static.array.length * 2, 0);
    for (i = 0; i < this$static.array.length; ++i) {
      setCheck(newArray, i, this$static.array[i]);
    }
    this$static.array = newArray;
  }
  ++this$static.size;
  for (i = this$static.size - 1; i > beforeIndex; --i) {
    setCheck(this$static.array, i, this$static.array[i - 1]);
  }
  setCheck(this$static.array, beforeIndex, w);
}

function $remove_7(this$static, index){
  var i;
  if (index < 0 || index >= this$static.size) {
    throw new IndexOutOfBoundsException_0;
  }
  --this$static.size;
  for (i = index; i < this$static.size; ++i) {
    setCheck(this$static.array, i, this$static.array[i + 1]);
  }
  setCheck(this$static.array, this$static.size, null);
}

function $remove_8(this$static, w){
  var index;
  index = $indexOf_0(this$static, w);
  if (index == -1) {
    throw new NoSuchElementException_0;
  }
  $remove_7(this$static, index);
}

function WidgetCollection_0(parent_0){
  this.parent_0 = parent_0;
  this.array = initDim(_3Lcom_google_gwt_user_client_ui_Widget_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Widget, 4, 0);
}

defineSeed(312, 1, {}, WidgetCollection_0);
_.iterator = function iterator_3(){
  return new WidgetCollection$WidgetIterator_0(this);
}
;
_.array = null;
_.parent_0 = null;
_.size = 0;
function $next_0(this$static){
  if (this$static.index_0 >= this$static.this$0.size) {
    throw new NoSuchElementException_0;
  }
  return this$static.this$0.array[++this$static.index_0];
}

function WidgetCollection$WidgetIterator_0(this$0){
  this.this$0 = this$0;
}

defineSeed(313, 1, {}, WidgetCollection$WidgetIterator_0);
_.hasNext = function hasNext_0(){
  return this.index_0 < this.this$0.size - 1;
}
;
_.next_0 = function next_1(){
  return $next_0(this);
}
;
_.remove_2 = function remove_10(){
  if (this.index_0 < 0 || this.index_0 >= this.this$0.size) {
    throw new IllegalStateException_0;
  }
  this.this$0.parent_0.remove_3(this.this$0.array[this.index_0--]);
}
;
_.index_0 = -1;
_.this$0 = null;
function toJsArray(data){
  var i, jsan, len;
  jsan = [];
  len = data.length;
  for (i = len - 1; i >= 0; --i) {
    jsan[i] = data[i];
  }
  return jsan;
}

function toJsArray_0(data){
  var i, jsan, len;
  jsan = [];
  len = data.length;
  for (i = len - 1; i >= 0; --i) {
    jsan[i] = data[i];
  }
  return jsan;
}

function $attachShader(this$static, program, shader){
  this$static.attachShader(program, shader);
}

function $bindBuffer(this$static, target, buffer){
  this$static.bindBuffer(target, buffer);
}

function $bindFramebuffer(this$static, target, framebuffer){
  this$static.bindFramebuffer(target, framebuffer);
}

function $bindTexture(this$static, target, texture){
  this$static.bindTexture(target, texture);
}

function $bufferData(this$static, target, data, usage){
  this$static.bufferData(target, data, usage);
}

function $clear_0(this$static, mask){
  this$static.clear(mask);
}

function $clearColor(this$static, red, green, blue, alpha){
  this$static.clearColor(red, green, blue, alpha);
}

function $compileShader(this$static, shader){
  this$static.compileShader(shader);
}

function $createShader(this$static, type){
  return this$static.createShader(type);
}

function $deleteBuffer(this$static, buffer){
  this$static.deleteBuffer(buffer);
}

function $deleteFramebuffer(this$static, framebuffer){
  this$static.deleteFramebuffer(framebuffer);
}

function $deleteProgram(this$static, program){
  this$static.deleteProgram(program);
}

function $deleteRenderbuffer(this$static, renderbuffer){
  this$static.deleteRenderbuffer(renderbuffer);
}

function $deleteShader(this$static, shader){
  this$static.deleteShader(shader);
}

function $deleteTexture(this$static, texture){
  this$static.deleteTexture(texture);
}

function $disableVertexAttribArray(this$static, index){
  this$static.disableVertexAttribArray(index);
}

function $drawElements(this$static, mode, count, type, offset){
  this$static.drawElements(mode, count, type, offset);
}

function $enableVertexAttribArray(this$static, index){
  this$static.enableVertexAttribArray(index);
}

function $framebufferTexture2D(this$static, target, attachment, textarget, texture, level){
  this$static.framebufferTexture2D(target, attachment, textarget, texture, level);
}

function $getAttribLocation(this$static, program, name_0){
  return this$static.getAttribLocation(program, name_0);
}

function $getProgramInfoLog(this$static, program){
  return this$static.getProgramInfoLog(program);
}

function $getProgramParameterb(this$static, program, pname){
  return this$static.getProgramParameter(program, pname);
}

function $getShaderInfoLog(this$static, shader){
  return this$static.getShaderInfoLog(shader);
}

function $getShaderParameterb(this$static, shader, pname){
  return this$static.getShaderParameter(shader, pname);
}

function $getUniformLocation(this$static, program, name_0){
  return this$static.getUniformLocation(program, name_0);
}

function $linkProgram(this$static, program){
  this$static.linkProgram(program);
}

function $readPixels(this$static, x, y, width, height, format, type, pixels){
  this$static.readPixels(x, y, width, height, format, type, pixels);
}

function $shaderSource(this$static, shader, source){
  this$static.shaderSource(shader, source);
}

function $texImage2D(this$static, target, level, internalformat, width, height, border, format, type, pixels){
  this$static.texImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}

function $texImage2D_0(this$static, target, level, internalformat, format, type, image){
  this$static.texImage2D(target, level, internalformat, format, type, image);
}

function $texParameteri(this$static, target, pname, param){
  this$static.texParameteri(target, pname, param);
}

function $uniform1i(this$static, location_0, x){
  this$static.uniform1i(location_0, x);
}

function $uniform2f(this$static, location_0, x, y){
  this$static.uniform2f(location_0, x, y);
}

function $uniform4fv(this$static, location_0, v){
  this$static.uniform4fv(location_0, v);
}

function $useProgram(this$static, program){
  this$static.useProgram(program);
}

function $vertexAttribPointer(this$static, indx, size, type, normalized, stride, offset){
  this$static.vertexAttribPointer(indx, size, type, normalized, stride, offset);
}

function $viewport(this$static, x, y, width, height){
  this$static.viewport(x, y, width, height);
}

function getContext(canvas, attributes){
  var names = ['experimental-webgl', 'webgl', 'moz-webgl', 'webkit-webgl', 'webkit-3d'];
  for (var i = 0; i < names.length; i++) {
    try {
      var ctx = canvas.getContext(names[i], attributes);
      if (ctx != null) {
        if ($wnd.WebGLDebugUtils) {
          $wnd.console && $wnd.console.log && console.log('WebGL debugging enabled');
          return $wnd.WebGLDebugUtils.makeDebugContext(ctx);
        }
        return ctx;
      }
    }
     catch (e) {
    }
  }
  return null;
}

function $setOnReadyStateChange(this$static, handler){
  var _this = this$static;
  this$static.onreadystatechange = $entry(function(){
    handler.onReadyStateChange(_this);
  }
  );
}

function create_8(){
  var xhr;
  if ($wnd.XMLHttpRequest) {
    xhr = new $wnd.XMLHttpRequest;
  }
   else {
    try {
      xhr = new $wnd.ActiveXObject('MSXML2.XMLHTTP.3.0');
    }
     catch (e) {
      xhr = new $wnd.ActiveXObject('Microsoft.XMLHTTP');
    }
  }
  return xhr;
}

function $removeHandler(this$static){
  $doRemove_1(this$static.this$0, this$static.val$type, this$static.val$source, this$static.val$handler);
}

function SimpleEventBus$1_0(this$0, val$type, val$handler){
  this.this$0 = this$0;
  this.val$type = val$type;
  this.val$source = null;
  this.val$handler = val$handler;
}

defineSeed(326, 1, {}, SimpleEventBus$1_0);
_.this$0 = null;
_.val$handler = null;
_.val$source = null;
_.val$type = null;
function SimpleEventBus$2_0(this$0, val$type, val$handler){
  this.this$0 = this$0;
  this.val$type = val$type;
  this.val$source = null;
  this.val$handler = val$handler;
}

defineSeed(327, 1, {}, SimpleEventBus$2_0);
_.execute = function execute_9(){
  $doAddNow(this.this$0, this.val$type, this.val$source, this.val$handler);
}
;
_.this$0 = null;
_.val$handler = null;
_.val$source = null;
_.val$type = null;
function SimpleEventBus$3_0(this$0, val$type, val$source, val$handler){
  this.this$0 = this$0;
  this.val$type = val$type;
  this.val$source = val$source;
  this.val$handler = val$handler;
}

defineSeed(328, 1, {}, SimpleEventBus$3_0);
_.execute = function execute_10(){
  $doRemoveNow(this.this$0, this.val$type, this.val$source, this.val$handler);
}
;
_.this$0 = null;
_.val$handler = null;
_.val$source = null;
_.val$type = null;
function ArithmeticException_0(){
  RuntimeException_0.call(this, 'divide by zero');
}

defineSeed(329, 144, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), ArithmeticException_0);
function ArrayStoreException_0(){
  this.fillInStackTrace();
}

function ArrayStoreException_1(message){
  RuntimeException_0.call(this, message);
}

defineSeed(330, 144, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), ArrayStoreException_0, ArrayStoreException_1);
function digit(c){
  if (c >= 48 && c < 58) {
    return c - 48;
  }
  if (c >= 97 && c < 97) {
    return c - 97 + 10;
  }
  if (c >= 65 && c < 65) {
    return c - 65 + 10;
  }
  return -1;
}

function Class_0(){
}

function asString(number){
  return typeof number == 'number'?'S' + (number < 0?-number:number):number;
}

function createForArray(seedId, componentType){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(seedId != 0?-seedId:0)?asString(seedId != 0?-seedId:0):'' + getHashCode(clazz));
  isInstantiable(seedId != 0?-seedId:0) && setClassLiteral(seedId != 0?-seedId:0, clazz);
  clazz.modifiers = 4;
  clazz.componentType = componentType;
  return clazz;
}

function createForClass(seedId){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(seedId)?asString(seedId):'' + getHashCode(clazz));
  isInstantiable(seedId) && setClassLiteral(seedId, clazz);
  return clazz;
}

function createForEnum(seedId, enumConstantsFunc){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(seedId)?asString(seedId):'' + getHashCode(clazz));
  isInstantiable(seedId) && setClassLiteral(seedId, clazz);
  clazz.modifiers = enumConstantsFunc?8:0;
  return clazz;
}

function createForInterface(){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(0)?asString(0):'' + getHashCode(clazz));
  isInstantiable(0) && setClassLiteral(0, clazz);
  clazz.modifiers = 2;
  return clazz;
}

function createForPrimitive(seedId){
  var clazz;
  clazz = new Class_0;
  clazz.typeName = 'Class$' + (isInstantiableOrPrimitive(seedId)?asString(seedId):'' + getHashCode(clazz));
  isInstantiable(seedId) && setClassLiteral(seedId, clazz);
  clazz.modifiers = 1;
  return clazz;
}

function getSeedFunction(clazz){
  var func = seedTable[clazz.seedId];
  clazz = null;
  return func;
}

function isInstantiable(seedId){
  return typeof seedId == 'number' && seedId > 0;
}

function isInstantiableOrPrimitive(seedId){
  return seedId != null && seedId != 0;
}

function setClassLiteral(seedId, clazz){
  var proto;
  clazz.seedId = seedId;
  if (seedId == 2) {
    proto = String.prototype;
  }
   else {
    if (seedId > 0) {
      var seed = getSeedFunction(clazz);
      if (seed) {
        proto = seed.prototype;
      }
       else {
        seed = seedTable[seedId] = function(){
        }
        ;
        seed.___clazz$ = clazz;
        return;
      }
    }
     else {
      return;
    }
  }
  proto.___clazz$ = clazz;
}

defineSeed(332, 1, {}, Class_0);
_.toString$ = function toString_14(){
  return ((this.modifiers & 2) != 0?'interface ':(this.modifiers & 1) != 0?'':'class ') + this.typeName;
}
;
_.componentType = null;
_.modifiers = 0;
_.seedId = 0;
_.typeName = null;
function __parseAndValidateDouble(s){
  var toReturn;
  toReturn = __parseDouble(s);
  if (isNaN(toReturn)) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
  return toReturn;
}

function __parseAndValidateInt(s){
  var i, length_0, startIndex, toReturn;
  if (s == null) {
    throw new NumberFormatException_0('null');
  }
  length_0 = s.length;
  startIndex = length_0 > 0 && s.charCodeAt(0) == 45?1:0;
  for (i = startIndex; i < length_0; ++i) {
    if (digit(s.charCodeAt(i)) == -1) {
      throw new NumberFormatException_0('For input string: "' + s + '"');
    }
  }
  toReturn = parseInt(s, 10);
  if (isNaN(toReturn)) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
   else if (toReturn < -2147483648 || toReturn > 2147483647) {
    throw new NumberFormatException_0('For input string: "' + s + '"');
  }
  return toReturn;
}

function __parseDouble(str){
  var floatRegex = floatRegex_0;
  !floatRegex && (floatRegex = floatRegex_0 = /^\s*[+-]?((\d+\.?\d*)|(\.\d+))([eE][+-]?\d+)?[dDfF]?\s*$/i);
  if (floatRegex.test(str)) {
    return parseFloat(str);
  }
   else {
    return Number.NaN;
  }
}

defineSeed(334, 1, makeCastMap([Q$Serializable, Q$Number]));
var floatRegex_0 = null;
function $clinit_Double(){
  $clinit_Double = nullMethod;
  powers = initValues(_3D_classLit, makeCastMap([Q$Serializable]), -1, [1.3407807929942597E154, 1.157920892373162E77, 3.4028236692093846E38, 1.8446744073709552E19, 4294967296, 65536, 256, 16, 4, 2]);
  invPowers = initValues(_3D_classLit, makeCastMap([Q$Serializable]), -1, [7.458340731200207E-155, 8.636168555094445E-78, 2.9387358770557188E-39, 5.421010862427522E-20, 2.3283064365386963E-10, 1.52587890625E-5, 0.00390625, 0.0625, 0.25, 0.5]);
}

function doubleToLongBits(value){
  $clinit_Double();
  var bit, exp, i, ihi, ilo, negative;
  if (isNaN_0(value)) {
    return P7ff8000000000000_longLit;
  }
  negative = false;
  if (value == 0) {
    return 1 / value == -Infinity?N8000000000000000_longLit:P0_longLit;
  }
  if (value < 0) {
    negative = true;
    value = -value;
  }
  if (!isFinite(value)) {
    return negative?N10000000000000_longLit:P7ff0000000000000_longLit;
  }
  exp = 0;
  if (value < 1) {
    bit = 512;
    for (i = 0; i < 10; ++i , bit >>= 1) {
      if (value < invPowers[i] && exp - bit >= -1023) {
        value *= powers[i];
        exp -= bit;
      }
    }
    if (value < 1 && exp - 1 >= -1023) {
      value *= 2;
      --exp;
    }
  }
   else if (value >= 2) {
    bit = 512;
    for (i = 0; i < 10; ++i , bit >>= 1) {
      if (value >= powers[i]) {
        value *= invPowers[i];
        exp += bit;
      }
    }
  }
  exp > -1023?(value -= 1):(value *= 0.5);
  ihi = fromDouble(value * 1048576);
  value -= toDouble(ihi) * 9.5367431640625E-7;
  ilo = fromDouble(value * 4503599627370496);
  ihi = or(ihi, fromInt(exp + 1023 << 20));
  negative && (ihi = or(ihi, P80000000_longLit));
  return or(shl(ihi, 32), ilo);
}

function isNaN_0(x){
  $clinit_Double();
  return isNaN(x);
}

var invPowers, powers;
function Error_1(cause){
  Throwable_1.call(this, cause);
}

defineSeed(335, 97, makeCastMap([Q$Serializable, Q$Throwable]), Error_1);
function floatToIntBits(value){
  var bits, exp, l_0, mantissa, negative;
  if (isNaN(value)) {
    return 2143289344;
  }
  if (value == 0) {
    return 1 / value == -Infinity?-2147483648:0;
  }
  negative = false;
  if (value < 0) {
    negative = true;
    value = -value;
  }
  if (!isFinite(value)) {
    return negative?-8388608:2139095040;
  }
  l_0 = doubleToLongBits(value);
  exp = toInt(sub(and(shr(l_0, 52), P7ff_longLit), P3ff_longLit));
  mantissa = toInt(shr(and(l_0, Pfffffffffffff_longLit), 29));
  if (exp <= -127) {
    mantissa = ~~(8388608 | mantissa) >> -127 - exp + 1;
    exp = -127;
  }
  bits = negative?P80000000_longLit:P0_longLit;
  bits = or(bits, fromInt(exp + 127 << 23));
  bits = or(bits, fromInt(mantissa));
  return toInt(bits);
}

function parseFloat_0(s){
  var doubleValue;
  doubleValue = __parseAndValidateDouble(s);
  if (doubleValue > 3.4028234663852886E38) {
    return Infinity;
  }
   else if (doubleValue < -3.4028234663852886E38) {
    return -Infinity;
  }
  return doubleValue;
}

function IllegalArgumentException_0(){
  this.fillInStackTrace();
}

function IllegalArgumentException_1(message){
  RuntimeException_0.call(this, message);
}

defineSeed(337, 144, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), IllegalArgumentException_0, IllegalArgumentException_1);
function IllegalStateException_0(){
  this.fillInStackTrace();
}

function IllegalStateException_1(s){
  RuntimeException_0.call(this, s);
}

defineSeed(338, 144, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), IllegalStateException_0, IllegalStateException_1);
function IndexOutOfBoundsException_0(){
  this.fillInStackTrace();
}

function IndexOutOfBoundsException_1(message){
  RuntimeException_0.call(this, message);
}

defineSeed(339, 144, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), IndexOutOfBoundsException_0, IndexOutOfBoundsException_1);
function Integer_0(value){
  this.value_0 = value;
}

function numberOfLeadingZeros_0(i){
  var m_0, n, y;
  if (i < 0) {
    return 0;
  }
   else if (i == 0) {
    return 32;
  }
   else {
    y = -(~~i >> 16);
    m_0 = ~~y >> 16 & 16;
    n = 16 - m_0;
    i = ~~i >> m_0;
    y = i - 256;
    m_0 = ~~y >> 16 & 8;
    n += m_0;
    i <<= m_0;
    y = i - 4096;
    m_0 = ~~y >> 16 & 4;
    n += m_0;
    i <<= m_0;
    y = i - 16384;
    m_0 = ~~y >> 16 & 2;
    n += m_0;
    i <<= m_0;
    y = ~~i >> 14;
    m_0 = y & ~(~~y >> 1);
    return n + 2 - m_0;
  }
}

function numberOfTrailingZeros(i){
  var r, rtn;
  if (i == 0) {
    return 32;
  }
   else {
    rtn = 0;
    for (r = 1; (r & i) == 0; r <<= 1) {
      ++rtn;
    }
    return rtn;
  }
}

function toPowerOfTwoString(value){
  var buf, digits, pos;
  buf = initDim(_3C_classLit, makeCastMap([Q$Serializable]), -1, 8, 1);
  digits = ($clinit_Number$__Digits() , digits_0);
  pos = 7;
  if (value >= 0) {
    while (value > 15) {
      buf[pos--] = digits[value & 15];
      value >>= 4;
    }
  }
   else {
    while (pos > 0) {
      buf[pos--] = digits[value & 15];
      value >>= 4;
    }
  }
  buf[pos] = digits[value & 15];
  return __valueOf(buf, pos, 8);
}

function valueOf(i){
  var rebase, result;
  if (i > -129 && i < 128) {
    rebase = i + 128;
    result = ($clinit_Integer$BoxedValues() , boxedValues_0)[rebase];
    !result && (result = boxedValues_0[rebase] = new Integer_0(i));
    return result;
  }
  return new Integer_0(i);
}

defineSeed(340, 334, makeCastMap([Q$Serializable, Q$Comparable, Q$Integer, Q$Number]), Integer_0);
_.compareTo$ = function compareTo_0(b){
  return this.value_0 < b.value_0?-1:this.value_0 > b.value_0?1:0;
}
;
_.equals$ = function equals_7(o){
  return instanceOf(o, Q$Integer) && o.value_0 == this.value_0;
}
;
_.hashCode$ = function hashCode_7(){
  return this.value_0;
}
;
_.toString$ = function toString_15(){
  return '' + this.value_0;
}
;
_.value_0 = 0;
function $clinit_Integer$BoxedValues(){
  $clinit_Integer$BoxedValues = nullMethod;
  boxedValues_0 = initDim(_3Ljava_lang_Integer_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Integer, 256, 0);
}

var boxedValues_0;
function signum(i){
  return eq(i, P0_longLit)?0:lt(i, P0_longLit)?-1:1;
}

function abs(x){
  return x <= 0?0 - x:x;
}

function ceil(x){
  return Math.ceil(x);
}

function floor(x){
  return Math.floor(x);
}

function max(x, y){
  return x > y?x:y;
}

function max_0(x, y){
  return x > y?x:y;
}

function round(x){
  return Math.round(x);
}

function sqrt(x){
  return Math.sqrt(x);
}

function NullPointerException_0(){
  this.fillInStackTrace();
}

function NullPointerException_1(message){
  RuntimeException_0.call(this, message);
}

defineSeed(344, 144, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), NullPointerException_0, NullPointerException_1);
function $clinit_Number$__Digits(){
  $clinit_Number$__Digits = nullMethod;
  digits_0 = initValues(_3C_classLit, makeCastMap([Q$Serializable]), -1, [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]);
}

var digits_0;
function NumberFormatException_0(message){
  IllegalArgumentException_1.call(this, message);
}

defineSeed(346, 337, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), NumberFormatException_0);
function StackTraceElement_0(className, methodName, fileName, lineNumber){
  this.className = className;
  this.methodName = methodName;
  this.fileName = fileName;
  this.lineNumber = lineNumber;
}

defineSeed(347, 1, makeCastMap([Q$Serializable, Q$StackTraceElement]), StackTraceElement_0);
_.toString$ = function toString_16(){
  return this.className + '.' + this.methodName + '(' + (this.fileName != null?this.fileName:'Unknown Source') + (this.lineNumber >= 0?':' + this.lineNumber:'') + ')';
}
;
_.className = null;
_.fileName = null;
_.lineNumber = 0;
_.methodName = null;
function $charAt(this$static, index){
  return this$static.charCodeAt(index);
}

function $equals(this$static, other){
  if (!instanceOf(other, Q$String)) {
    return false;
  }
  return String(this$static) == other;
}

function $indexOf_1(this$static, str){
  return this$static.indexOf(str);
}

function $lastIndexOf(this$static, str){
  return this$static.lastIndexOf(str);
}

function $lastIndexOf_0(this$static, str, start){
  return this$static.lastIndexOf(str, start);
}

function $replace_0(this$static, from, to){
  var regex;
  if (from < 256) {
    regex = toPowerOfTwoString(from);
    regex = '\\x' + '00'.substring(regex.length) + regex;
  }
   else {
    regex = String.fromCharCode(from);
  }
  return this$static.replace(RegExp(regex, 'g'), String.fromCharCode(to));
}

function $replace_1(this$static, from, to){
  var regex, replacement;
  regex = $replaceAll(from, '([/\\\\\\.\\*\\+\\?\\|\\(\\)\\[\\]\\{\\}$^])', '\\\\$1');
  replacement = $replaceAll($replaceAll(to, '\\\\', '\\\\\\\\'), '\\$', '\\\\$');
  return $replaceAll(this$static, regex, replacement);
}

function $replaceAll(this$static, regex, replace){
  replace = __translateReplaceString(replace);
  return this$static.replace(RegExp(regex, 'g'), replace);
}

function $replaceFirst(this$static, regex, replace){
  replace = __translateReplaceString(replace);
  return this$static.replace(RegExp(regex), replace);
}

function $split(this$static, regex, maxMatch){
  var compiled = new RegExp(regex, 'g');
  var out = [];
  var count = 0;
  var trail = this$static;
  var lastTrail = null;
  while (true) {
    var matchObj = compiled.exec(trail);
    if (matchObj == null || trail == '' || count == maxMatch - 1 && maxMatch > 0) {
      out[count] = trail;
      break;
    }
     else {
      out[count] = trail.substring(0, matchObj.index);
      trail = trail.substring(matchObj.index + matchObj[0].length, trail.length);
      compiled.lastIndex = 0;
      if (lastTrail == trail) {
        out[count] = trail.substring(0, 1);
        trail = trail.substring(1);
      }
      lastTrail = trail;
      count++;
    }
  }
  if (maxMatch == 0 && this$static.length > 0) {
    var lastNonEmpty = out.length;
    while (lastNonEmpty > 0 && out[lastNonEmpty - 1] == '') {
      --lastNonEmpty;
    }
    lastNonEmpty < out.length && out.splice(lastNonEmpty, out.length - lastNonEmpty);
  }
  var jr = __createArray(out.length);
  for (var i = 0; i < out.length; ++i) {
    jr[i] = out[i];
  }
  return jr;
}

function $substring(this$static, beginIndex){
  return this$static.substr(beginIndex, this$static.length - beginIndex);
}

function $substring_0(this$static, beginIndex, endIndex){
  return this$static.substr(beginIndex, endIndex - beginIndex);
}

function $trim(this$static){
  if (this$static.length == 0 || this$static[0] > ' ' && this$static[this$static.length - 1] > ' ') {
    return this$static;
  }
  var r1 = this$static.replace(/^(\s*)/, '');
  var r2 = r1.replace(/\s*$/, '');
  return r2;
}

function __createArray(numElements){
  return initDim(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, numElements, 0);
}

function __translateReplaceString(replaceStr){
  var pos;
  pos = 0;
  while (0 <= (pos = replaceStr.indexOf('\\', pos))) {
    replaceStr.charCodeAt(pos + 1) == 36?(replaceStr = replaceStr.substr(0, pos - 0) + '$' + $substring(replaceStr, ++pos)):(replaceStr = replaceStr.substr(0, pos - 0) + $substring(replaceStr, ++pos));
  }
  return replaceStr;
}

function __valueOf(x, start, end){
  x = x.slice(start, end);
  return String.fromCharCode.apply(null, x);
}

function compareTo_2(thisStr, otherStr){
  thisStr = String(thisStr);
  if (thisStr == otherStr) {
    return 0;
  }
  return thisStr < otherStr?-1:1;
}

function fromCodePoint(codePoint){
  var hiSurrogate, loSurrogate;
  if (codePoint >= 65536) {
    hiSurrogate = 55296 + (~~(codePoint - 65536) >> 10 & 1023) & 65535;
    loSurrogate = 56320 + (codePoint - 65536 & 1023) & 65535;
    return String.fromCharCode(hiSurrogate) + String.fromCharCode(loSurrogate);
  }
   else {
    return String.fromCharCode(codePoint & 65535);
  }
}

function valueOf_0(x){
  return String.fromCharCode(x);
}

function valueOf_1(x){
  return String.fromCharCode.apply(null, x);
}

_ = String.prototype;
_.castableTypeMap$ = makeCastMap([Q$String, Q$Serializable, Q$CharSequence, Q$Comparable]);
_.compareTo$ = function compareTo_1(other){
  return compareTo_2(this, other);
}
;
_.equals$ = function equals_8(other){
  return $equals(this, other);
}
;
_.hashCode$ = function hashCode_8(){
  return getHashCode_0(this);
}
;
_.toString$ = _.toString;
--></script>
<script><!--
function $clinit_String$HashCache(){
  $clinit_String$HashCache = nullMethod;
  back_0 = {};
  front = {};
}

function compute(str){
  var hashCode, i, n, nBatch;
  hashCode = 0;
  n = str.length;
  nBatch = n - 4;
  i = 0;
  while (i < nBatch) {
    hashCode = str.charCodeAt(i + 3) + 31 * (str.charCodeAt(i + 2) + 31 * (str.charCodeAt(i + 1) + 31 * (str.charCodeAt(i) + 31 * hashCode))) | 0;
    i += 4;
  }
  while (i < n) {
    hashCode = hashCode * 31 + $charAt(str, i++);
  }
  return hashCode | 0;
}

function getHashCode_0(str){
  $clinit_String$HashCache();
  var key = ':' + str;
  var result = front[key];
  if (result != null) {
    return result;
  }
  result = back_0[key];
  result == null && (result = compute(str));
  increment_0();
  return front[key] = result;
}

function increment_0(){
  if (count_0 == 256) {
    back_0 = front;
    front = {};
    count_0 = 0;
  }
  ++count_0;
}

var back_0, count_0 = 0, front;
function $$init_0(this$static){
  this$static.impl = new StringBufferImplAppend_0;
}

function $append_4(this$static, x){
  $append_1(this$static.impl, x);
  return this$static;
}

function $append_5(this$static, x){
  $append_3(this$static.impl, x);
  return this$static;
}

function $append_6(this$static, x){
  $appendNonNull(this$static.impl, valueOf_1(x));
  return this$static;
}

function StringBuffer_0(){
  $$init_0(this);
}

function StringBuffer_1(){
  $$init_0(this);
}

defineSeed(349, 1, makeCastMap([Q$CharSequence]), StringBuffer_0, StringBuffer_1);
_.toString$ = function toString_17(){
  return this.impl.string;
}
;
function $$init_1(this$static){
  this$static.impl = new StringBufferImplAppend_0;
}

function $append_7(this$static, x){
  $appendNonNull(this$static.impl, String.fromCharCode(x));
  return this$static;
}

function $append_8(this$static, x){
  $append(this$static.impl, x);
  return this$static;
}

function $append_9(this$static, x){
  $append_0(this$static.impl, x);
  return this$static;
}

function $append_10(this$static, x){
  $append_1(this$static.impl, x);
  return this$static;
}

function $append_11(this$static, x){
  $append_2(this$static.impl, x);
  return this$static;
}

function $append_12(this$static, x){
  $append_3(this$static.impl, x);
  return this$static;
}

function $append_13(this$static, x){
  $appendNonNull(this$static.impl, valueOf_1(x));
  return this$static;
}

function $charAt_0(this$static, index){
  return $charAt(this$static.impl.string, index);
}

function $insert_0(this$static, x){
  return $replace(this$static.impl, 0, 0, x) , this$static;
}

function $setLength(this$static, newLength){
  var oldLength;
  oldLength = this$static.impl.string.length;
  newLength < oldLength?($replace(this$static.impl, newLength, oldLength, '') , this$static):newLength > oldLength && $append_13(this$static, initDim(_3C_classLit, makeCastMap([Q$Serializable]), -1, newLength - oldLength, 1));
}

function StringBuilder_0(){
  $$init_1(this);
}

function StringBuilder_1(s){
  $$init_1(this);
  $append_3(this.impl, s);
}

defineSeed(350, 1, makeCastMap([Q$CharSequence]), StringBuilder_0, StringBuilder_1);
_.toString$ = function toString_18(){
  return this.impl.string;
}
;
function arraycopy(src, srcOfs, dest, destOfs, len){
  var destArray, destComp, destEnd, destType, destlen, srcArray, srcComp, srcType, srclen;
  if (src == null || dest == null) {
    throw new NullPointerException_0;
  }
  srcType = getClass__devirtual$(src);
  destType = getClass__devirtual$(dest);
  if ((srcType.modifiers & 4) == 0 || (destType.modifiers & 4) == 0) {
    throw new ArrayStoreException_1('Must be array types');
  }
  srcComp = srcType.componentType;
  destComp = destType.componentType;
  if (!((srcComp.modifiers & 1) != 0?srcComp == destComp:(destComp.modifiers & 1) == 0)) {
    throw new ArrayStoreException_1('Array types must match');
  }
  srclen = src.length;
  destlen = dest.length;
  if (srcOfs < 0 || destOfs < 0 || len < 0 || srcOfs + len > srclen || destOfs + len > destlen) {
    throw new IndexOutOfBoundsException_0;
  }
  if (((srcComp.modifiers & 1) == 0 || (srcComp.modifiers & 4) != 0) && srcType != destType) {
    srcArray = src;
    destArray = dest;
    if (maskUndefined(src) === maskUndefined(dest) && srcOfs < destOfs) {
      srcOfs += len;
      for (destEnd = destOfs + len; destEnd-- > destOfs;) {
        setCheck(destArray, destEnd, srcArray[--srcOfs]);
      }
    }
     else {
      for (destEnd = destOfs + len; destOfs < destEnd;) {
        setCheck(destArray, destOfs++, srcArray[srcOfs++]);
      }
    }
  }
   else {
    Array.prototype.splice.apply(dest, [destOfs, len].concat(src.slice(srcOfs, srcOfs + len)));
  }
}

function UnsupportedOperationException_0(){
  this.fillInStackTrace();
}

function UnsupportedOperationException_1(message){
  RuntimeException_0.call(this, message);
}

defineSeed(352, 144, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), UnsupportedOperationException_0, UnsupportedOperationException_1);
function $clear_1(this$static){
  this$static.position_0 = 0;
  this$static.mark = -1;
  this$static.limit = this$static.capacity;
  return this$static;
}

function $position(this$static){
  if (0 > this$static.limit) {
    throw new IllegalArgumentException_0;
  }
  this$static.position_0 = 0;
  this$static.mark != -1 && this$static.mark > this$static.position_0 && (this$static.mark = -1);
  return this$static;
}

function Buffer_0(capacity){
  if (capacity < 0) {
    throw new IllegalArgumentException_0;
  }
  this.capacity = this.limit = capacity;
}

defineSeed(353, 1, {});
_.capacity = 0;
_.limit = 0;
_.mark = -1;
_.position_0 = 0;
function BufferOverflowException_0(){
  this.fillInStackTrace();
}

defineSeed(354, 144, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), BufferOverflowException_0);
function $$init_2(this$static){
  this$static.order = ($clinit_ByteOrder() , BIG_ENDIAN);
}

function $asShortBuffer(this$static){
  if (this$static.order != ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER)) {
    throw new RuntimeException_0('Native order supported only.');
  }
  return new ShortBuffer_0($slice(this$static));
}

function $compareTo(this$static, otherBuffer){
  var compareRemaining, otherByte, otherPos, thisByte, thisPos;
  compareRemaining = this$static.limit - this$static.position_0 < otherBuffer.limit - otherBuffer.position_0?this$static.limit - this$static.position_0:otherBuffer.limit - otherBuffer.position_0;
  thisPos = this$static.position_0;
  otherPos = otherBuffer.position_0;
  while (compareRemaining > 0) {
    thisByte = this$static.byteArray[thisPos];
    otherByte = otherBuffer.byteArray[otherPos];
    if (thisByte != otherByte) {
      return thisByte < otherByte?-1:1;
    }
    ++thisPos;
    ++otherPos;
    --compareRemaining;
  }
  return this$static.limit - this$static.position_0 - (otherBuffer.limit - otherBuffer.position_0);
}

function $get_1(this$static, index){
  return this$static.byteArray[index];
}

function $order(this$static, byteOrder){
  this$static.order = byteOrder;
  return this$static;
}

function $slice(this$static){
  var slice;
  slice = new ByteBuffer_2(this$static.byteArray.buffer, this$static.limit - this$static.position_0, this$static.byteArray.byteOffset + this$static.position_0);
  slice.order = this$static.order;
  return slice;
}

function ByteBuffer_0(capacity){
  ByteBuffer_1.call(this, new ArrayBuffer(capacity));
}

function ByteBuffer_1(buf){
  Buffer_0.call(this, buf.byteLength);
  $$init_2(this);
  this.byteArray = new Int8Array(buf);
}

function ByteBuffer_2(buffer, capacity, offset){
  Buffer_0.call(this, capacity);
  $$init_2(this);
  this.byteArray = new Int8Array(buffer, offset, capacity);
}

function allocateDirect(capacity){
  if (capacity < 0) {
    throw new IllegalArgumentException_0;
  }
  return new ByteBuffer_0(capacity);
}

defineSeed(355, 353, makeCastMap([Q$Comparable, Q$ByteBuffer, Q$HasArrayBufferView]), ByteBuffer_0, ByteBuffer_2);
_.compareTo$ = function compareTo_3(otherBuffer){
  return $compareTo(this, otherBuffer);
}
;
_.equals$ = function equals_9(other){
  var equalSoFar, myPosition, otherBuffer, otherPosition;
  if (!instanceOf(other, Q$ByteBuffer)) {
    return false;
  }
  otherBuffer = other;
  if (this.limit - this.position_0 != otherBuffer.limit - otherBuffer.position_0) {
    return false;
  }
  myPosition = this.position_0;
  otherPosition = otherBuffer.position_0;
  equalSoFar = true;
  while (equalSoFar && myPosition < this.limit) {
    equalSoFar = $get_1(this, myPosition++) == $get_1(otherBuffer, otherPosition++);
  }
  return equalSoFar;
}
;
_.getElementSize = function getElementSize(){
  return 1;
}
;
_.getElementType = function getElementType(){
  return 5120;
}
;
_.getTypedArray = function getTypedArray(){
  return this.byteArray;
}
;
_.hashCode$ = function hashCode_9(){
  var hash, myPosition;
  myPosition = this.position_0;
  hash = 0;
  while (myPosition < this.limit) {
    hash = hash + $get_1(this, myPosition++);
  }
  return hash;
}
;
_.toString$ = function toString_19(){
  var buf;
  buf = new StringBuffer_0;
  $append_5(buf, Ljava_nio_ByteBuffer_2_classLit.typeName);
  buf.impl.string += ', status: capacity=';
  $append_4(buf, this.capacity);
  buf.impl.string += ' position=';
  $append_4(buf, this.position_0);
  buf.impl.string += ' limit=';
  $append_4(buf, this.limit);
  return buf.impl.string;
}
;
_.byteArray = null;
function $clinit_ByteOrder(){
  $clinit_ByteOrder = nullMethod;
  BIG_ENDIAN = new ByteOrder_0('BIG_ENDIAN');
  LITTLE_ENDIAN = new ByteOrder_0('LITTLE_ENDIAN');
  NATIVE_ORDER = LITTLE_ENDIAN;
}

function ByteOrder_0(name_0){
  this.name_0 = name_0;
}

defineSeed(356, 1, {}, ByteOrder_0);
_.toString$ = function toString_20(){
  return this.name_0;
}
;
_.name_0 = null;
var BIG_ENDIAN, LITTLE_ENDIAN, NATIVE_ORDER = null;
function $compareTo_0(this$static, otherBuffer){
  var compareRemaining, otherFloat, otherPos, thisFloat, thisPos;
  compareRemaining = this$static.limit - this$static.position_0 < otherBuffer.limit - otherBuffer.position_0?this$static.limit - this$static.position_0:otherBuffer.limit - otherBuffer.position_0;
  thisPos = this$static.position_0;
  otherPos = otherBuffer.position_0;
  while (compareRemaining > 0) {
    thisFloat = this$static.floatArray[thisPos];
    otherFloat = otherBuffer.floatArray[otherPos];
    if (thisFloat != otherFloat && (thisFloat == thisFloat || otherFloat == otherFloat)) {
      return thisFloat < otherFloat?-1:1;
    }
    ++thisPos;
    ++otherPos;
    --compareRemaining;
  }
  return this$static.limit - this$static.position_0 - (otherBuffer.limit - otherBuffer.position_0);
}

function $get_2(this$static, index){
  return this$static.floatArray[index];
}

function $put_0(this$static, src, len){
  var i, length_0;
  length_0 = src.length;
  if (len < 0 || gt(fromInt(len), fromInt(length_0))) {
    throw new IndexOutOfBoundsException_0;
  }
  if (len > this$static.limit - this$static.position_0) {
    throw new BufferOverflowException_0;
  }
  for (i = 0; i < len; ++i) {
    this$static.floatArray[this$static.position_0++] = src[i];
  }
  return this$static;
}

function FloatBuffer_0(byteBuffer){
  Buffer_0.call(this, ~~byteBuffer.capacity >> 2);
  this.byteBuffer = byteBuffer;
  $clear_1(this.byteBuffer);
  this.floatArray = create_2(byteBuffer.byteArray.buffer, byteBuffer.byteArray.byteOffset, this.capacity);
}

defineSeed(357, 353, makeCastMap([Q$Comparable, Q$FloatBuffer, Q$HasArrayBufferView]), FloatBuffer_0);
_.compareTo$ = function compareTo_4(otherBuffer){
  return $compareTo_0(this, otherBuffer);
}
;
_.equals$ = function equals_10(other){
  var equalSoFar, myPosition, otherBuffer, otherPosition;
  if (!instanceOf(other, Q$FloatBuffer)) {
    return false;
  }
  otherBuffer = other;
  if (this.limit - this.position_0 != otherBuffer.limit - otherBuffer.position_0) {
    return false;
  }
  myPosition = this.position_0;
  otherPosition = otherBuffer.position_0;
  equalSoFar = true;
  while (equalSoFar && myPosition < this.limit) {
    equalSoFar = $get_2(this, myPosition++) == $get_2(otherBuffer, otherPosition++);
  }
  return equalSoFar;
}
;
_.getElementSize = function getElementSize_0(){
  return 4;
}
;
_.getElementType = function getElementType_0(){
  return 5126;
}
;
_.getTypedArray = function getTypedArray_0(){
  return this.floatArray;
}
;
_.toString$ = function toString_21(){
  var buf;
  buf = new StringBuffer_0;
  $append_5(buf, Ljava_nio_FloatBuffer_2_classLit.typeName);
  buf.impl.string += ', status: capacity=';
  $append_4(buf, this.capacity);
  buf.impl.string += ' position=';
  $append_4(buf, this.position_0);
  buf.impl.string += ' limit=';
  $append_4(buf, this.limit);
  return buf.impl.string;
}
;
_.byteBuffer = null;
_.floatArray = null;
function $compareTo_1(this$static, otherBuffer){
  var compareRemaining, otherByte, otherPos, thisByte, thisPos;
  compareRemaining = this$static.limit - this$static.position_0 < otherBuffer.limit - otherBuffer.position_0?this$static.limit - this$static.position_0:otherBuffer.limit - otherBuffer.position_0;
  thisPos = this$static.position_0;
  otherPos = otherBuffer.position_0;
  while (compareRemaining > 0) {
    thisByte = this$static.shortArray[thisPos];
    otherByte = otherBuffer.shortArray[otherPos];
    if (thisByte != otherByte) {
      return thisByte < otherByte?-1:1;
    }
    ++thisPos;
    ++otherPos;
    --compareRemaining;
  }
  return this$static.limit - this$static.position_0 - (otherBuffer.limit - otherBuffer.position_0);
}

function $get_3(this$static, index){
  return this$static.shortArray[index];
}

function $put_1(this$static, src, len){
  var i, length_0;
  length_0 = src.length;
  if (len < 0 || gt(fromInt(len), fromInt(length_0))) {
    throw new IndexOutOfBoundsException_0;
  }
  if (len > this$static.limit - this$static.position_0) {
    throw new BufferOverflowException_0;
  }
  for (i = 0; i < len; ++i) {
    this$static.shortArray[this$static.position_0++] = src[i];
  }
  return this$static;
}

function ShortBuffer_0(byteBuffer){
  Buffer_0.call(this, ~~byteBuffer.capacity >> 1);
  this.byteBuffer = byteBuffer;
  $clear_1(this.byteBuffer);
  this.shortArray = create_3(byteBuffer.byteArray.buffer, byteBuffer.byteArray.byteOffset, this.capacity);
}

defineSeed(358, 353, makeCastMap([Q$Comparable, Q$ShortBuffer, Q$HasArrayBufferView]), ShortBuffer_0);
_.compareTo$ = function compareTo_5(otherBuffer){
  return $compareTo_1(this, otherBuffer);
}
;
_.equals$ = function equals_11(other){
  var equalSoFar, myPosition, otherBuffer, otherPosition;
  if (!instanceOf(other, Q$ShortBuffer)) {
    return false;
  }
  otherBuffer = other;
  if (this.limit - this.position_0 != otherBuffer.limit - otherBuffer.position_0) {
    return false;
  }
  myPosition = this.position_0;
  otherPosition = otherBuffer.position_0;
  equalSoFar = true;
  while (equalSoFar && myPosition < this.limit) {
    equalSoFar = $get_3(this, myPosition++) == $get_3(otherBuffer, otherPosition++);
  }
  return equalSoFar;
}
;
_.getElementSize = function getElementSize_1(){
  return 2;
}
;
_.getElementType = function getElementType_1(){
  return 5122;
}
;
_.getTypedArray = function getTypedArray_1(){
  return this.shortArray;
}
;
_.hashCode$ = function hashCode_10(){
  var hash, myPosition;
  myPosition = this.position_0;
  hash = 0;
  while (myPosition < this.limit) {
    hash = hash + $get_3(this, myPosition++);
  }
  return hash;
}
;
_.toString$ = function toString_22(){
  var buf;
  buf = new StringBuffer_0;
  $append_5(buf, Ljava_nio_ShortBuffer_2_classLit.typeName);
  buf.impl.string += ', status: capacity=';
  $append_4(buf, this.capacity);
  buf.impl.string += ' position=';
  $append_4(buf, this.position_0);
  buf.impl.string += ' limit=';
  $append_4(buf, this.limit);
  return buf.impl.string;
}
;
_.byteBuffer = null;
_.shortArray = null;
function $addAllHashEntries(this$static, dest){
  var hashCodeMap = this$static.hashCodeMap;
  for (var hashCode in hashCodeMap) {
    var hashCodeInt = parseInt(hashCode, 10);
    if (hashCode == hashCodeInt) {
      var array = hashCodeMap[hashCodeInt];
      for (var i = 0, c = array.length; i < c; ++i) {
        dest.add(array[i]);
      }
    }
  }
}

function $addAllStringEntries(this$static, dest){
  var stringMap = this$static.stringMap;
  for (var key in stringMap) {
    if (key.charCodeAt(0) == 58) {
      var entry = new AbstractHashMap$MapEntryString_0(this$static, key.substring(1));
      dest.add(entry);
    }
  }
}

function $clearImpl(this$static){
  this$static.hashCodeMap = [];
  this$static.stringMap = {};
  this$static.nullSlotLive = false;
  this$static.nullSlot = null;
  this$static.size = 0;
}

function $containsKey_0(this$static, key){
  return key == null?this$static.nullSlotLive:instanceOf(key, Q$String)?':' + key in this$static.stringMap:$hasHashValue(this$static, key, ~~hashCode__devirtual$(key));
}

function $get_4(this$static, key){
  return key == null?this$static.nullSlot:instanceOf(key, Q$String)?this$static.stringMap[':' + key]:$getHashValue(this$static, key, ~~hashCode__devirtual$(key));
}

function $getHashValue(this$static, key, hashCode){
  var array = this$static.hashCodeMap[hashCode];
  if (array) {
    for (var i = 0, c = array.length; i < c; ++i) {
      var entry = array[i];
      var entryKey = entry.getKey();
      if (this$static.equalsBridge(key, entryKey)) {
        return entry.getValue();
      }
    }
  }
  return null;
}

function $getStringValue(this$static, key){
  return this$static.stringMap[':' + key];
}

function $hasHashValue(this$static, key, hashCode){
  var array = this$static.hashCodeMap[hashCode];
  if (array) {
    for (var i = 0, c = array.length; i < c; ++i) {
      var entry = array[i];
      var entryKey = entry.getKey();
      if (this$static.equalsBridge(key, entryKey)) {
        return true;
      }
    }
  }
  return false;
}

function $put_2(this$static, key, value){
  return key == null?$putNullSlot(this$static, value):instanceOf(key, Q$String)?$putStringValue(this$static, key, value):$putHashValue(this$static, key, value, ~~hashCode__devirtual$(key));
}

function $putHashValue(this$static, key, value, hashCode){
  var array = this$static.hashCodeMap[hashCode];
  if (array) {
    for (var i = 0, c = array.length; i < c; ++i) {
      var entry = array[i];
      var entryKey = entry.getKey();
      if (this$static.equalsBridge(key, entryKey)) {
        var previous = entry.getValue();
        entry.setValue(value);
        return previous;
      }
    }
  }
   else {
    array = this$static.hashCodeMap[hashCode] = [];
  }
  var entry = new MapEntryImpl_0(key, value);
  array.push(entry);
  ++this$static.size;
  return null;
}

function $putNullSlot(this$static, value){
  var result;
  result = this$static.nullSlot;
  this$static.nullSlot = value;
  if (!this$static.nullSlotLive) {
    this$static.nullSlotLive = true;
    ++this$static.size;
  }
  return result;
}

function $putStringValue(this$static, key, value){
  var result, stringMap = this$static.stringMap;
  key = ':' + key;
  key in stringMap?(result = stringMap[key]):++this$static.size;
  stringMap[key] = value;
  return result;
}

function $remove_9(this$static, key){
  return key == null?$removeNullSlot(this$static):instanceOf(key, Q$String)?$removeStringValue(this$static, key):$removeHashValue(this$static, key, ~~hashCode__devirtual$(key));
}

function $removeHashValue(this$static, key, hashCode){
  var array = this$static.hashCodeMap[hashCode];
  if (array) {
    for (var i = 0, c = array.length; i < c; ++i) {
      var entry = array[i];
      var entryKey = entry.getKey();
      if (this$static.equalsBridge(key, entryKey)) {
        array.length == 1?delete this$static.hashCodeMap[hashCode]:array.splice(i, 1);
        --this$static.size;
        return entry.getValue();
      }
    }
  }
  return null;
}

function $removeNullSlot(this$static){
  var result;
  result = this$static.nullSlot;
  this$static.nullSlot = null;
  if (this$static.nullSlotLive) {
    this$static.nullSlotLive = false;
    --this$static.size;
  }
  return result;
}

function $removeStringValue(this$static, key){
  var result, stringMap = this$static.stringMap;
  key = ':' + key;
  if (key in stringMap) {
    result = stringMap[key];
    --this$static.size;
    delete stringMap[key];
  }
  return result;
}

defineSeed(359, 275, makeCastMap([Q$Map]));
_.containsKey = function containsKey_1(key){
  return $containsKey_0(this, key);
}
;
_.entrySet_0 = function entrySet_1(){
  return new AbstractHashMap$EntrySet_0(this);
}
;
_.equalsBridge = function equalsBridge(value1, value2){
  return maskUndefined(value1) === maskUndefined(value2) || value1 != null && equals__devirtual$(value1, value2);
}
;
_.get_0 = function get_3(key){
  return $get_4(this, key);
}
;
_.put = function put_1(key, value){
  return $put_2(this, key, value);
}
;
_.remove_1 = function remove_11(key){
  return $remove_9(this, key);
}
;
_.size_0 = function size_4(){
  return this.size;
}
;
_.hashCodeMap = null;
_.nullSlot = null;
_.nullSlotLive = false;
_.size = 0;
_.stringMap = null;
function $contains_1(this$static, o){
  var entry, key, value;
  if (instanceOf(o, Q$Map$Entry)) {
    entry = o;
    key = entry.getKey();
    if ($containsKey_0(this$static.this$0, key)) {
      value = $get_4(this$static.this$0, key);
      return $equals_0(entry.getValue(), value);
    }
  }
  return false;
}

function AbstractHashMap$EntrySet_0(this$0){
  this.this$0 = this$0;
}

defineSeed(360, 279, makeCastMap([Q$Set]), AbstractHashMap$EntrySet_0);
_.contains_0 = function contains_3(o){
  return $contains_1(this, o);
}
;
_.iterator = function iterator_4(){
  return new AbstractHashMap$EntrySetIterator_0(this.this$0);
}
;
_.remove = function remove_12(entry){
  var key;
  if ($contains_1(this, entry)) {
    key = entry.getKey();
    $remove_9(this.this$0, key);
    return true;
  }
  return false;
}
;
_.size_0 = function size_5(){
  return this.this$0.size;
}
;
_.this$0 = null;
function $next_1(this$static){
  return this$static.last = $next_2(this$static.iter);
}

function $remove_10(this$static){
  if (!this$static.last) {
    throw new IllegalStateException_1('Must call next() before remove().');
  }
   else {
    $remove_11(this$static.iter);
    $remove_9(this$static.this$0, this$static.last.getKey());
    this$static.last = null;
  }
}

function AbstractHashMap$EntrySetIterator_0(this$0){
  var list;
  this.this$0 = this$0;
  list = new ArrayList_0;
  this$0.nullSlotLive && $add_4(list, new AbstractHashMap$MapEntryNull_0(this$0));
  $addAllStringEntries(this$0, list);
  $addAllHashEntries(this$0, list);
  this.iter = new AbstractList$IteratorImpl_0(list);
}

defineSeed(361, 1, {}, AbstractHashMap$EntrySetIterator_0);
_.hasNext = function hasNext_1(){
  return $hasNext(this.iter);
}
;
_.next_0 = function next_2(){
  return $next_1(this);
}
;
_.remove_2 = function remove_13(){
  $remove_10(this);
}
;
_.iter = null;
_.last = null;
_.this$0 = null;
defineSeed(363, 1, makeCastMap([Q$Map$Entry]));
_.equals$ = function equals_12(other){
  var entry;
  if (instanceOf(other, Q$Map$Entry)) {
    entry = other;
    if (equalsWithNullCheck(this.getKey(), entry.getKey()) && equalsWithNullCheck(this.getValue(), entry.getValue())) {
      return true;
    }
  }
  return false;
}
;
_.hashCode$ = function hashCode_11(){
  var keyHash, valueHash;
  keyHash = 0;
  valueHash = 0;
  this.getKey() != null && (keyHash = hashCode__devirtual$(this.getKey()));
  this.getValue() != null && (valueHash = hashCode__devirtual$(this.getValue()));
  return keyHash ^ valueHash;
}
;
_.toString$ = function toString_23(){
  return this.getKey() + '=' + this.getValue();
}
;
function AbstractHashMap$MapEntryNull_0(this$0){
  this.this$0 = this$0;
}

defineSeed(362, 363, makeCastMap([Q$Map$Entry]), AbstractHashMap$MapEntryNull_0);
_.getKey = function getKey_0(){
  return null;
}
;
_.getValue = function getValue_0(){
  return this.this$0.nullSlot;
}
;
_.setValue = function setValue_0(object){
  return $putNullSlot(this.this$0, object);
}
;
_.this$0 = null;
function AbstractHashMap$MapEntryString_0(this$0, key){
  this.this$0 = this$0;
  this.key_0 = key;
}

defineSeed(364, 363, makeCastMap([Q$Map$Entry]), AbstractHashMap$MapEntryString_0);
_.getKey = function getKey_1(){
  return this.key_0;
}
;
_.getValue = function getValue_1(){
  return $getStringValue(this.this$0, this.key_0);
}
;
_.setValue = function setValue_1(object){
  return $putStringValue(this.this$0, this.key_0, object);
}
;
_.key_0 = null;
_.this$0 = null;
function $hasNext(this$static){
  return this$static.i < this$static.this$0_0.size_0();
}

function $next_2(this$static){
  if (this$static.i >= this$static.this$0_0.size_0()) {
    throw new NoSuchElementException_0;
  }
  return this$static.this$0_0.get(this$static.last = this$static.i++);
}

function $remove_11(this$static){
  if (this$static.last < 0) {
    throw new IllegalStateException_0;
  }
  this$static.this$0_0.remove_0(this$static.last);
  this$static.i = this$static.last;
  this$static.last = -1;
}

function AbstractList$IteratorImpl_0(this$0){
  this.this$0_0 = this$0;
}

defineSeed(365, 1, {}, AbstractList$IteratorImpl_0);
_.hasNext = function hasNext_2(){
  return $hasNext(this);
}
;
_.next_0 = function next_3(){
  return $next_2(this);
}
;
_.remove_2 = function remove_14(){
  $remove_11(this);
}
;
_.i = 0;
_.last = -1;
_.this$0_0 = null;
function AbstractList$ListIteratorImpl_0(this$0, start){
  var size;
  this.this$0 = this$0;
  this.this$0_0 = this$0;
  size = this$0.size_0();
  (start < 0 || start > size) && indexOutOfBounds(start, size);
  this.i = start;
}

defineSeed(366, 365, {}, AbstractList$ListIteratorImpl_0);
_.hasPrevious = function hasPrevious(){
  return this.i > 0;
}
;
_.previous = function previous_0(){
  if (this.i <= 0) {
    throw new NoSuchElementException_0;
  }
  return this.this$0.get(this.last = --this.i);
}
;
_.this$0 = null;
function $iterator(this$static){
  var outerIter;
  outerIter = new AbstractHashMap$EntrySetIterator_0(this$static.val$entrySet.this$0);
  return new AbstractMap$1$1_0(outerIter);
}

function AbstractMap$1_0(this$0, val$entrySet){
  this.this$0 = this$0;
  this.val$entrySet = val$entrySet;
}

defineSeed(367, 279, makeCastMap([Q$Set]), AbstractMap$1_0);
_.contains_0 = function contains_4(key){
  return $containsKey_0(this.this$0, key);
}
;
_.iterator = function iterator_5(){
  return $iterator(this);
}
;
_.size_0 = function size_6(){
  return this.val$entrySet.this$0.size;
}
;
_.this$0 = null;
_.val$entrySet = null;
function AbstractMap$1$1_0(val$outerIter){
  this.val$outerIter = val$outerIter;
}

defineSeed(368, 1, {}, AbstractMap$1$1_0);
_.hasNext = function hasNext_3(){
  return $hasNext(this.val$outerIter.iter);
}
;
_.next_0 = function next_4(){
  var entry;
  entry = $next_1(this.val$outerIter);
  return entry.getKey();
}
;
_.remove_2 = function remove_15(){
  $remove_10(this.val$outerIter);
}
;
_.val$outerIter = null;
function $get_5(this$static, index){
  var $e0, iter;
  iter = $listIterator(this$static, index);
  try {
    return $next_3(iter);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$NoSuchElementException)) {
      throw new IndexOutOfBoundsException_1("Can't get element " + index);
    }
     else 
      throw $e0;
  }
}

defineSeed(369, 115, makeCastMap([Q$List]));
_.add_0 = function add_5(index, element){
  var iter;
  iter = $listIterator(this, index);
  $addBefore(iter.this$0, element, iter.currentNode);
  ++iter.currentIndex;
  iter.lastNode = null;
}
;
_.get = function get_4(index){
  return $get_5(this, index);
}
;
_.iterator = function iterator_6(){
  return $listIterator(this, 0);
}
;
_.remove_0 = function remove_16(index){
  var $e0, iter, old;
  iter = $listIterator(this, index);
  try {
    old = $next_3(iter);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$NoSuchElementException)) {
      throw new IndexOutOfBoundsException_1("Can't remove element " + index);
    }
     else 
      throw $e0;
  }
  $remove_13(iter);
  return old;
}
;
function insertionSort(array, low, high){
  var i, j, t;
  for (i = low + 1; i < high; ++i) {
    for (j = i; j > low && array[j - 1].compareTo$(array[j]) > 0; --j) {
      t = array[j];
      setCheck(array, j, array[j - 1]);
      setCheck(array, j - 1, t);
    }
  }
}

function merge(src, srcLow, srcMid, srcHigh, dest, destLow, destHigh){
  var topIdx;
  topIdx = srcMid;
  while (destLow < destHigh) {
    topIdx >= srcHigh || srcLow < srcMid && src[srcLow].compareTo$(src[topIdx]) <= 0?setCheck(dest, destLow++, src[srcLow++]):setCheck(dest, destLow++, src[topIdx++]);
  }
}

function mergeSort(x, fromIndex, toIndex){
  var temp;
  temp = cloneSubrange(x, fromIndex, toIndex);
  mergeSort_0(temp, x, fromIndex, toIndex, -fromIndex);
}

function mergeSort_0(temp, array, low, high, ofs){
  var length_0, tempHigh, tempLow, tempMid;
  length_0 = high - low;
  if (length_0 < 7) {
    insertionSort(array, low, high);
    return;
  }
  tempLow = low + ofs;
  tempHigh = high + ofs;
  tempMid = tempLow + (~~(tempHigh - tempLow) >> 1);
  mergeSort_0(array, temp, tempLow, tempMid, -ofs);
  mergeSort_0(array, temp, tempMid, tempHigh, -ofs);
  if (temp[tempMid - 1].compareTo$(temp[tempMid]) <= 0) {
    while (low < high) {
      setCheck(array, low++, temp[tempLow++]);
    }
    return;
  }
  merge(temp, tempLow, tempMid, tempHigh, array, low, high);
}

function $clinit_Collections(){
  $clinit_Collections = nullMethod;
  EMPTY_LIST = new Collections$EmptyList_0;
}

var EMPTY_LIST;
function Collections$EmptyList_0(){
}

defineSeed(372, 115, makeCastMap([Q$Serializable, Q$List]), Collections$EmptyList_0);
_.contains_0 = function contains_5(object){
  return false;
}
;
_.get = function get_5(location_0){
  throw new IndexOutOfBoundsException_0;
}
;
_.size_0 = function size_7(){
  return 0;
}
;
--></script>
<script><!--
function Date_1(){
  this.jsdate = new Date;
}

function Date_2(date){
  this.jsdate = create(toDouble(date));
}

function padTwo(number){
  return number < 10?'0' + number:'' + number;
}

defineSeed(374, 1, makeCastMap([Q$Serializable, Q$Comparable, Q$Date]), Date_1, Date_2);
_.compareTo$ = function compareTo_6(other){
  return signum(sub(fromDouble(this.jsdate.getTime()), fromDouble(other.jsdate.getTime())));
}
;
_.equals$ = function equals_13(obj){
  return instanceOf(obj, Q$Date) && eq(fromDouble(this.jsdate.getTime()), fromDouble(obj.jsdate.getTime()));
}
;
_.hashCode$ = function hashCode_12(){
  var time;
  time = fromDouble(this.jsdate.getTime());
  return toInt(xor(time, shru(time, 32)));
}
;
_.toString$ = function toString_24(){
  var hourOffset, minuteOffset, offset;
  offset = -this.jsdate.getTimezoneOffset();
  hourOffset = (offset >= 0?'+':'') + ~~(offset / 60);
  minuteOffset = (offset < 0?-offset:offset) % 60 < 10?'0' + (offset < 0?-offset:offset) % 60:'' + (offset < 0?-offset:offset) % 60;
  return ($clinit_Date$StringData() , DAYS)[this.jsdate.getDay()] + ' ' + MONTHS[this.jsdate.getMonth()] + ' ' + padTwo(this.jsdate.getDate()) + ' ' + padTwo(this.jsdate.getHours()) + ':' + padTwo(this.jsdate.getMinutes()) + ':' + padTwo(this.jsdate.getSeconds()) + ' GMT' + hourOffset + minuteOffset + ' ' + this.jsdate.getFullYear();
}
;
_.jsdate = null;
function $clinit_Date$StringData(){
  $clinit_Date$StringData = nullMethod;
  DAYS = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']);
  MONTHS = initValues(_3Ljava_lang_String_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$String, ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']);
}

var DAYS, MONTHS;
function EmptyStackException_0(){
  this.fillInStackTrace();
}

defineSeed(376, 144, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable]), EmptyStackException_0);
function $equals_0(value1, value2){
  return maskUndefined(value1) === maskUndefined(value2) || value1 != null && equals__devirtual$(value1, value2);
}

function HashMap_0(){
  $clearImpl(this);
}

defineSeed(377, 359, makeCastMap([Q$Serializable, Q$Map]), HashMap_0);
function $add_8(this$static, o){
  var old;
  old = $put_2(this$static.map, o, this$static);
  return old == null;
}

function $contains_2(this$static, o){
  return $containsKey_0(this$static.map, o);
}

function $remove_12(this$static, o){
  return $remove_9(this$static.map, o) != null;
}

function HashSet_0(){
  this.map = new HashMap_0;
}

defineSeed(378, 279, makeCastMap([Q$Serializable, Q$Set]), HashSet_0);
_.add = function add_6(o){
  return $add_8(this, o);
}
;
_.contains_0 = function contains_6(o){
  return $containsKey_0(this.map, o);
}
;
_.isEmpty = function isEmpty_2(){
  return this.map.size == 0;
}
;
_.iterator = function iterator_7(){
  return $iterator($keySet(this.map));
}
;
_.remove = function remove_17(o){
  return $remove_12(this, o);
}
;
_.size_0 = function size_8(){
  return this.map.size;
}
;
_.toString$ = function toString_25(){
  return $toString_0($keySet(this.map));
}
;
_.map = null;
function $add_9(this$static, o){
  new LinkedList$Node_1(o, this$static.header);
  ++this$static.size;
  return true;
}

function $addBefore(this$static, o, target){
  new LinkedList$Node_1(o, target);
  ++this$static.size;
}

function $addFirst(this$static, o){
  new LinkedList$Node_1(o, this$static.header.next);
  ++this$static.size;
}

function $clear_2(this$static){
  this$static.header = new LinkedList$Node_0;
  this$static.size = 0;
}

function $listIterator(this$static, index){
  var i, node;
  (index < 0 || index > this$static.size) && indexOutOfBounds(index, this$static.size);
  if (index >= ~~this$static.size >> 1) {
    node = this$static.header;
    for (i = this$static.size; i > index; --i) {
      node = node.prev;
    }
  }
   else {
    node = this$static.header.next;
    for (i = 0; i < index; ++i) {
      node = node.next;
    }
  }
  return new LinkedList$ListIteratorImpl_0(this$static, index, node);
}

function LinkedList_0(){
  this.header = new LinkedList$Node_0;
  this.size = 0;
}

defineSeed(379, 369, makeCastMap([Q$Serializable, Q$List]), LinkedList_0);
_.add = function add_7(o){
  return $add_9(this, o);
}
;
_.listIterator_0 = function listIterator_1(index){
  return $listIterator(this, index);
}
;
_.size_0 = function size_9(){
  return this.size;
}
;
_.header = null;
_.size = 0;
function $next_3(this$static){
  if (this$static.currentNode == this$static.this$0.header) {
    throw new NoSuchElementException_0;
  }
  this$static.lastNode = this$static.currentNode;
  this$static.currentNode = this$static.currentNode.next;
  ++this$static.currentIndex;
  return this$static.lastNode.value_0;
}

function $remove_13(this$static){
  $verifyCurrentElement(this$static);
  this$static.currentNode == this$static.lastNode?(this$static.currentNode = this$static.lastNode.next):--this$static.currentIndex;
  $remove_14(this$static.lastNode);
  this$static.lastNode = null;
  --this$static.this$0.size;
}

function $verifyCurrentElement(this$static){
  if (!this$static.lastNode) {
    throw new IllegalStateException_0;
  }
}

function LinkedList$ListIteratorImpl_0(this$0, index, startNode){
  this.this$0 = this$0;
  this.currentNode = startNode;
  this.currentIndex = index;
}

defineSeed(380, 1, {}, LinkedList$ListIteratorImpl_0);
_.hasNext = function hasNext_4(){
  return this.currentNode != this.this$0.header;
}
;
_.hasPrevious = function hasPrevious_0(){
  return this.currentNode.prev != this.this$0.header;
}
;
_.next_0 = function next_5(){
  return $next_3(this);
}
;
_.previous = function previous_1(){
  if (this.currentNode.prev == this.this$0.header) {
    throw new NoSuchElementException_0;
  }
  this.lastNode = this.currentNode = this.currentNode.prev;
  --this.currentIndex;
  return this.lastNode.value_0;
}
;
_.remove_2 = function remove_18(){
  $remove_13(this);
}
;
_.currentIndex = 0;
_.currentNode = null;
_.lastNode = null;
_.this$0 = null;
function $remove_14(this$static){
  this$static.next.prev = this$static.prev;
  this$static.prev.next = this$static.next;
  this$static.next = this$static.prev = this$static;
}

function LinkedList$Node_0(){
  this.next = this.prev = this;
}

function LinkedList$Node_1(value, nextNode){
  this.value_0 = value;
  this.next = nextNode;
  this.prev = nextNode.prev;
  nextNode.prev.next = this;
  nextNode.prev = this;
}

defineSeed(381, 1, {}, LinkedList$Node_0, LinkedList$Node_1);
_.next = null;
_.prev = null;
_.value_0 = null;
function MapEntryImpl_0(key, value){
  this.key_0 = key;
  this.value_0 = value;
}

defineSeed(382, 363, makeCastMap([Q$Map$Entry]), MapEntryImpl_0);
_.getKey = function getKey_2(){
  return this.key_0;
}
;
_.getValue = function getValue_2(){
  return this.value_0;
}
;
_.setValue = function setValue_2(value){
  var old;
  old = this.value_0;
  this.value_0 = value;
  return old;
}
;
_.key_0 = null;
_.value_0 = null;
function NoSuchElementException_0(){
  this.fillInStackTrace();
}

defineSeed(383, 144, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable, Q$NoSuchElementException]), NoSuchElementException_0);
function $clinit_Random(){
  $clinit_Random = nullMethod;
  var i, twoToTheXMinus24Tmp, twoToTheXMinus48Tmp;
  twoToTheXMinus24 = initDim(_3D_classLit, makeCastMap([Q$Serializable]), -1, 25, 1);
  twoToTheXMinus48 = initDim(_3D_classLit, makeCastMap([Q$Serializable]), -1, 33, 1);
  twoToTheXMinus48Tmp = 1.52587890625E-5;
  for (i = 32; i >= 0; --i) {
    twoToTheXMinus48[i] = twoToTheXMinus48Tmp;
    twoToTheXMinus48Tmp *= 0.5;
  }
  twoToTheXMinus24Tmp = 1;
  for (i = 24; i >= 0; --i) {
    twoToTheXMinus24[i] = twoToTheXMinus24Tmp;
    twoToTheXMinus24Tmp *= 0.5;
  }
}

function $nextInt(this$static, n){
  var bits, val;
  if (n > 0) {
    if ((n & -n) == n) {
      return round_int(n * $nextInternal(this$static, 31) * 4.6566128730773926E-10);
    }
    do {
      bits = $nextInternal(this$static, 31);
      val = bits % n;
    }
     while (bits - val + (n - 1) < 0);
    return round_int(val);
  }
  throw new IllegalArgumentException_0;
}

function $nextInternal(this$static, bits){
  var carry, dval, h_0, hi, l_0, lo;
  hi = this$static.seedhi * 15525485 + this$static.seedlo * 1502;
  lo = this$static.seedlo * 15525485 + 11;
  carry = Math.floor(lo * 5.9604644775390625E-8);
  hi += carry;
  lo -= carry * 16777216;
  hi %= 16777216;
  this$static.seedhi = hi;
  this$static.seedlo = lo;
  if (bits <= 24) {
    return floor(this$static.seedhi * twoToTheXMinus24[bits]);
  }
   else {
    h_0 = this$static.seedhi * (1 << bits - 24);
    l_0 = floor(this$static.seedlo * twoToTheXMinus48[bits]);
    dval = h_0 + l_0;
    dval >= 2147483648 && (dval -= 4294967296);
    return dval;
  }
}

function Random_0(){
  $clinit_Random();
  var hi, lo, seed;
  seed = uniqueSeed++ + (new Date).getTime();
  hi = round_int(Math.floor(seed * 5.9604644775390625E-8)) & 16777215;
  lo = round_int(seed - hi * 16777216);
  this.seedhi = hi ^ 1502;
  this.seedlo = lo ^ 15525485;
}

defineSeed(384, 1, {}, Random_0);
_.seedhi = 0;
_.seedlo = 0;
var twoToTheXMinus24, twoToTheXMinus48, uniqueSeed = 0;
function $add_10(this$static, o){
  return $add_4(this$static.arrayList, o);
}

function $contains_3(this$static, elem){
  return $indexOf(this$static.arrayList, elem, 0) != -1;
}

defineSeed(386, 115, makeCastMap([Q$Serializable, Q$List]));
_.add_0 = function add_8(index, o){
  $add_3(this.arrayList, index, o);
}
;
_.add = function add_9(o){
  return $add_4(this.arrayList, o);
}
;
_.contains_0 = function contains_7(elem){
  return $contains_3(this, elem);
}
;
_.get = function get_6(index){
  return $get(this.arrayList, index);
}
;
_.isEmpty = function isEmpty_3(){
  return this.arrayList.size == 0;
}
;
_.iterator = function iterator_8(){
  return new AbstractList$IteratorImpl_0(this.arrayList);
}
;
_.remove_0 = function remove_19(index){
  return $remove_2(this.arrayList, index);
}
;
_.size_0 = function size_10(){
  return this.arrayList.size;
}
;
_.toString$ = function toString_26(){
  return $toString_0(this.arrayList);
}
;
_.arrayList = null;
function $peek(this$static){
  var sz;
  sz = this$static.arrayList.size;
  if (sz > 0) {
    return $get(this$static.arrayList, sz - 1);
  }
   else {
    throw new EmptyStackException_0;
  }
}

function $pop(this$static){
  var sz;
  sz = this$static.arrayList.size;
  if (sz > 0) {
    return $remove_2(this$static.arrayList, sz - 1);
  }
   else {
    throw new EmptyStackException_0;
  }
}

function $push_1(this$static, o){
  $add_4(this$static.arrayList, o);
  return o;
}

function Stack_0(){
  this.arrayList = new ArrayList_0;
}

defineSeed(385, 386, makeCastMap([Q$Serializable, Q$List]), Stack_0);
function equalsWithNullCheck(a, b){
  return maskUndefined(a) === maskUndefined(b) || a != null && equals__devirtual$(a, b);
}

function $shouldCollide(fixtureA, fixtureB){
  var collide, filterA, filterB;
  filterA = fixtureA.m_filter;
  filterB = fixtureB.m_filter;
  if (filterA.groupIndex == filterB.groupIndex && filterA.groupIndex != 0) {
    return filterA.groupIndex > 0;
  }
  collide = (filterA.maskBits & filterB.categoryBits) != 0 && (filterA.categoryBits & filterB.maskBits) != 0;
  return collide;
}

function ContactFilter_0(){
}

defineSeed(388, 1, {}, ContactFilter_0);
function ContactImpulse_0(){
  this.normalImpulses = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 2, 1);
  this.tangentImpulses = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 2, 1);
}

defineSeed(389, 1, {}, ContactImpulse_0);
function $combine(this$static, aabb1, aab){
  this$static.lowerBound.x = aabb1.lowerBound.x < aab.lowerBound.x?aabb1.lowerBound.x:aab.lowerBound.x;
  this$static.lowerBound.y = aabb1.lowerBound.y < aab.lowerBound.y?aabb1.lowerBound.y:aab.lowerBound.y;
  this$static.upperBound.x = aabb1.upperBound.x > aab.upperBound.x?aabb1.upperBound.x:aab.upperBound.x;
  this$static.upperBound.y = aabb1.upperBound.y > aab.upperBound.y?aabb1.upperBound.y:aab.upperBound.y;
}

function $getPerimeter(this$static){
  return 2 * (this$static.upperBound.x - this$static.lowerBound.x + this$static.upperBound.y - this$static.lowerBound.y);
}

function AABB_0(){
  this.lowerBound = new Vec2_0;
  this.upperBound = new Vec2_0;
}

function testOverlap(a, b){
  if (b.lowerBound.x - a.upperBound.x > 0 || b.lowerBound.y - a.upperBound.y > 0) {
    return false;
  }
  if (a.lowerBound.x - b.upperBound.x > 0 || a.lowerBound.y - b.upperBound.y > 0) {
    return false;
  }
  return true;
}

defineSeed(390, 1, {}, AABB_0);
_.toString$ = function toString_27(){
  var s;
  s = 'AABB[' + this.lowerBound + ' . ' + this.upperBound + ']';
  return s;
}
;
_.lowerBound = null;
_.upperBound = null;
function $clinit_Collision(){
  $clinit_Collision = nullMethod;
  d_0 = new Vec2_0;
}

function $collideCircles(manifold, circle1, xfA, circle2, xfB){
  var circle1p, circle2p, distSqr, dx, dy, pAx, pAy, pBx, pBy, radius;
  manifold.pointCount = 0;
  circle1p = circle1.m_p;
  circle2p = circle2.m_p;
  pAx = xfA.q.c * circle1p.x - xfA.q.s * circle1p.y + xfA.p.x;
  pAy = xfA.q.s * circle1p.x + xfA.q.c * circle1p.y + xfA.p.y;
  pBx = xfB.q.c * circle2p.x - xfB.q.s * circle2p.y + xfB.p.x;
  pBy = xfB.q.s * circle2p.x + xfB.q.c * circle2p.y + xfB.p.y;
  dx = pBx - pAx;
  dy = pBy - pAy;
  distSqr = dx * dx + dy * dy;
  radius = circle1.m_radius + circle2.m_radius;
  if (distSqr > radius * radius) {
    return;
  }
  manifold.type_0 = ($clinit_Manifold$ManifoldType() , CIRCLES);
  $set_12(manifold.localPoint, circle1p);
  $setZero_0(manifold.localNormal);
  manifold.pointCount = 1;
  $set_12(manifold.points[0].localPoint, circle2p);
  $zero(manifold.points[0].id_0);
}

function $collideEdgeAndCircle(this$static, manifold, edgeA, xfA, circleB, xfB){
  var A, A1, B, B2, dd, den, e2, radius, u, u1, v, v2;
  manifold.pointCount = 0;
  mulToOutUnsafe_1(xfB, circleB.m_p, this$static.temp);
  mulTransToOutUnsafe_0(xfA, this$static.temp, this$static.Q);
  A = edgeA.m_vertex1;
  B = edgeA.m_vertex2;
  $subLocal($set_12(this$static.e, B), A);
  u = dot_0(this$static.e, $subLocal($set_12(this$static.temp, B), this$static.Q));
  v = dot_0(this$static.e, $subLocal($set_12(this$static.temp, this$static.Q), A));
  radius = edgeA.m_radius + circleB.m_radius;
  this$static.cf.indexB = 0;
  this$static.cf.typeB = 0;
  if (v <= 0) {
    $subLocal($set_12(d_0, this$static.Q), A);
    dd = dot_0(d_0, d_0);
    if (dd > radius * radius) {
      return;
    }
    if (edgeA.m_hasVertex0) {
      A1 = edgeA.m_vertex0;
      $subLocal($set_12(this$static.e1, A), A1);
      u1 = dot_0(this$static.e1, $subLocal($set_12(this$static.temp, A), this$static.Q));
      if (u1 > 0) {
        return;
      }
    }
    this$static.cf.indexA = 0;
    this$static.cf.typeA = 0;
    manifold.pointCount = 1;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , CIRCLES);
    $setZero_0(manifold.localNormal);
    $set_12(manifold.localPoint, A);
    $set_2(manifold.points[0].id_0, this$static.cf);
    $set_12(manifold.points[0].localPoint, circleB.m_p);
    return;
  }
  if (u <= 0) {
    $subLocal($set_12(d_0, this$static.Q), B);
    dd = dot_0(d_0, d_0);
    if (dd > radius * radius) {
      return;
    }
    if (edgeA.m_hasVertex3) {
      B2 = edgeA.m_vertex3;
      e2 = this$static.e1;
      $subLocal($set_12(e2, B2), B);
      v2 = dot_0(e2, $subLocal($set_12(this$static.temp, this$static.Q), B));
      if (v2 > 0) {
        return;
      }
    }
    this$static.cf.indexA = 1;
    this$static.cf.typeA = 0;
    manifold.pointCount = 1;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , CIRCLES);
    $setZero_0(manifold.localNormal);
    $set_12(manifold.localPoint, B);
    $set_2(manifold.points[0].id_0, this$static.cf);
    $set_12(manifold.points[0].localPoint, circleB.m_p);
    return;
  }
  den = dot_0(this$static.e, this$static.e);
  $addLocal($mulLocal($set_12(this$static.P, A), u), $mulLocal($set_12(this$static.temp, B), v));
  $mulLocal(this$static.P, 1 / den);
  $subLocal($set_12(d_0, this$static.Q), this$static.P);
  dd = dot_0(d_0, d_0);
  if (dd > radius * radius) {
    return;
  }
  this$static.n.x = -this$static.e.y;
  this$static.n.y = this$static.e.x;
  dot_0(this$static.n, $subLocal($set_12(this$static.temp, this$static.Q), A)) < 0 && $set_11(this$static.n, -this$static.n.x, -this$static.n.y);
  $normalize_0(this$static.n);
  this$static.cf.indexA = 0;
  this$static.cf.typeA = 1;
  manifold.pointCount = 1;
  manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_A);
  $set_12(manifold.localNormal, this$static.n);
  $set_12(manifold.localPoint, A);
  $set_2(manifold.points[0].id_0, this$static.cf);
  $set_12(manifold.points[0].localPoint, circleB.m_p);
}

function $collideEdgeAndPolygon(this$static, manifold, edgeA, xfA, polygonB, xfB){
  $collide(this$static.collider, manifold, edgeA, xfA, polygonB, xfB);
}

function $collidePolygonAndCircle(manifold, polygon, xfA, circle, xfB){
  var cLocalx, cLocaly, circlep, cx, cy, dx, dy, fcx, fcy, i, mpoint, normal, normalIndex, normals, px, py, radius, s, separation, temp2X, temp2Y, temp3X, temp3Y, temp4X, temp4Y, tempX, tempY, tempx, tempy, tx, ty, u1, u2, v1, v2, vertIndex2, vertex, vertexCount, vertices, xfAq, xfBq;
  manifold.pointCount = 0;
  circlep = circle.m_p;
  xfBq = xfB.q;
  xfAq = xfA.q;
  cx = xfBq.c * circlep.x - xfBq.s * circlep.y + xfB.p.x;
  cy = xfBq.s * circlep.x + xfBq.c * circlep.y + xfB.p.y;
  px = cx - xfA.p.x;
  py = cy - xfA.p.y;
  cLocalx = xfAq.c * px + xfAq.s * py;
  cLocaly = -xfAq.s * px + xfAq.c * py;
  normalIndex = 0;
  separation = -3.4028234663852886E38;
  radius = polygon.m_radius + circle.m_radius;
  vertexCount = polygon.m_count;
  vertices = polygon.m_vertices;
  normals = polygon.m_normals;
  for (i = 0; i < vertexCount; ++i) {
    vertex = vertices[i];
    tempx = cLocalx - vertex.x;
    tempy = cLocaly - vertex.y;
    s = normals[i].x * tempx + normals[i].y * tempy;
    if (s > radius) {
      return;
    }
    if (s > separation) {
      separation = s;
      normalIndex = i;
    }
  }
  vertIndex2 = normalIndex + 1 < vertexCount?normalIndex + 1:0;
  v1 = vertices[normalIndex];
  v2 = vertices[vertIndex2];
  if (separation < 1.1920928955078125E-7) {
    manifold.pointCount = 1;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_A);
    normal = normals[normalIndex];
    manifold.localNormal.x = normal.x;
    manifold.localNormal.y = normal.y;
    manifold.localPoint.x = (v1.x + v2.x) * 0.5;
    manifold.localPoint.y = (v1.y + v2.y) * 0.5;
    mpoint = manifold.points[0];
    mpoint.localPoint.x = circlep.x;
    mpoint.localPoint.y = circlep.y;
    $zero(mpoint.id_0);
    return;
  }
  tempX = cLocalx - v1.x;
  tempY = cLocaly - v1.y;
  temp2X = v2.x - v1.x;
  temp2Y = v2.y - v1.y;
  u1 = tempX * temp2X + tempY * temp2Y;
  temp3X = cLocalx - v2.x;
  temp3Y = cLocaly - v2.y;
  temp4X = v1.x - v2.x;
  temp4Y = v1.y - v2.y;
  u2 = temp3X * temp4X + temp3Y * temp4Y;
  if (u1 <= 0) {
    dx = cLocalx - v1.x;
    dy = cLocaly - v1.y;
    if (dx * dx + dy * dy > radius * radius) {
      return;
    }
    manifold.pointCount = 1;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_A);
    manifold.localNormal.x = cLocalx - v1.x;
    manifold.localNormal.y = cLocaly - v1.y;
    $normalize_0(manifold.localNormal);
    $set_12(manifold.localPoint, v1);
    $set_12(manifold.points[0].localPoint, circlep);
    $zero(manifold.points[0].id_0);
  }
   else if (u2 <= 0) {
    dx = cLocalx - v2.x;
    dy = cLocaly - v2.y;
    if (dx * dx + dy * dy > radius * radius) {
      return;
    }
    manifold.pointCount = 1;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_A);
    manifold.localNormal.x = cLocalx - v2.x;
    manifold.localNormal.y = cLocaly - v2.y;
    $normalize_0(manifold.localNormal);
    $set_12(manifold.localPoint, v2);
    $set_12(manifold.points[0].localPoint, circlep);
    $zero(manifold.points[0].id_0);
  }
   else {
    fcx = (v1.x + v2.x) * 0.5;
    fcy = (v1.y + v2.y) * 0.5;
    tx = cLocalx - fcx;
    ty = cLocaly - fcy;
    normal = normals[normalIndex];
    separation = tx * normal.x + ty * normal.y;
    if (separation > radius) {
      return;
    }
    manifold.pointCount = 1;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_A);
    $set_12(manifold.localNormal, normals[normalIndex]);
    manifold.localPoint.x = fcx;
    manifold.localPoint.y = fcy;
    $set_12(manifold.points[0].localPoint, circlep);
    $zero(manifold.points[0].id_0);
  }
}

function $collidePolygons(this$static, manifold, polyA, xfA, polyB, xfB){
  var count1, cp, edge1, flip, frontOffset, i, iv2, normalx, normaly, np, out, pointCount, poly1, poly2, px, py, separation, sideOffset1, sideOffset2, totalRadius, vertices1, xf1, xf1q, xf2;
  manifold.pointCount = 0;
  totalRadius = polyA.m_radius + polyB.m_radius;
  $findMaxSeparation(this$static.results1, polyA, xfA, polyB, xfB);
  if (this$static.results1.separation > totalRadius) {
    return;
  }
  $findMaxSeparation(this$static.results2, polyB, xfB, polyA, xfA);
  if (this$static.results2.separation > totalRadius) {
    return;
  }
  if (this$static.results2.separation > 0.9800000190734863 * this$static.results1.separation + 0.0010000000474974513) {
    poly1 = polyB;
    poly2 = polyA;
    xf1 = xfB;
    xf2 = xfA;
    edge1 = this$static.results2.edgeIndex;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_B);
    flip = true;
  }
   else {
    poly1 = polyA;
    poly2 = polyB;
    xf1 = xfA;
    xf2 = xfB;
    edge1 = this$static.results1.edgeIndex;
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_A);
    flip = false;
  }
  xf1q = xf1.q;
  $findIncidentEdge(this$static.incidentEdge, poly1, xf1, edge1, poly2, xf2);
  count1 = poly1.m_count;
  vertices1 = poly1.m_vertices;
  iv2 = edge1 + 1 < count1?edge1 + 1:0;
  $set_12(this$static.v11, vertices1[edge1]);
  $set_12(this$static.v12, vertices1[iv2]);
  this$static.localTangent.x = this$static.v12.x - this$static.v11.x;
  this$static.localTangent.y = this$static.v12.y - this$static.v11.y;
  $normalize_0(this$static.localTangent);
  this$static.localNormal.x = this$static.localTangent.y;
  this$static.localNormal.y = -this$static.localTangent.x;
  this$static.planePoint.x = (this$static.v11.x + this$static.v12.x) * 0.5;
  this$static.planePoint.y = (this$static.v11.y + this$static.v12.y) * 0.5;
  this$static.tangent.x = xf1q.c * this$static.localTangent.x - xf1q.s * this$static.localTangent.y;
  this$static.tangent.y = xf1q.s * this$static.localTangent.x + xf1q.c * this$static.localTangent.y;
  normalx = this$static.tangent.y;
  normaly = -this$static.tangent.x;
  mulToOut(xf1, this$static.v11, this$static.v11);
  mulToOut(xf1, this$static.v12, this$static.v12);
  frontOffset = normalx * this$static.v11.x + normaly * this$static.v11.y;
  sideOffset1 = -(this$static.tangent.x * this$static.v11.x + this$static.tangent.y * this$static.v11.y) + totalRadius;
  sideOffset2 = this$static.tangent.x * this$static.v12.x + this$static.tangent.y * this$static.v12.y + totalRadius;
  $negateLocal(this$static.tangent);
  np = clipSegmentToLine(this$static.clipPoints1, this$static.incidentEdge, this$static.tangent, sideOffset1, edge1);
  $negateLocal(this$static.tangent);
  if (np < 2) {
    return;
  }
  np = clipSegmentToLine(this$static.clipPoints2, this$static.clipPoints1, this$static.tangent, sideOffset2, iv2);
  if (np < 2) {
    return;
  }
  $set_12(manifold.localNormal, this$static.localNormal);
  $set_12(manifold.localPoint, this$static.planePoint);
  pointCount = 0;
  for (i = 0; i < 2; ++i) {
    separation = normalx * this$static.clipPoints2[i].v.x + normaly * this$static.clipPoints2[i].v.y - frontOffset;
    if (separation <= totalRadius) {
      cp = manifold.points[pointCount];
      out = cp.localPoint;
      px = this$static.clipPoints2[i].v.x - xf2.p.x;
      py = this$static.clipPoints2[i].v.y - xf2.p.y;
      out.x = xf2.q.c * px + xf2.q.s * py;
      out.y = -xf2.q.s * px + xf2.q.c * py;
      $set_2(cp.id_0, this$static.clipPoints2[i].id_0);
      flip && $flip(cp.id_0);
      ++pointCount;
    }
  }
  manifold.pointCount = pointCount;
}

function $edgeSeparation(poly1, xf1, edge1, poly2, xf2){
  var a, count2, dot, i, index, minDot, normal1Worldx, normal1Worldy, normal1x, normal1y, normals1, separation, v, v1x, v1y, v2x, v2y, v3, v4, vertices1, vertices2, xf1q, xf2q;
  vertices1 = poly1.m_vertices;
  normals1 = poly1.m_normals;
  count2 = poly2.m_count;
  vertices2 = poly2.m_vertices;
  xf1q = xf1.q;
  xf2q = xf2.q;
  v = normals1[edge1];
  normal1Worldx = xf1q.c * v.x - xf1q.s * v.y;
  normal1Worldy = xf1q.s * v.x + xf1q.c * v.y;
  normal1x = xf2q.c * normal1Worldx + xf2q.s * normal1Worldy;
  normal1y = -xf2q.s * normal1Worldx + xf2q.c * normal1Worldy;
  index = 0;
  minDot = 3.4028234663852886E38;
  for (i = 0; i < count2; ++i) {
    a = vertices2[i];
    dot = a.x * normal1x + a.y * normal1y;
    if (dot < minDot) {
      minDot = dot;
      index = i;
    }
  }
  v3 = vertices1[edge1];
  v1x = xf1q.c * v3.x - xf1q.s * v3.y + xf1.p.x;
  v1y = xf1q.s * v3.x + xf1q.c * v3.y + xf1.p.y;
  v4 = vertices2[index];
  v2x = xf2q.c * v4.x - xf2q.s * v4.y + xf2.p.x - v1x;
  v2y = xf2q.s * v4.x + xf2q.c * v4.y + xf2.p.y - v1y;
  separation = v2x * normal1Worldx + v2y * normal1Worldy;
  return separation;
}

function $findIncidentEdge(c, poly1, xf1, edge1, poly2, xf2){
  var b, c0, c1, count2, dot, i, i2, index, minDot, normal1x, normal1y, normals1, normals2, out, out1, tempx, tempy, v, v1, v2, vertices2, xf1q, xf2q;
  normals1 = poly1.m_normals;
  count2 = poly2.m_count;
  vertices2 = poly2.m_vertices;
  normals2 = poly2.m_normals;
  c0 = c[0];
  c1 = c[1];
  xf1q = xf1.q;
  xf2q = xf2.q;
  v = normals1[edge1];
  tempx = xf1q.c * v.x - xf1q.s * v.y;
  tempy = xf1q.s * v.x + xf1q.c * v.y;
  normal1x = xf2q.c * tempx + xf2q.s * tempy;
  normal1y = -xf2q.s * tempx + xf2q.c * tempy;
  index = 0;
  minDot = 3.4028234663852886E38;
  for (i = 0; i < count2; ++i) {
    b = normals2[i];
    dot = normal1x * b.x + normal1y * b.y;
    if (dot < minDot) {
      minDot = dot;
      index = i;
    }
  }
  i2 = index + 1 < count2?index + 1:0;
  v1 = vertices2[index];
  out = c0.v;
  out.x = xf2q.c * v1.x - xf2q.s * v1.y + xf2.p.x;
  out.y = xf2q.s * v1.x + xf2q.c * v1.y + xf2.p.y;
  c0.id_0.indexA = ~~(edge1 << 24) >> 24;
  c0.id_0.indexB = ~~(index << 24) >> 24;
  c0.id_0.typeA = 1;
  c0.id_0.typeB = 0;
  v2 = vertices2[i2];
  out1 = c1.v;
  out1.x = xf2q.c * v2.x - xf2q.s * v2.y + xf2.p.x;
  out1.y = xf2q.s * v2.x + xf2q.c * v2.y + xf2.p.y;
  c1.id_0.indexA = ~~(edge1 << 24) >> 24;
  c1.id_0.indexB = ~~(i2 << 24) >> 24;
  c1.id_0.typeA = 1;
  c1.id_0.typeB = 0;
}

function $findMaxSeparation(results, poly1, xf1, poly2, xf2){
  var bestEdge, bestSeparation, count1, dLocal1x, dLocal1y, dot, dx, dy, edge, i, increment, maxDot, nextEdge, normal, normals1, poly1centroid, poly2centroid, prevEdge, s, sNext, sPrev, xf1q, xf2q;
  count1 = poly1.m_count;
  normals1 = poly1.m_normals;
  poly1centroid = poly1.m_centroid;
  poly2centroid = poly2.m_centroid;
  xf2q = xf2.q;
  xf1q = xf1.q;
  dx = xf2q.c * poly2centroid.x - xf2q.s * poly2centroid.y + xf2.p.x;
  dy = xf2q.s * poly2centroid.x + xf2q.c * poly2centroid.y + xf2.p.y;
  dx -= xf1q.c * poly1centroid.x - xf1q.s * poly1centroid.y + xf1.p.x;
  dy -= xf1q.s * poly1centroid.x + xf1q.c * poly1centroid.y + xf1.p.y;
  dLocal1x = xf1q.c * dx + xf1q.s * dy;
  dLocal1y = -xf1q.s * dx + xf1q.c * dy;
  edge = 0;
  maxDot = -3.4028234663852886E38;
  for (i = 0; i < count1; ++i) {
    normal = normals1[i];
    dot = normal.x * dLocal1x + normal.y * dLocal1y;
    if (dot > maxDot) {
      maxDot = dot;
      edge = i;
    }
  }
  s = $edgeSeparation(poly1, xf1, edge, poly2, xf2);
  prevEdge = edge - 1 >= 0?edge - 1:count1 - 1;
  sPrev = $edgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
  nextEdge = edge + 1 < count1?edge + 1:0;
  sNext = $edgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
  if (sPrev > s && sPrev > sNext) {
    increment = -1;
    bestEdge = prevEdge;
    bestSeparation = sPrev;
  }
   else if (sNext > s) {
    increment = 1;
    bestEdge = nextEdge;
    bestSeparation = sNext;
  }
   else {
    results.edgeIndex = edge;
    results.separation = s;
    return;
  }
  for (;;) {
    increment == -1?(edge = bestEdge - 1 >= 0?bestEdge - 1:count1 - 1):(edge = bestEdge + 1 < count1?bestEdge + 1:0);
    s = $edgeSeparation(poly1, xf1, edge, poly2, xf2);
    if (s > bestSeparation) {
      bestEdge = edge;
      bestSeparation = s;
    }
     else {
      break;
    }
  }
  results.edgeIndex = bestEdge;
  results.separation = bestSeparation;
}

function $testOverlap(this$static, shapeA, indexA, shapeB, indexB, xfA, xfB){
  $set_3(this$static.input.proxyA, shapeA, indexA);
  $set_3(this$static.input.proxyB, shapeB, indexB);
  $set_10(this$static.input.transformA, xfA);
  $set_10(this$static.input.transformB, xfB);
  this$static.input.useRadii = true;
  this$static.cache.count = 0;
  $distance(this$static.pool.dist, this$static.output, this$static.cache, this$static.input);
  return this$static.output.distance < 1.1920928955078125E-6;
}

--></script>
<script><!--
function Collision_0(argPool){
  $clinit_Collision();
  this.input = new DistanceInput_0;
  this.cache = new Distance$SimplexCache_0;
  this.output = new DistanceOutput_0;
  this.temp = new Vec2_0;
  this.results1 = new Collision$EdgeResults_0;
  this.results2 = new Collision$EdgeResults_0;
  this.incidentEdge = initDim(_3Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Collision$ClipVertex, 2, 0);
  this.localTangent = new Vec2_0;
  this.localNormal = new Vec2_0;
  this.planePoint = new Vec2_0;
  this.tangent = new Vec2_0;
  this.v11 = new Vec2_0;
  this.v12 = new Vec2_0;
  this.clipPoints1 = initDim(_3Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Collision$ClipVertex, 2, 0);
  this.clipPoints2 = initDim(_3Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Collision$ClipVertex, 2, 0);
  this.Q = new Vec2_0;
  this.e = new Vec2_0;
  this.cf = new ContactID_0;
  this.e1 = new Vec2_0;
  this.P = new Vec2_0;
  this.n = new Vec2_0;
  this.collider = new Collision$EPCollider_0;
  this.incidentEdge[0] = new Collision$ClipVertex_0;
  this.incidentEdge[1] = new Collision$ClipVertex_0;
  this.clipPoints1[0] = new Collision$ClipVertex_0;
  this.clipPoints1[1] = new Collision$ClipVertex_0;
  this.clipPoints2[0] = new Collision$ClipVertex_0;
  this.clipPoints2[1] = new Collision$ClipVertex_0;
  this.pool = argPool;
}

function clipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA){
  $clinit_Collision();
  var distance0, distance1, interp, numOut, vIn0, vIn0v, vIn1, vIn1v, vOutNO;
  numOut = 0;
  vIn0 = vIn[0];
  vIn1 = vIn[1];
  vIn0v = vIn0.v;
  vIn1v = vIn1.v;
  distance0 = normal.x * vIn0v.x + normal.y * vIn0v.y - offset;
  distance1 = normal.x * vIn1v.x + normal.y * vIn1v.y - offset;
  distance0 <= 0 && $set_1(vOut[numOut++], vIn0);
  distance1 <= 0 && $set_1(vOut[numOut++], vIn1);
  if (distance0 * distance1 < 0) {
    interp = distance0 / (distance0 - distance1);
    vOutNO = vOut[numOut];
    vOutNO.v.x = vIn0v.x + interp * (vIn1v.x - vIn0v.x);
    vOutNO.v.y = vIn0v.y + interp * (vIn1v.y - vIn0v.y);
    vOutNO.id_0.indexA = ~~(vertexIndexA << 24) >> 24;
    vOutNO.id_0.indexB = vIn0.id_0.indexB;
    vOutNO.id_0.typeA = 0;
    vOutNO.id_0.typeB = 1;
    ++numOut;
  }
  return numOut;
}

defineSeed(391, 1, {}, Collision_0);
_.pool = null;
var d_0;
function $set_1(this$static, cv){
  var c, v1;
  v1 = cv.v;
  this$static.v.x = v1.x;
  this$static.v.y = v1.y;
  c = cv.id_0;
  this$static.id_0.indexA = c.indexA;
  this$static.id_0.indexB = c.indexB;
  this$static.id_0.typeA = c.typeA;
  this$static.id_0.typeB = c.typeB;
}

function Collision$ClipVertex_0(){
  this.v = new Vec2_0;
  this.id_0 = new ContactID_0;
}

defineSeed(392, 1, makeCastMap([Q$Collision$ClipVertex]), Collision$ClipVertex_0);
_.id_0 = null;
_.v = null;
function Collision$EPAxis_0(){
}

defineSeed(393, 1, {}, Collision$EPAxis_0);
_.index_0 = 0;
_.separation = 0;
_.type_0 = null;
function $clinit_Collision$EPAxis$Type(){
  $clinit_Collision$EPAxis$Type = nullMethod;
  UNKNOWN = new Collision$EPAxis$Type_0('UNKNOWN', 0);
  EDGE_A = new Collision$EPAxis$Type_0('EDGE_A', 1);
  EDGE_B = new Collision$EPAxis$Type_0('EDGE_B', 2);
  $VALUES_14 = initValues(_3Lorg_jbox2d_collision_Collision$EPAxis$Type_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Collision$EPAxis$Type, [UNKNOWN, EDGE_A, EDGE_B]);
}

function Collision$EPAxis$Type_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_15(){
  $clinit_Collision$EPAxis$Type();
  return $VALUES_14;
}

defineSeed(394, 39, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$Collision$EPAxis$Type]), Collision$EPAxis$Type_0);
var $VALUES_14, EDGE_A, EDGE_B, UNKNOWN;
function $collide(this$static, manifold, edgeA, xfA, polygonB, xfB){
  var bestIndex, bestValue, convex1, convex2, cp, hasVertex0, hasVertex3, i, i2, ie0, ie1, np, offset0, offset1, offset2, pointCount, primaryAxis, separation, value;
  mulTransToOutUnsafe(xfA, xfB, this$static.m_xf);
  mulToOutUnsafe_1(this$static.m_xf, polygonB.m_centroid, this$static.m_centroidB);
  this$static.m_v0 = edgeA.m_vertex0;
  this$static.m_v1 = edgeA.m_vertex1;
  this$static.m_v2 = edgeA.m_vertex2;
  this$static.m_v3 = edgeA.m_vertex3;
  hasVertex0 = edgeA.m_hasVertex0;
  hasVertex3 = edgeA.m_hasVertex3;
  $subLocal($set_12(this$static.edge1, this$static.m_v2), this$static.m_v1);
  $normalize_0(this$static.edge1);
  $set_11(this$static.m_normal1, this$static.edge1.y, -this$static.edge1.x);
  offset1 = dot_0(this$static.m_normal1, $subLocal($set_12(this$static.temp, this$static.m_centroidB), this$static.m_v1));
  offset0 = 0;
  offset2 = 0;
  convex1 = false;
  convex2 = false;
  if (hasVertex0) {
    $subLocal($set_12(this$static.edge0, this$static.m_v1), this$static.m_v0);
    $normalize_0(this$static.edge0);
    $set_11(this$static.m_normal0, this$static.edge0.y, -this$static.edge0.x);
    convex1 = cross(this$static.edge0, this$static.edge1) >= 0;
    offset0 = dot_0(this$static.m_normal0, $subLocal($set_12(this$static.temp, this$static.m_centroidB), this$static.m_v0));
  }
  if (hasVertex3) {
    $subLocal($set_12(this$static.edge2, this$static.m_v3), this$static.m_v2);
    $normalize_0(this$static.edge2);
    $set_11(this$static.m_normal2, this$static.edge2.y, -this$static.edge2.x);
    convex2 = cross(this$static.edge1, this$static.edge2) > 0;
    offset2 = dot_0(this$static.m_normal2, $subLocal($set_12(this$static.temp, this$static.m_centroidB), this$static.m_v2));
  }
  if (hasVertex0 && hasVertex3) {
    if (convex1 && convex2) {
      this$static.m_front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;
      if (this$static.m_front) {
        this$static.m_normal.x = this$static.m_normal1.x;
        this$static.m_normal.y = this$static.m_normal1.y;
        this$static.m_lowerLimit.x = this$static.m_normal0.x;
        this$static.m_lowerLimit.y = this$static.m_normal0.y;
        this$static.m_upperLimit.x = this$static.m_normal2.x;
        this$static.m_upperLimit.y = this$static.m_normal2.y;
      }
       else {
        this$static.m_normal.x = -this$static.m_normal1.x;
        this$static.m_normal.y = -this$static.m_normal1.y;
        this$static.m_lowerLimit.x = -this$static.m_normal1.x;
        this$static.m_lowerLimit.y = -this$static.m_normal1.y;
        this$static.m_upperLimit.x = -this$static.m_normal1.x;
        this$static.m_upperLimit.y = -this$static.m_normal1.y;
      }
    }
     else if (convex1) {
      this$static.m_front = offset0 >= 0 || offset1 >= 0 && offset2 >= 0;
      if (this$static.m_front) {
        this$static.m_normal.x = this$static.m_normal1.x;
        this$static.m_normal.y = this$static.m_normal1.y;
        this$static.m_lowerLimit.x = this$static.m_normal0.x;
        this$static.m_lowerLimit.y = this$static.m_normal0.y;
        this$static.m_upperLimit.x = this$static.m_normal1.x;
        this$static.m_upperLimit.y = this$static.m_normal1.y;
      }
       else {
        this$static.m_normal.x = -this$static.m_normal1.x;
        this$static.m_normal.y = -this$static.m_normal1.y;
        this$static.m_lowerLimit.x = -this$static.m_normal2.x;
        this$static.m_lowerLimit.y = -this$static.m_normal2.y;
        this$static.m_upperLimit.x = -this$static.m_normal1.x;
        this$static.m_upperLimit.y = -this$static.m_normal1.y;
      }
    }
     else if (convex2) {
      this$static.m_front = offset2 >= 0 || offset0 >= 0 && offset1 >= 0;
      if (this$static.m_front) {
        this$static.m_normal.x = this$static.m_normal1.x;
        this$static.m_normal.y = this$static.m_normal1.y;
        this$static.m_lowerLimit.x = this$static.m_normal1.x;
        this$static.m_lowerLimit.y = this$static.m_normal1.y;
        this$static.m_upperLimit.x = this$static.m_normal2.x;
        this$static.m_upperLimit.y = this$static.m_normal2.y;
      }
       else {
        this$static.m_normal.x = -this$static.m_normal1.x;
        this$static.m_normal.y = -this$static.m_normal1.y;
        this$static.m_lowerLimit.x = -this$static.m_normal1.x;
        this$static.m_lowerLimit.y = -this$static.m_normal1.y;
        this$static.m_upperLimit.x = -this$static.m_normal0.x;
        this$static.m_upperLimit.y = -this$static.m_normal0.y;
      }
    }
     else {
      this$static.m_front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;
      if (this$static.m_front) {
        this$static.m_normal.x = this$static.m_normal1.x;
        this$static.m_normal.y = this$static.m_normal1.y;
        this$static.m_lowerLimit.x = this$static.m_normal1.x;
        this$static.m_lowerLimit.y = this$static.m_normal1.y;
        this$static.m_upperLimit.x = this$static.m_normal1.x;
        this$static.m_upperLimit.y = this$static.m_normal1.y;
      }
       else {
        this$static.m_normal.x = -this$static.m_normal1.x;
        this$static.m_normal.y = -this$static.m_normal1.y;
        this$static.m_lowerLimit.x = -this$static.m_normal2.x;
        this$static.m_lowerLimit.y = -this$static.m_normal2.y;
        this$static.m_upperLimit.x = -this$static.m_normal0.x;
        this$static.m_upperLimit.y = -this$static.m_normal0.y;
      }
    }
  }
   else if (hasVertex0) {
    if (convex1) {
      this$static.m_front = offset0 >= 0 || offset1 >= 0;
      if (this$static.m_front) {
        this$static.m_normal.x = this$static.m_normal1.x;
        this$static.m_normal.y = this$static.m_normal1.y;
        this$static.m_lowerLimit.x = this$static.m_normal0.x;
        this$static.m_lowerLimit.y = this$static.m_normal0.y;
        this$static.m_upperLimit.x = -this$static.m_normal1.x;
        this$static.m_upperLimit.y = -this$static.m_normal1.y;
      }
       else {
        this$static.m_normal.x = -this$static.m_normal1.x;
        this$static.m_normal.y = -this$static.m_normal1.y;
        this$static.m_lowerLimit.x = this$static.m_normal1.x;
        this$static.m_lowerLimit.y = this$static.m_normal1.y;
        this$static.m_upperLimit.x = -this$static.m_normal1.x;
        this$static.m_upperLimit.y = -this$static.m_normal1.y;
      }
    }
     else {
      this$static.m_front = offset0 >= 0 && offset1 >= 0;
      if (this$static.m_front) {
        this$static.m_normal.x = this$static.m_normal1.x;
        this$static.m_normal.y = this$static.m_normal1.y;
        this$static.m_lowerLimit.x = this$static.m_normal1.x;
        this$static.m_lowerLimit.y = this$static.m_normal1.y;
        this$static.m_upperLimit.x = -this$static.m_normal1.x;
        this$static.m_upperLimit.y = -this$static.m_normal1.y;
      }
       else {
        this$static.m_normal.x = -this$static.m_normal1.x;
        this$static.m_normal.y = -this$static.m_normal1.y;
        this$static.m_lowerLimit.x = this$static.m_normal1.x;
        this$static.m_lowerLimit.y = this$static.m_normal1.y;
        this$static.m_upperLimit.x = -this$static.m_normal0.x;
        this$static.m_upperLimit.y = -this$static.m_normal0.y;
      }
    }
  }
   else if (hasVertex3) {
    if (convex2) {
      this$static.m_front = offset1 >= 0 || offset2 >= 0;
      if (this$static.m_front) {
        this$static.m_normal.x = this$static.m_normal1.x;
        this$static.m_normal.y = this$static.m_normal1.y;
        this$static.m_lowerLimit.x = -this$static.m_normal1.x;
        this$static.m_lowerLimit.y = -this$static.m_normal1.y;
        this$static.m_upperLimit.x = this$static.m_normal2.x;
        this$static.m_upperLimit.y = this$static.m_normal2.y;
      }
       else {
        this$static.m_normal.x = -this$static.m_normal1.x;
        this$static.m_normal.y = -this$static.m_normal1.y;
        this$static.m_lowerLimit.x = -this$static.m_normal1.x;
        this$static.m_lowerLimit.y = -this$static.m_normal1.y;
        this$static.m_upperLimit.x = this$static.m_normal1.x;
        this$static.m_upperLimit.y = this$static.m_normal1.y;
      }
    }
     else {
      this$static.m_front = offset1 >= 0 && offset2 >= 0;
      if (this$static.m_front) {
        this$static.m_normal.x = this$static.m_normal1.x;
        this$static.m_normal.y = this$static.m_normal1.y;
        this$static.m_lowerLimit.x = -this$static.m_normal1.x;
        this$static.m_lowerLimit.y = -this$static.m_normal1.y;
        this$static.m_upperLimit.x = this$static.m_normal1.x;
        this$static.m_upperLimit.y = this$static.m_normal1.y;
      }
       else {
        this$static.m_normal.x = -this$static.m_normal1.x;
        this$static.m_normal.y = -this$static.m_normal1.y;
        this$static.m_lowerLimit.x = -this$static.m_normal2.x;
        this$static.m_lowerLimit.y = -this$static.m_normal2.y;
        this$static.m_upperLimit.x = this$static.m_normal1.x;
        this$static.m_upperLimit.y = this$static.m_normal1.y;
      }
    }
  }
   else {
    this$static.m_front = offset1 >= 0;
    if (this$static.m_front) {
      this$static.m_normal.x = this$static.m_normal1.x;
      this$static.m_normal.y = this$static.m_normal1.y;
      this$static.m_lowerLimit.x = -this$static.m_normal1.x;
      this$static.m_lowerLimit.y = -this$static.m_normal1.y;
      this$static.m_upperLimit.x = -this$static.m_normal1.x;
      this$static.m_upperLimit.y = -this$static.m_normal1.y;
    }
     else {
      this$static.m_normal.x = -this$static.m_normal1.x;
      this$static.m_normal.y = -this$static.m_normal1.y;
      this$static.m_lowerLimit.x = this$static.m_normal1.x;
      this$static.m_lowerLimit.y = this$static.m_normal1.y;
      this$static.m_upperLimit.x = this$static.m_normal1.x;
      this$static.m_upperLimit.y = this$static.m_normal1.y;
    }
  }
  this$static.m_polygonB.count = polygonB.m_count;
  for (i = 0; i < polygonB.m_count; ++i) {
    mulToOutUnsafe_1(this$static.m_xf, polygonB.m_vertices[i], this$static.m_polygonB.vertices[i]);
    mulToOutUnsafe_0(this$static.m_xf.q, polygonB.m_normals[i], this$static.m_polygonB.normals[i]);
  }
  this$static.m_radius = 0.019999999552965164;
  manifold.pointCount = 0;
  $computeEdgeSeparation(this$static, this$static.edgeAxis);
  if (this$static.edgeAxis.type_0 == ($clinit_Collision$EPAxis$Type() , UNKNOWN)) {
    return;
  }
  if (this$static.edgeAxis.separation > this$static.m_radius) {
    return;
  }
  $computePolygonSeparation(this$static, this$static.polygonAxis);
  if (this$static.polygonAxis.type_0 != UNKNOWN && this$static.polygonAxis.separation > this$static.m_radius) {
    return;
  }
  this$static.polygonAxis.type_0 == UNKNOWN?(primaryAxis = this$static.edgeAxis):this$static.polygonAxis.separation > 0.9800000190734863 * this$static.edgeAxis.separation + 0.0010000000474974513?(primaryAxis = this$static.polygonAxis):(primaryAxis = this$static.edgeAxis);
  ie0 = this$static.ie[0];
  ie1 = this$static.ie[1];
  if (primaryAxis.type_0 == EDGE_A) {
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_A);
    bestIndex = 0;
    bestValue = dot_0(this$static.m_normal, this$static.m_polygonB.normals[0]);
    for (i = 1; i < this$static.m_polygonB.count; ++i) {
      value = dot_0(this$static.m_normal, this$static.m_polygonB.normals[i]);
      if (value < bestValue) {
        bestValue = value;
        bestIndex = i;
      }
    }
    i2 = bestIndex + 1 < this$static.m_polygonB.count?bestIndex + 1:0;
    $set_12(ie0.v, this$static.m_polygonB.vertices[bestIndex]);
    ie0.id_0.indexA = 0;
    ie0.id_0.indexB = ~~(bestIndex << 24) >> 24;
    ie0.id_0.typeA = 1;
    ie0.id_0.typeB = 0;
    $set_12(ie1.v, this$static.m_polygonB.vertices[i2]);
    ie1.id_0.indexA = 0;
    ie1.id_0.indexB = ~~(i2 << 24) >> 24;
    ie1.id_0.typeA = 1;
    ie1.id_0.typeB = 0;
    if (this$static.m_front) {
      this$static.rf.i1 = 0;
      this$static.rf.i2 = 1;
      $set_12(this$static.rf.v1, this$static.m_v1);
      $set_12(this$static.rf.v2, this$static.m_v2);
      $set_12(this$static.rf.normal, this$static.m_normal1);
    }
     else {
      this$static.rf.i1 = 1;
      this$static.rf.i2 = 0;
      $set_12(this$static.rf.v1, this$static.m_v2);
      $set_12(this$static.rf.v2, this$static.m_v1);
      $negateLocal($set_12(this$static.rf.normal, this$static.m_normal1));
    }
  }
   else {
    manifold.type_0 = ($clinit_Manifold$ManifoldType() , FACE_B);
    $set_12(ie0.v, this$static.m_v1);
    ie0.id_0.indexA = 0;
    ie0.id_0.indexB = ~~(primaryAxis.index_0 << 24) >> 24;
    ie0.id_0.typeA = 0;
    ie0.id_0.typeB = 1;
    $set_12(ie1.v, this$static.m_v2);
    ie1.id_0.indexA = 0;
    ie1.id_0.indexB = ~~(primaryAxis.index_0 << 24) >> 24;
    ie1.id_0.typeA = 0;
    ie1.id_0.typeB = 1;
    this$static.rf.i1 = primaryAxis.index_0;
    this$static.rf.i2 = this$static.rf.i1 + 1 < this$static.m_polygonB.count?this$static.rf.i1 + 1:0;
    $set_12(this$static.rf.v1, this$static.m_polygonB.vertices[this$static.rf.i1]);
    $set_12(this$static.rf.v2, this$static.m_polygonB.vertices[this$static.rf.i2]);
    $set_12(this$static.rf.normal, this$static.m_polygonB.normals[this$static.rf.i1]);
  }
  $set_11(this$static.rf.sideNormal1, this$static.rf.normal.y, -this$static.rf.normal.x);
  $negateLocal($set_12(this$static.rf.sideNormal2, this$static.rf.sideNormal1));
  this$static.rf.sideOffset1 = dot_0(this$static.rf.sideNormal1, this$static.rf.v1);
  this$static.rf.sideOffset2 = dot_0(this$static.rf.sideNormal2, this$static.rf.v2);
  np = clipSegmentToLine(this$static.clipPoints1, this$static.ie, this$static.rf.sideNormal1, this$static.rf.sideOffset1, this$static.rf.i1);
  if (np < 2) {
    return;
  }
  np = clipSegmentToLine(this$static.clipPoints2, this$static.clipPoints1, this$static.rf.sideNormal2, this$static.rf.sideOffset2, this$static.rf.i2);
  if (np < 2) {
    return;
  }
  if (primaryAxis.type_0 == EDGE_A) {
    $set_12(manifold.localNormal, this$static.rf.normal);
    $set_12(manifold.localPoint, this$static.rf.v1);
  }
   else {
    $set_12(manifold.localNormal, polygonB.m_normals[this$static.rf.i1]);
    $set_12(manifold.localPoint, polygonB.m_vertices[this$static.rf.i1]);
  }
  pointCount = 0;
  for (i = 0; i < 2; ++i) {
    separation = dot_0(this$static.rf.normal, $subLocal($set_12(this$static.temp, this$static.clipPoints2[i].v), this$static.rf.v1));
    if (separation <= this$static.m_radius) {
      cp = manifold.points[pointCount];
      if (primaryAxis.type_0 == EDGE_A) {
        mulTransToOutUnsafe_0(this$static.m_xf, this$static.clipPoints2[i].v, cp.localPoint);
        $set_2(cp.id_0, this$static.clipPoints2[i].id_0);
      }
       else {
        $set_12(cp.localPoint, this$static.clipPoints2[i].v);
        cp.id_0.typeA = this$static.clipPoints2[i].id_0.typeB;
        cp.id_0.typeB = this$static.clipPoints2[i].id_0.typeA;
        cp.id_0.indexA = this$static.clipPoints2[i].id_0.indexB;
        cp.id_0.indexB = this$static.clipPoints2[i].id_0.indexA;
      }
      ++pointCount;
    }
  }
  manifold.pointCount = pointCount;
}

function $computeEdgeSeparation(this$static, axis){
  var i, nx, ny, s, tempx, tempy, v;
  axis.type_0 = ($clinit_Collision$EPAxis$Type() , EDGE_A);
  axis.index_0 = this$static.m_front?0:1;
  axis.separation = 3.4028234663852886E38;
  nx = this$static.m_normal.x;
  ny = this$static.m_normal.y;
  for (i = 0; i < this$static.m_polygonB.count; ++i) {
    v = this$static.m_polygonB.vertices[i];
    tempx = v.x - this$static.m_v1.x;
    tempy = v.y - this$static.m_v1.y;
    s = nx * tempx + ny * tempy;
    s < axis.separation && (axis.separation = s);
  }
}

function $computePolygonSeparation(this$static, axis){
  var i, normalB, s, s1, s2, tempx, tempy, vB;
  axis.type_0 = ($clinit_Collision$EPAxis$Type() , UNKNOWN);
  axis.index_0 = -1;
  axis.separation = -3.4028234663852886E38;
  this$static.perp.x = -this$static.m_normal.y;
  this$static.perp.y = this$static.m_normal.x;
  for (i = 0; i < this$static.m_polygonB.count; ++i) {
    normalB = this$static.m_polygonB.normals[i];
    vB = this$static.m_polygonB.vertices[i];
    this$static.n.x = -normalB.x;
    this$static.n.y = -normalB.y;
    tempx = vB.x - this$static.m_v1.x;
    tempy = vB.y - this$static.m_v1.y;
    s1 = this$static.n.x * tempx + this$static.n.y * tempy;
    tempx = vB.x - this$static.m_v2.x;
    tempy = vB.y - this$static.m_v2.y;
    s2 = this$static.n.x * tempx + this$static.n.y * tempy;
    s = ($clinit_MathUtils() , s1 < s2?s1:s2);
    if (s > this$static.m_radius) {
      axis.type_0 = EDGE_B;
      axis.index_0 = i;
      axis.separation = s;
      return;
    }
    if (this$static.n.x * this$static.perp.x + this$static.n.y * this$static.perp.y >= 0) {
      if (dot_0($subLocal($set_12(this$static.temp, this$static.n), this$static.m_upperLimit), this$static.m_normal) < -0.03490658849477768) {
        continue;
      }
    }
     else {
      if (dot_0($subLocal($set_12(this$static.temp, this$static.n), this$static.m_lowerLimit), this$static.m_normal) < -0.03490658849477768) {
        continue;
      }
    }
    if (s > axis.separation) {
      axis.type_0 = EDGE_B;
      axis.index_0 = i;
      axis.separation = s;
    }
  }
}

function Collision$EPCollider_0(){
  var i;
  this.m_polygonB = new Collision$TempPolygon_0;
  this.m_xf = new Transform_0;
  this.m_centroidB = new Vec2_0;
  this.m_v0 = new Vec2_0;
  this.m_v1 = new Vec2_0;
  this.m_v2 = new Vec2_0;
  this.m_v3 = new Vec2_0;
  this.m_normal0 = new Vec2_0;
  this.m_normal1 = new Vec2_0;
  this.m_normal2 = new Vec2_0;
  this.m_normal = new Vec2_0;
  this.m_lowerLimit = new Vec2_0;
  this.m_upperLimit = new Vec2_0;
  this.edge1 = new Vec2_0;
  this.temp = new Vec2_0;
  this.edge0 = new Vec2_0;
  this.edge2 = new Vec2_0;
  this.ie = initDim(_3Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Collision$ClipVertex, 2, 0);
  this.clipPoints1 = initDim(_3Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Collision$ClipVertex, 2, 0);
  this.clipPoints2 = initDim(_3Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Collision$ClipVertex, 2, 0);
  this.rf = new Collision$ReferenceFace_0;
  this.edgeAxis = new Collision$EPAxis_0;
  this.polygonAxis = new Collision$EPAxis_0;
  this.perp = new Vec2_0;
  this.n = new Vec2_0;
  for (i = 0; i < 2; ++i) {
    this.ie[i] = new Collision$ClipVertex_0;
    this.clipPoints1[i] = new Collision$ClipVertex_0;
    this.clipPoints2[i] = new Collision$ClipVertex_0;
  }
}

defineSeed(395, 1, {}, Collision$EPCollider_0);
_.m_front = false;
_.m_radius = 0;
function Collision$EdgeResults_0(){
}

defineSeed(396, 1, {}, Collision$EdgeResults_0);
_.edgeIndex = 0;
_.separation = 0;
function Collision$ReferenceFace_0(){
  this.v1 = new Vec2_0;
  this.v2 = new Vec2_0;
  this.normal = new Vec2_0;
  this.sideNormal1 = new Vec2_0;
  this.sideNormal2 = new Vec2_0;
}

defineSeed(397, 1, {}, Collision$ReferenceFace_0);
_.i1 = 0;
_.i2 = 0;
_.sideOffset1 = 0;
_.sideOffset2 = 0;
function Collision$TempPolygon_0(){
  var i;
  this.vertices = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, 8, 0);
  this.normals = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, 8, 0);
  for (i = 0; i < this.vertices.length; ++i) {
    this.vertices[i] = new Vec2_0;
    this.normals[i] = new Vec2_0;
  }
}

defineSeed(398, 1, {}, Collision$TempPolygon_0);
_.count = 0;
function $flip(this$static){
  var tempA;
  tempA = this$static.indexA;
  this$static.indexA = this$static.indexB;
  this$static.indexB = tempA;
  tempA = this$static.typeA;
  this$static.typeA = this$static.typeB;
  this$static.typeB = tempA;
}

function $isEqual(this$static, cid){
  return (this$static.indexA << 24 | this$static.indexB << 16 | this$static.typeA << 8 | this$static.typeB) == (cid.indexA << 24 | cid.indexB << 16 | cid.typeA << 8 | cid.typeB);
}

function $set_2(this$static, c){
  this$static.indexA = c.indexA;
  this$static.indexB = c.indexB;
  this$static.typeA = c.typeA;
  this$static.typeB = c.typeB;
}

function $zero(this$static){
  this$static.indexA = 0;
  this$static.indexB = 0;
  this$static.typeA = 0;
  this$static.typeB = 0;
}

function ContactID_0(){
}

defineSeed(399, 1, makeCastMap([Q$Comparable]), ContactID_0);
_.compareTo$ = function compareTo_7(o){
  return (this.indexA << 24 | this.indexB << 16 | this.typeA << 8 | this.typeB) - (o.indexA << 24 | o.indexB << 16 | o.typeA << 8 | o.typeB);
}
;
_.indexA = 0;
_.indexB = 0;
_.typeA = 0;
_.typeB = 0;
function $distance(this$static, output, cache, input){
  var duplicate, i, iter, proxyA, proxyB, rA, rB, saveCount, transformA, transformB, vertex, vertices;
  ++GJK_CALLS;
  proxyA = input.proxyA;
  proxyB = input.proxyB;
  transformA = input.transformA;
  transformB = input.transformB;
  $readCache(this$static.simplex, cache, proxyA, transformA, proxyB, transformB);
  vertices = this$static.simplex.vertices;
  $getClosestPoint(this$static.simplex, this$static.closestPoint);
  $lengthSquared(this$static.closestPoint);
  iter = 0;
  while (iter < GJK_MAX_ITERS) {
    saveCount = this$static.simplex.m_count;
    for (i = 0; i < saveCount; ++i) {
      this$static.saveA[i] = vertices[i].indexA;
      this$static.saveB[i] = vertices[i].indexB;
    }
    switch (this$static.simplex.m_count) {
      case 2:
        $solve2(this$static.simplex);
        break;
      case 3:
        $solve3(this$static.simplex);
    }
    if (this$static.simplex.m_count == 3) {
      break;
    }
    $getClosestPoint(this$static.simplex, this$static.closestPoint);
    $lengthSquared(this$static.closestPoint);
    $getSearchDirection(this$static.simplex, this$static.d);
    if ($lengthSquared(this$static.d) < 1.4210854715202004E-14) {
      break;
    }
    vertex = vertices[this$static.simplex.m_count];
    mulTransUnsafe_0(transformA.q, $negateLocal(this$static.d), this$static.temp);
    vertex.indexA = $getSupport(proxyA, this$static.temp);
    mulToOutUnsafe_1(transformA, $getVertex(proxyA, vertex.indexA), vertex.wA);
    mulTransUnsafe_0(transformB.q, $negateLocal(this$static.d), this$static.temp);
    vertex.indexB = $getSupport(proxyB, this$static.temp);
    mulToOutUnsafe_1(transformB, $getVertex(proxyB, vertex.indexB), vertex.wB);
    $subLocal($set_12(vertex.w, vertex.wB), vertex.wA);
    ++iter;
    ++GJK_ITERS;
    duplicate = false;
    for (i = 0; i < saveCount; ++i) {
      if (vertex.indexA == this$static.saveA[i] && vertex.indexB == this$static.saveB[i]) {
        duplicate = true;
        break;
      }
    }
    if (duplicate) {
      break;
    }
    ++this$static.simplex.m_count;
  }
  GJK_MAX_ITERS = max_1(GJK_MAX_ITERS, iter);
  $getWitnessPoints(this$static.simplex, output.pointA, output.pointB);
  output.distance = ($clinit_MathUtils() , $clinit_MathUtils() , sqrt(distanceSquared(output.pointA, output.pointB)));
  $writeCache(this$static.simplex, cache);
  if (input.useRadii) {
    rA = proxyA.m_radius;
    rB = proxyB.m_radius;
    if (output.distance > rA + rB && output.distance > 1.1920928955078125E-7) {
      output.distance -= rA + rB;
      $subLocal($set_12(this$static.normal, output.pointB), output.pointA);
      $normalize_0(this$static.normal);
      $mulLocal($set_12(this$static.temp, this$static.normal), rA);
      $addLocal(output.pointA, this$static.temp);
      $mulLocal($set_12(this$static.temp, this$static.normal), rB);
      $subLocal(output.pointB, this$static.temp);
    }
     else {
      $mulLocal($addLocal(output.pointA, output.pointB), 0.5);
      $set_12(output.pointB, output.pointA);
      output.distance = 0;
    }
  }
}

function Distance_0(){
  this.simplex = new Distance$Simplex_0;
  this.saveA = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 3, 1);
  this.saveB = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 3, 1);
  this.closestPoint = new Vec2_0;
  this.d = new Vec2_0;
  this.temp = new Vec2_0;
  this.normal = new Vec2_0;
}

defineSeed(400, 1, {}, Distance_0);
var GJK_CALLS = 0, GJK_ITERS = 0, GJK_MAX_ITERS = 20;
function $getSupport(this$static, d){
  var bestIndex, bestValue, i, value;
  bestIndex = 0;
  bestValue = dot_0(this$static.m_vertices[0], d);
  for (i = 1; i < this$static.m_count; ++i) {
    value = dot_0(this$static.m_vertices[i], d);
    if (value > bestValue) {
      bestIndex = i;
      bestValue = value;
    }
  }
  return bestIndex;
}

function $getVertex(this$static, index){
  return this$static.m_vertices[index];
}

function $set_3(this$static, shape, index){
  var circle, edge, i, poly;
  switch (shape.m_type.ordinal) {
    case 0:
      circle = shape;
      $set_12(this$static.m_vertices[0], circle.m_p);
      this$static.m_count = 1;
      this$static.m_radius = circle.m_radius;
      break;
    case 2:
      poly = shape;
      this$static.m_count = poly.m_count;
      this$static.m_radius = poly.m_radius;
      for (i = 0; i < this$static.m_count; ++i) {
        $set_12(this$static.m_vertices[i], poly.m_vertices[i]);
      }

      break;
    case 3:
      this$static.m_buffer[0] = null.nullField[index];
      index + 1 < null.nullField?(this$static.m_buffer[1] = null.nullField[index + 1]):(this$static.m_buffer[1] = null.nullField[0]);
      $set_12(this$static.m_vertices[0], this$static.m_buffer[0]);
      $set_12(this$static.m_vertices[1], this$static.m_buffer[1]);
      this$static.m_count = 2;
      this$static.m_radius = null.nullField;
      break;
    case 1:
      edge = shape;
      $set_12(this$static.m_vertices[0], edge.m_vertex1);
      $set_12(this$static.m_vertices[1], edge.m_vertex2);
      this$static.m_count = 2;
      this$static.m_radius = edge.m_radius;
  }
}

--></script>
<script><!--
function Distance$DistanceProxy_0(){
  var i;
  this.m_vertices = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, 8, 0);
  for (i = 0; i < this.m_vertices.length; ++i) {
    this.m_vertices[i] = new Vec2_0;
  }
  this.m_buffer = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, 2, 0);
  this.m_count = 0;
  this.m_radius = 0;
}

defineSeed(401, 1, {}, Distance$DistanceProxy_0);
_.m_buffer = null;
_.m_count = 0;
_.m_radius = 0;
_.m_vertices = null;
function $getClosestPoint(this$static, out){
  switch (this$static.m_count) {
    case 3:
    default:case 0:
      out.x = 0;
      out.y = 0;
      return;
    case 1:
      $set_12(out, this$static.m_v1.w);
      return;
    case 2:
      $mulLocal($set_12(this$static.case22, this$static.m_v2.w), this$static.m_v2.a_0);
      $addLocal($mulLocal($set_12(this$static.case2, this$static.m_v1.w), this$static.m_v1.a_0), this$static.case22);
      $set_12(out, this$static.case2);
      return;
  }
}

function $getMetric(this$static){
  switch (this$static.m_count) {
    case 1:
    default:case 0:
      return 0;
    case 2:
      return $clinit_MathUtils() , $clinit_MathUtils() , sqrt(distanceSquared(this$static.m_v1.w, this$static.m_v2.w));
    case 3:
      $subLocal($set_12(this$static.case3, this$static.m_v2.w), this$static.m_v1.w);
      $subLocal($set_12(this$static.case33, this$static.m_v3.w), this$static.m_v1.w);
      return cross(this$static.case3, this$static.case33);
  }
}

function $getSearchDirection(this$static, out){
  var sgn;
  switch (this$static.m_count) {
    case 1:
      $negateLocal($set_12(out, this$static.m_v1.w));
      return;
    case 2:
      $subLocal($set_12(this$static.e12, this$static.m_v2.w), this$static.m_v1.w);
      $negateLocal($set_12(out, this$static.m_v1.w));
      sgn = cross(this$static.e12, out);
      if (sgn > 0) {
        crossToOutUnsafe(1, this$static.e12, out);
        return;
      }
       else {
        crossToOutUnsafe_0(this$static.e12, 1, out);
        return;
      }

    default:out.x = 0;
      out.y = 0;
      return;
  }
}

function $getWitnessPoints(this$static, pA, pB){
  switch (this$static.m_count) {
    case 1:
      $set_12(pA, this$static.m_v1.wA);
      $set_12(pB, this$static.m_v1.wB);
      break;
    case 2:
      $mulLocal($set_12(this$static.case2, this$static.m_v1.wA), this$static.m_v1.a_0);
      $addLocal($mulLocal($set_12(pA, this$static.m_v2.wA), this$static.m_v2.a_0), this$static.case2);
      $mulLocal($set_12(this$static.case2, this$static.m_v1.wB), this$static.m_v1.a_0);
      $addLocal($mulLocal($set_12(pB, this$static.m_v2.wB), this$static.m_v2.a_0), this$static.case2);
      break;
    case 3:
      $mulLocal($set_12(pA, this$static.m_v1.wA), this$static.m_v1.a_0);
      $mulLocal($set_12(this$static.case3, this$static.m_v2.wA), this$static.m_v2.a_0);
      $mulLocal($set_12(this$static.case33, this$static.m_v3.wA), this$static.m_v3.a_0);
      $addLocal($addLocal(pA, this$static.case3), this$static.case33);
      $set_12(pB, pA);
  }
}

function $readCache(this$static, cache, proxyA, transformA, proxyB, transformB){
  var i, metric1, metric2, v, wALocal, wBLocal;
  this$static.m_count = cache.count;
  for (i = 0; i < this$static.m_count; ++i) {
    v = this$static.vertices[i];
    v.indexA = cache.indexA[i];
    v.indexB = cache.indexB[i];
    wALocal = $getVertex(proxyA, v.indexA);
    wBLocal = $getVertex(proxyB, v.indexB);
    mulToOutUnsafe_1(transformA, wALocal, v.wA);
    mulToOutUnsafe_1(transformB, wBLocal, v.wB);
    $subLocal($set_12(v.w, v.wB), v.wA);
    v.a_0 = 0;
  }
  if (this$static.m_count > 1) {
    metric1 = cache.metric;
    metric2 = $getMetric(this$static);
    (metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < 1.1920928955078125E-7) && (this$static.m_count = 0);
  }
  if (this$static.m_count == 0) {
    v = this$static.vertices[0];
    v.indexA = 0;
    v.indexB = 0;
    wALocal = proxyA.m_vertices[0];
    wBLocal = proxyB.m_vertices[0];
    mulToOutUnsafe_1(transformA, wALocal, v.wA);
    mulToOutUnsafe_1(transformB, wBLocal, v.wB);
    $subLocal($set_12(v.w, v.wB), v.wA);
    this$static.m_count = 1;
  }
}

function $solve2(this$static){
  var d12_1, d12_2, inv_d12, w1, w2;
  w1 = this$static.m_v1.w;
  w2 = this$static.m_v2.w;
  $subLocal($set_12(this$static.e12, w2), w1);
  d12_2 = -dot_0(w1, this$static.e12);
  if (d12_2 <= 0) {
    this$static.m_v1.a_0 = 1;
    this$static.m_count = 1;
    return;
  }
  d12_1 = dot_0(w2, this$static.e12);
  if (d12_1 <= 0) {
    this$static.m_v2.a_0 = 1;
    this$static.m_count = 1;
    $set_4(this$static.m_v1, this$static.m_v2);
    return;
  }
  inv_d12 = 1 / (d12_1 + d12_2);
  this$static.m_v1.a_0 = d12_1 * inv_d12;
  this$static.m_v2.a_0 = d12_2 * inv_d12;
  this$static.m_count = 2;
}

function $solve3(this$static){
  var d123_1, d123_2, d123_3, d12_2, d13_2, d23_2, inv_d12, inv_d123, inv_d13, inv_d23, n123, w1e12, w1e13, w2e12, w2e23, w3e13, w3e23;
  $set_12(this$static.w1, this$static.m_v1.w);
  $set_12(this$static.w2, this$static.m_v2.w);
  $set_12(this$static.w3, this$static.m_v3.w);
  $subLocal($set_12(this$static.e12, this$static.w2), this$static.w1);
  w1e12 = dot_0(this$static.w1, this$static.e12);
  w2e12 = dot_0(this$static.w2, this$static.e12);
  d12_2 = -w1e12;
  $subLocal($set_12(this$static.e13, this$static.w3), this$static.w1);
  w1e13 = dot_0(this$static.w1, this$static.e13);
  w3e13 = dot_0(this$static.w3, this$static.e13);
  d13_2 = -w1e13;
  $subLocal($set_12(this$static.e23, this$static.w3), this$static.w2);
  w2e23 = dot_0(this$static.w2, this$static.e23);
  w3e23 = dot_0(this$static.w3, this$static.e23);
  d23_2 = -w2e23;
  n123 = cross(this$static.e12, this$static.e13);
  d123_1 = n123 * cross(this$static.w2, this$static.w3);
  d123_2 = n123 * cross(this$static.w3, this$static.w1);
  d123_3 = n123 * cross(this$static.w1, this$static.w2);
  if (d12_2 <= 0 && d13_2 <= 0) {
    this$static.m_v1.a_0 = 1;
    this$static.m_count = 1;
    return;
  }
  if (w2e12 > 0 && d12_2 > 0 && d123_3 <= 0) {
    inv_d12 = 1 / (w2e12 + d12_2);
    this$static.m_v1.a_0 = w2e12 * inv_d12;
    this$static.m_v2.a_0 = d12_2 * inv_d12;
    this$static.m_count = 2;
    return;
  }
  if (w3e13 > 0 && d13_2 > 0 && d123_2 <= 0) {
    inv_d13 = 1 / (w3e13 + d13_2);
    this$static.m_v1.a_0 = w3e13 * inv_d13;
    this$static.m_v3.a_0 = d13_2 * inv_d13;
    this$static.m_count = 2;
    $set_4(this$static.m_v2, this$static.m_v3);
    return;
  }
  if (w2e12 <= 0 && d23_2 <= 0) {
    this$static.m_v2.a_0 = 1;
    this$static.m_count = 1;
    $set_4(this$static.m_v1, this$static.m_v2);
    return;
  }
  if (w3e13 <= 0 && w3e23 <= 0) {
    this$static.m_v3.a_0 = 1;
    this$static.m_count = 1;
    $set_4(this$static.m_v1, this$static.m_v3);
    return;
  }
  if (w3e23 > 0 && d23_2 > 0 && d123_1 <= 0) {
    inv_d23 = 1 / (w3e23 + d23_2);
    this$static.m_v2.a_0 = w3e23 * inv_d23;
    this$static.m_v3.a_0 = d23_2 * inv_d23;
    this$static.m_count = 2;
    $set_4(this$static.m_v1, this$static.m_v3);
    return;
  }
  inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
  this$static.m_v1.a_0 = d123_1 * inv_d123;
  this$static.m_v2.a_0 = d123_2 * inv_d123;
  this$static.m_v3.a_0 = d123_3 * inv_d123;
  this$static.m_count = 3;
}

function $writeCache(this$static, cache){
  var i;
  cache.metric = $getMetric(this$static);
  cache.count = this$static.m_count;
  for (i = 0; i < this$static.m_count; ++i) {
    cache.indexA[i] = this$static.vertices[i].indexA;
    cache.indexB[i] = this$static.vertices[i].indexB;
  }
}

function Distance$Simplex_0(){
  this.m_v1 = new Distance$SimplexVertex_0;
  this.m_v2 = new Distance$SimplexVertex_0;
  this.m_v3 = new Distance$SimplexVertex_0;
  this.vertices = initValues(_3Lorg_jbox2d_collision_Distance$SimplexVertex_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Distance$SimplexVertex, [this.m_v1, this.m_v2, this.m_v3]);
  this.e12 = new Vec2_0;
  this.case2 = new Vec2_0;
  this.case22 = new Vec2_0;
  this.case3 = new Vec2_0;
  this.case33 = new Vec2_0;
  this.e13 = new Vec2_0;
  this.e23 = new Vec2_0;
  this.w1 = new Vec2_0;
  this.w2 = new Vec2_0;
  this.w3 = new Vec2_0;
}

defineSeed(402, 1, {}, Distance$Simplex_0);
_.m_count = 0;
function Distance$SimplexCache_0(){
  this.indexA = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 3, 1);
  this.indexB = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 3, 1);
  this.metric = 0;
  this.count = 0;
  this.indexA[0] = 2147483647;
  this.indexA[1] = 2147483647;
  this.indexA[2] = 2147483647;
  this.indexB[0] = 2147483647;
  this.indexB[1] = 2147483647;
  this.indexB[2] = 2147483647;
}

defineSeed(403, 1, {}, Distance$SimplexCache_0);
_.count = 0;
_.metric = 0;
function $set_4(this$static, sv){
  $set_12(this$static.wA, sv.wA);
  $set_12(this$static.wB, sv.wB);
  $set_12(this$static.w, sv.w);
  this$static.a_0 = sv.a_0;
  this$static.indexA = sv.indexA;
  this$static.indexB = sv.indexB;
}

function Distance$SimplexVertex_0(){
  this.wA = new Vec2_0;
  this.wB = new Vec2_0;
  this.w = new Vec2_0;
}

defineSeed(404, 1, makeCastMap([Q$Distance$SimplexVertex]), Distance$SimplexVertex_0);
_.a_0 = 0;
_.indexA = 0;
_.indexB = 0;
function DistanceInput_0(){
  this.proxyA = new Distance$DistanceProxy_0;
  this.proxyB = new Distance$DistanceProxy_0;
  this.transformA = new Transform_0;
  this.transformB = new Transform_0;
}

defineSeed(405, 1, {}, DistanceInput_0);
_.useRadii = false;
function DistanceOutput_0(){
  this.pointA = new Vec2_0;
  this.pointB = new Vec2_0;
}

defineSeed(406, 1, {}, DistanceOutput_0);
_.distance = 0;
function $set_5(this$static, cp){
  var i;
  for (i = 0; i < cp.pointCount; ++i) {
    $set_6(this$static.points[i], cp.points[i]);
  }
  this$static.type_0 = cp.type_0;
  $set_12(this$static.localNormal, cp.localNormal);
  $set_12(this$static.localPoint, cp.localPoint);
  this$static.pointCount = cp.pointCount;
}

function Manifold_0(){
  var i;
  this.points = initDim(_3Lorg_jbox2d_collision_ManifoldPoint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ManifoldPoint, 2, 0);
  for (i = 0; i < 2; ++i) {
    this.points[i] = new ManifoldPoint_0;
  }
  this.localNormal = new Vec2_0;
  this.localPoint = new Vec2_0;
  this.pointCount = 0;
}

defineSeed(407, 1, {}, Manifold_0);
_.localNormal = null;
_.localPoint = null;
_.pointCount = 0;
_.points = null;
_.type_0 = null;
function $clinit_Manifold$ManifoldType(){
  $clinit_Manifold$ManifoldType = nullMethod;
  CIRCLES = new Manifold$ManifoldType_0('CIRCLES', 0);
  FACE_A = new Manifold$ManifoldType_0('FACE_A', 1);
  FACE_B = new Manifold$ManifoldType_0('FACE_B', 2);
  $VALUES_15 = initValues(_3Lorg_jbox2d_collision_Manifold$ManifoldType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Manifold$ManifoldType, [CIRCLES, FACE_A, FACE_B]);
}

function Manifold$ManifoldType_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_16(){
  $clinit_Manifold$ManifoldType();
  return $VALUES_15;
}

defineSeed(408, 39, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$Manifold$ManifoldType]), Manifold$ManifoldType_0);
var $VALUES_15, CIRCLES, FACE_A, FACE_B;
function $set_6(this$static, cp){
  $set_12(this$static.localPoint, cp.localPoint);
  this$static.normalImpulse = cp.normalImpulse;
  this$static.tangentImpulse = cp.tangentImpulse;
  $set_2(this$static.id_0, cp.id_0);
}

function ManifoldPoint_0(){
  this.localPoint = new Vec2_0;
  this.normalImpulse = this.tangentImpulse = 0;
  this.id_0 = new ContactID_0;
}

defineSeed(409, 1, makeCastMap([Q$ManifoldPoint]), ManifoldPoint_0);
_.id_0 = null;
_.localPoint = null;
_.normalImpulse = 0;
_.tangentImpulse = 0;
function RayCastInput_0(){
  new Vec2_0;
  new Vec2_0;
}

defineSeed(410, 1, {}, RayCastInput_0);
function RayCastOutput_0(){
  new Vec2_0;
}

defineSeed(411, 1, {}, RayCastOutput_0);
function $evaluate(this$static, indexA, indexB, t){
  var separation;
  $getTransform(this$static.m_sweepA, this$static.xfa, t);
  $getTransform(this$static.m_sweepB, this$static.xfb, t);
  switch (this$static.m_type.ordinal) {
    case 0:
      {
        mulTransUnsafe_0(this$static.xfa.q, this$static.m_axis, this$static.axisA);
        mulTransUnsafe_0(this$static.xfb.q, $negateLocal(this$static.m_axis), this$static.axisB);
        $negateLocal(this$static.m_axis);
        $set_12(this$static.localPointA, $getVertex(this$static.m_proxyA, indexA));
        $set_12(this$static.localPointB, $getVertex(this$static.m_proxyB, indexB));
        mulToOutUnsafe_1(this$static.xfa, this$static.localPointA, this$static.pointA);
        mulToOutUnsafe_1(this$static.xfb, this$static.localPointB, this$static.pointB);
        separation = dot_0($subLocal(this$static.pointB, this$static.pointA), this$static.m_axis);
        return separation;
      }

    case 1:
      {
        mulToOutUnsafe_0(this$static.xfa.q, this$static.m_axis, this$static.normal);
        mulToOutUnsafe_1(this$static.xfa, this$static.m_localPoint, this$static.pointA);
        mulTransUnsafe_0(this$static.xfb.q, $negateLocal(this$static.normal), this$static.axisB);
        $negateLocal(this$static.normal);
        $set_12(this$static.localPointB, $getVertex(this$static.m_proxyB, indexB));
        mulToOutUnsafe_1(this$static.xfb, this$static.localPointB, this$static.pointB);
        separation = dot_0($subLocal(this$static.pointB, this$static.pointA), this$static.normal);
        return separation;
      }

    case 2:
      {
        mulToOutUnsafe_0(this$static.xfb.q, this$static.m_axis, this$static.normal);
        mulToOutUnsafe_1(this$static.xfb, this$static.m_localPoint, this$static.pointB);
        mulTransUnsafe_0(this$static.xfa.q, $negateLocal(this$static.normal), this$static.axisA);
        $negateLocal(this$static.normal);
        $set_12(this$static.localPointA, $getVertex(this$static.m_proxyA, indexA));
        mulToOutUnsafe_1(this$static.xfa, this$static.localPointA, this$static.pointA);
        separation = dot_0($subLocal(this$static.pointA, this$static.pointB), this$static.normal);
        return separation;
      }

    default:return 0;
  }
}

function $findMinSeparation(this$static, indexes, t){
  var separation;
  $getTransform(this$static.m_sweepA, this$static.xfa, t);
  $getTransform(this$static.m_sweepB, this$static.xfb, t);
  switch (this$static.m_type.ordinal) {
    case 0:
      {
        mulTransUnsafe_0(this$static.xfa.q, this$static.m_axis, this$static.axisA);
        mulTransUnsafe_0(this$static.xfb.q, $negateLocal(this$static.m_axis), this$static.axisB);
        $negateLocal(this$static.m_axis);
        indexes[0] = $getSupport(this$static.m_proxyA, this$static.axisA);
        indexes[1] = $getSupport(this$static.m_proxyB, this$static.axisB);
        $set_12(this$static.localPointA, $getVertex(this$static.m_proxyA, indexes[0]));
        $set_12(this$static.localPointB, $getVertex(this$static.m_proxyB, indexes[1]));
        mulToOutUnsafe_1(this$static.xfa, this$static.localPointA, this$static.pointA);
        mulToOutUnsafe_1(this$static.xfb, this$static.localPointB, this$static.pointB);
        separation = dot_0($subLocal(this$static.pointB, this$static.pointA), this$static.m_axis);
        return separation;
      }

    case 1:
      {
        mulToOutUnsafe_0(this$static.xfa.q, this$static.m_axis, this$static.normal);
        mulToOutUnsafe_1(this$static.xfa, this$static.m_localPoint, this$static.pointA);
        mulTransUnsafe_0(this$static.xfb.q, $negateLocal(this$static.normal), this$static.axisB);
        $negateLocal(this$static.normal);
        indexes[0] = -1;
        indexes[1] = $getSupport(this$static.m_proxyB, this$static.axisB);
        $set_12(this$static.localPointB, $getVertex(this$static.m_proxyB, indexes[1]));
        mulToOutUnsafe_1(this$static.xfb, this$static.localPointB, this$static.pointB);
        separation = dot_0($subLocal(this$static.pointB, this$static.pointA), this$static.normal);
        return separation;
      }

    case 2:
      {
        mulToOutUnsafe_0(this$static.xfb.q, this$static.m_axis, this$static.normal);
        mulToOutUnsafe_1(this$static.xfb, this$static.m_localPoint, this$static.pointB);
        mulTransUnsafe_0(this$static.xfa.q, $negateLocal(this$static.normal), this$static.axisA);
        $negateLocal(this$static.normal);
        indexes[1] = -1;
        indexes[0] = $getSupport(this$static.m_proxyA, this$static.axisA);
        $set_12(this$static.localPointA, $getVertex(this$static.m_proxyA, indexes[0]));
        mulToOutUnsafe_1(this$static.xfa, this$static.localPointA, this$static.pointA);
        separation = dot_0($subLocal(this$static.pointA, this$static.pointB), this$static.normal);
        return separation;
      }

    default:indexes[0] = -1;
      indexes[1] = -1;
      return 0;
  }
}

function $initialize(this$static, cache, proxyA, sweepA, proxyB, sweepB, t1){
  var count, s;
  this$static.m_proxyA = proxyA;
  this$static.m_proxyB = proxyB;
  count = cache.count;
  this$static.m_sweepA = sweepA;
  this$static.m_sweepB = sweepB;
  $getTransform(this$static.m_sweepA, this$static.xfa, t1);
  $getTransform(this$static.m_sweepB, this$static.xfb, t1);
  if (count == 1) {
    this$static.m_type = ($clinit_Type() , POINTS);
    $set_12(this$static.localPointA, $getVertex(this$static.m_proxyA, cache.indexA[0]));
    $set_12(this$static.localPointB, $getVertex(this$static.m_proxyB, cache.indexB[0]));
    mulToOutUnsafe_1(this$static.xfa, this$static.localPointA, this$static.pointA);
    mulToOutUnsafe_1(this$static.xfb, this$static.localPointB, this$static.pointB);
    $subLocal($set_12(this$static.m_axis, this$static.pointB), this$static.pointA);
    s = $normalize_0(this$static.m_axis);
    return s;
  }
   else if (cache.indexA[0] == cache.indexA[1]) {
    this$static.m_type = ($clinit_Type() , FACE_B_0);
    $set_12(this$static.localPointB1, $getVertex(this$static.m_proxyB, cache.indexB[0]));
    $set_12(this$static.localPointB2, $getVertex(this$static.m_proxyB, cache.indexB[1]));
    $subLocal($set_12(this$static.temp, this$static.localPointB2), this$static.localPointB1);
    crossToOutUnsafe_0(this$static.temp, 1, this$static.m_axis);
    $normalize_0(this$static.m_axis);
    mulToOutUnsafe_0(this$static.xfb.q, this$static.m_axis, this$static.normal);
    $mulLocal($addLocal($set_12(this$static.m_localPoint, this$static.localPointB1), this$static.localPointB2), 0.5);
    mulToOutUnsafe_1(this$static.xfb, this$static.m_localPoint, this$static.pointB);
    $set_12(this$static.localPointA, $getVertex(proxyA, cache.indexA[0]));
    mulToOutUnsafe_1(this$static.xfa, this$static.localPointA, this$static.pointA);
    $subLocal($set_12(this$static.temp, this$static.pointA), this$static.pointB);
    s = dot_0(this$static.temp, this$static.normal);
    if (s < 0) {
      $negateLocal(this$static.m_axis);
      s = -s;
    }
    return s;
  }
   else {
    this$static.m_type = ($clinit_Type() , FACE_A_0);
    $set_12(this$static.localPointA1, $getVertex(this$static.m_proxyA, cache.indexA[0]));
    $set_12(this$static.localPointA2, $getVertex(this$static.m_proxyA, cache.indexA[1]));
    $subLocal($set_12(this$static.temp, this$static.localPointA2), this$static.localPointA1);
    crossToOutUnsafe_0(this$static.temp, 1, this$static.m_axis);
    $normalize_0(this$static.m_axis);
    mulToOutUnsafe_0(this$static.xfa.q, this$static.m_axis, this$static.normal);
    $mulLocal($addLocal($set_12(this$static.m_localPoint, this$static.localPointA1), this$static.localPointA2), 0.5);
    mulToOutUnsafe_1(this$static.xfa, this$static.m_localPoint, this$static.pointA);
    $set_12(this$static.localPointB, $getVertex(this$static.m_proxyB, cache.indexB[0]));
    mulToOutUnsafe_1(this$static.xfb, this$static.localPointB, this$static.pointB);
    $subLocal($set_12(this$static.temp, this$static.pointB), this$static.pointA);
    s = dot_0(this$static.temp, this$static.normal);
    if (s < 0) {
      $negateLocal(this$static.m_axis);
      s = -s;
    }
    return s;
  }
}

function SeparationFunction_0(){
  this.m_localPoint = new Vec2_0;
  this.m_axis = new Vec2_0;
  this.localPointA = new Vec2_0;
  this.localPointB = new Vec2_0;
  this.pointA = new Vec2_0;
  this.pointB = new Vec2_0;
  this.localPointA1 = new Vec2_0;
  this.localPointA2 = new Vec2_0;
  this.normal = new Vec2_0;
  this.localPointB1 = new Vec2_0;
  this.localPointB2 = new Vec2_0;
  this.temp = new Vec2_0;
  this.xfa = new Transform_0;
  this.xfb = new Transform_0;
  this.axisA = new Vec2_0;
  this.axisB = new Vec2_0;
}

defineSeed(412, 1, {}, SeparationFunction_0);
_.m_proxyA = null;
_.m_proxyB = null;
_.m_sweepA = null;
_.m_sweepB = null;
_.m_type = null;
function $timeOfImpact(this$static, output, input){
  var a1, a2, done, iter, proxyA, proxyB, pushBackIter, rootIterCount, s, s1, s2, t, t1, t2, tMax, target, totalRadius;
  ++toiCalls;
  output.state = ($clinit_TimeOfImpact$TOIOutputState() , UNKNOWN_0);
  output.t = input.tMax;
  proxyA = input.proxyA;
  proxyB = input.proxyB;
  $set_9(this$static.sweepA, input.sweepA);
  $set_9(this$static.sweepB, input.sweepB);
  $normalize(this$static.sweepA);
  $normalize(this$static.sweepB);
  tMax = input.tMax;
  totalRadius = proxyA.m_radius + proxyB.m_radius;
  target = ($clinit_MathUtils() , 0.004999999888241291 > totalRadius - 0.014999999664723873?0.004999999888241291:totalRadius - 0.014999999664723873);
  t1 = 0;
  iter = 0;
  this$static.cache.count = 0;
  this$static.distanceInput.proxyA = input.proxyA;
  this$static.distanceInput.proxyB = input.proxyB;
  this$static.distanceInput.useRadii = false;
  for (;;) {
    $getTransform(this$static.sweepA, this$static.xfA, t1);
    $getTransform(this$static.sweepB, this$static.xfB, t1);
    this$static.distanceInput.transformA = this$static.xfA;
    this$static.distanceInput.transformB = this$static.xfB;
    $distance(this$static.pool.dist, this$static.distanceOutput, this$static.cache, this$static.distanceInput);
    if (this$static.distanceOutput.distance <= 0) {
      output.state = OVERLAPPED;
      output.t = 0;
      break;
    }
    if (this$static.distanceOutput.distance < target + 0.0012499999720603228) {
      output.state = TOUCHING;
      output.t = t1;
      break;
    }
    $initialize(this$static.fcn, this$static.cache, proxyA, this$static.sweepA, proxyB, this$static.sweepB, t1);
    done = false;
    t2 = tMax;
    pushBackIter = 0;
    for (;;) {
      s2 = $findMinSeparation(this$static.fcn, this$static.indexes, t2);
      if (s2 > target + 0.0012499999720603228) {
        output.state = SEPARATED;
        output.t = tMax;
        done = true;
        break;
      }
      if (s2 > target - 0.0012499999720603228) {
        t1 = t2;
        break;
      }
      s1 = $evaluate(this$static.fcn, this$static.indexes[0], this$static.indexes[1], t1);
      if (s1 < target - 0.0012499999720603228) {
        output.state = FAILED;
        output.t = t1;
        done = true;
        break;
      }
      if (s1 <= target + 0.0012499999720603228) {
        output.state = TOUCHING;
        output.t = t1;
        done = true;
        break;
      }
      rootIterCount = 0;
      a1 = t1;
      a2 = t2;
      for (;;) {
        (rootIterCount & 1) == 1?(t = a1 + (target - s1) * (a2 - a1) / (s2 - s1)):(t = 0.5 * (a1 + a2));
        s = $evaluate(this$static.fcn, this$static.indexes[0], this$static.indexes[1], t);
        if (($clinit_Settings() , s - target > 0?s - target:-(s - target)) < 0.0012499999720603228) {
          t2 = t;
          break;
        }
        if (s > target) {
          a1 = t;
          s1 = s;
        }
         else {
          a2 = t;
          s2 = s;
        }
        ++rootIterCount;
        ++toiRootIters;
        if (rootIterCount == 50) {
          break;
        }
      }
      toiMaxRootIters = max_1(toiMaxRootIters, rootIterCount);
      ++pushBackIter;
      if (pushBackIter == 8) {
        break;
      }
    }
    ++iter;
    ++toiIters;
    if (done) {
      break;
    }
    if (iter == 1000) {
      output.state = FAILED;
      output.t = t1;
      break;
    }
  }
  toiMaxIters = max_1(toiMaxIters, iter);
}

function TimeOfImpact_0(argPool){
  this.cache = new Distance$SimplexCache_0;
  this.distanceInput = new DistanceInput_0;
  this.xfA = new Transform_0;
  this.xfB = new Transform_0;
  this.distanceOutput = new DistanceOutput_0;
  this.fcn = new SeparationFunction_0;
  this.indexes = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 2, 1);
  this.sweepA = new Sweep_0;
  this.sweepB = new Sweep_0;
  this.pool = argPool;
}

defineSeed(413, 1, {}, TimeOfImpact_0);
_.pool = null;
var toiCalls = 0, toiIters = 0, toiMaxIters = 0, toiMaxRootIters = 0, toiRootIters = 0;
function TimeOfImpact$TOIInput_0(){
  this.proxyA = new Distance$DistanceProxy_0;
  this.proxyB = new Distance$DistanceProxy_0;
  this.sweepA = new Sweep_0;
  this.sweepB = new Sweep_0;
}

defineSeed(414, 1, {}, TimeOfImpact$TOIInput_0);
_.tMax = 0;
function TimeOfImpact$TOIOutput_0(){
}

defineSeed(415, 1, {}, TimeOfImpact$TOIOutput_0);
_.state = null;
_.t = 0;
function $clinit_TimeOfImpact$TOIOutputState(){
  $clinit_TimeOfImpact$TOIOutputState = nullMethod;
  UNKNOWN_0 = new TimeOfImpact$TOIOutputState_0('UNKNOWN', 0);
  FAILED = new TimeOfImpact$TOIOutputState_0('FAILED', 1);
  OVERLAPPED = new TimeOfImpact$TOIOutputState_0('OVERLAPPED', 2);
  TOUCHING = new TimeOfImpact$TOIOutputState_0('TOUCHING', 3);
  SEPARATED = new TimeOfImpact$TOIOutputState_0('SEPARATED', 4);
  $VALUES_16 = initValues(_3Lorg_jbox2d_collision_TimeOfImpact$TOIOutputState_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$TimeOfImpact$TOIOutputState, [UNKNOWN_0, FAILED, OVERLAPPED, TOUCHING, SEPARATED]);
}

function TimeOfImpact$TOIOutputState_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_17(){
  $clinit_TimeOfImpact$TOIOutputState();
  return $VALUES_16;
}

defineSeed(416, 39, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TimeOfImpact$TOIOutputState]), TimeOfImpact$TOIOutputState_0);
var $VALUES_16, FAILED, OVERLAPPED, SEPARATED, TOUCHING, UNKNOWN_0;
function $clinit_Type(){
  $clinit_Type = nullMethod;
  POINTS = new Type_0('POINTS', 0);
  FACE_A_0 = new Type_0('FACE_A', 1);
  FACE_B_0 = new Type_0('FACE_B', 2);
  $VALUES_17 = initValues(_3Lorg_jbox2d_collision_Type_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Type, [POINTS, FACE_A_0, FACE_B_0]);
}

function Type_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_18(){
  $clinit_Type();
  return $VALUES_17;
}

defineSeed(417, 39, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$Type]), Type_0);
var $VALUES_17, FACE_A_0, FACE_B_0, POINTS;
function $initialize_0(this$static, manifold, xfA, radiusA, xfB, radiusB){
  var cAx, cAy, cBx, cBy, clipPoint, i, planePoint, pointA, pointB, scalar;
  if (manifold.pointCount == 0) {
    return;
  }
  switch (manifold.type_0.ordinal) {
    case 0:
      {
        pointA = this$static.pool3;
        pointB = this$static.pool4;
        this$static.normal.x = 1;
        this$static.normal.y = 0;
        mulToOut(xfA, manifold.localPoint, pointA);
        mulToOut(xfB, manifold.points[0].localPoint, pointB);
        if (distanceSquared(pointA, pointB) > 1.4210854715202004E-14) {
          this$static.normal.x = pointB.x - pointA.x;
          this$static.normal.y = pointB.y - pointA.y;
          $normalize_0(this$static.normal);
        }
        cAx = this$static.normal.x * radiusA + pointA.x;
        cAy = this$static.normal.y * radiusA + pointA.y;
        cBx = -this$static.normal.x * radiusB + pointB.x;
        cBy = -this$static.normal.y * radiusB + pointB.y;
        this$static.points[0].x = (cAx + cBx) * 0.5;
        this$static.points[0].y = (cAy + cBy) * 0.5;
      }

      break;
    case 1:
      {
        planePoint = this$static.pool3;
        mulToOutUnsafe_0(xfA.q, manifold.localNormal, this$static.normal);
        mulToOut(xfA, manifold.localPoint, planePoint);
        clipPoint = this$static.pool4;
        for (i = 0; i < manifold.pointCount; ++i) {
          mulToOut(xfB, manifold.points[i].localPoint, clipPoint);
          scalar = radiusA - ((clipPoint.x - planePoint.x) * this$static.normal.x + (clipPoint.y - planePoint.y) * this$static.normal.y);
          cAx = this$static.normal.x * scalar + clipPoint.x;
          cAy = this$static.normal.y * scalar + clipPoint.y;
          cBx = -this$static.normal.x * radiusB + clipPoint.x;
          cBy = -this$static.normal.y * radiusB + clipPoint.y;
          this$static.points[i].x = (cAx + cBx) * 0.5;
          this$static.points[i].y = (cAy + cBy) * 0.5;
        }
      }

      break;
    case 2:
      planePoint = this$static.pool3;
      mulToOutUnsafe_0(xfB.q, manifold.localNormal, this$static.normal);
      mulToOut(xfB, manifold.localPoint, planePoint);
      clipPoint = this$static.pool4;
      for (i = 0; i < manifold.pointCount; ++i) {
        mulToOut(xfA, manifold.points[i].localPoint, clipPoint);
        scalar = radiusB - ((clipPoint.x - planePoint.x) * this$static.normal.x + (clipPoint.y - planePoint.y) * this$static.normal.y);
        cBx = this$static.normal.x * scalar + clipPoint.x;
        cBy = this$static.normal.y * scalar + clipPoint.y;
        cAx = -this$static.normal.x * radiusA + clipPoint.x;
        cAy = -this$static.normal.y * radiusA + clipPoint.y;
        this$static.points[i].x = (cAx + cBx) * 0.5;
        this$static.points[i].y = (cAy + cBy) * 0.5;
      }

      this$static.normal.x = -this$static.normal.x;
      this$static.normal.y = -this$static.normal.y;
  }
}

--></script>
<script><!--
function WorldManifold_0(){
  var i;
  this.pool3 = new Vec2_0;
  this.pool4 = new Vec2_0;
  this.normal = new Vec2_0;
  this.points = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, 2, 0);
  for (i = 0; i < 2; ++i) {
    this.points[i] = new Vec2_0;
  }
}

defineSeed(418, 1, {}, WorldManifold_0);
_.normal = null;
_.points = null;
function $bufferMove(this$static, proxyId){
  var old;
  if (this$static.m_moveCount == this$static.m_moveCapacity) {
    old = this$static.m_moveBuffer;
    this$static.m_moveCapacity *= 2;
    this$static.m_moveBuffer = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, this$static.m_moveCapacity, 1);
    arraycopy(old, 0, this$static.m_moveBuffer, 0, old.length);
  }
  this$static.m_moveBuffer[this$static.m_moveCount] = proxyId;
  ++this$static.m_moveCount;
}

function $createProxy(this$static, aabb, userData){
  var proxyId;
  proxyId = $createProxy_0(this$static.m_tree, aabb, userData);
  ++this$static.m_proxyCount;
  $bufferMove(this$static, proxyId);
  return proxyId;
}

function $destroyProxy(this$static, proxyId){
  $unbufferMove(this$static, proxyId);
  --this$static.m_proxyCount;
  $destroyProxy_0(this$static.m_tree, proxyId);
}

function $moveProxy(this$static, proxyId, aabb, displacement){
  var buffer;
  buffer = $moveProxy_0(this$static.m_tree, proxyId, aabb, displacement);
  buffer && $bufferMove(this$static, proxyId);
}

function $testOverlap_0(this$static, proxyIdA, proxyIdB){
  var a, b;
  a = $getFatAABB(this$static.m_tree, proxyIdA);
  b = $getFatAABB(this$static.m_tree, proxyIdB);
  if (b.lowerBound.x - a.upperBound.x > 0 || b.lowerBound.y - a.upperBound.y > 0) {
    return false;
  }
  if (a.lowerBound.x - b.upperBound.x > 0 || a.lowerBound.y - b.upperBound.y > 0) {
    return false;
  }
  return true;
}

function $treeCallback(this$static, proxyId){
  var i, oldBuffer;
  if (proxyId == this$static.m_queryProxyId) {
    return true;
  }
  if (this$static.m_pairCount == this$static.m_pairCapacity) {
    oldBuffer = this$static.m_pairBuffer;
    this$static.m_pairCapacity *= 2;
    this$static.m_pairBuffer = initDim(_3Lorg_jbox2d_collision_broadphase_Pair_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Pair, this$static.m_pairCapacity, 0);
    arraycopy(oldBuffer, 0, this$static.m_pairBuffer, 0, oldBuffer.length);
    for (i = oldBuffer.length; i < this$static.m_pairCapacity; ++i) {
      this$static.m_pairBuffer[i] = new Pair_0;
    }
  }
  if (proxyId < this$static.m_queryProxyId) {
    this$static.m_pairBuffer[this$static.m_pairCount].proxyIdA = proxyId;
    this$static.m_pairBuffer[this$static.m_pairCount].proxyIdB = this$static.m_queryProxyId;
  }
   else {
    this$static.m_pairBuffer[this$static.m_pairCount].proxyIdA = this$static.m_queryProxyId;
    this$static.m_pairBuffer[this$static.m_pairCount].proxyIdB = proxyId;
  }
  ++this$static.m_pairCount;
  return true;
}

function $unbufferMove(this$static, proxyId){
  var i;
  for (i = 0; i < this$static.m_moveCount; ++i) {
    this$static.m_moveBuffer[i] == proxyId && (this$static.m_moveBuffer[i] = -1);
  }
}

function $updatePairs(this$static, callback){
  var fatAABB, i, pair, primaryPair, userDataA, userDataB;
  this$static.m_pairCount = 0;
  for (i = 0; i < this$static.m_moveCount; ++i) {
    this$static.m_queryProxyId = this$static.m_moveBuffer[i];
    if (this$static.m_queryProxyId == -1) {
      continue;
    }
    fatAABB = $getFatAABB(this$static.m_tree, this$static.m_queryProxyId);
    $query(this$static.m_tree, this$static, fatAABB);
  }
  this$static.m_moveCount = 0;
  mergeSort(this$static.m_pairBuffer, 0, this$static.m_pairCount);
  i = 0;
  while (i < this$static.m_pairCount) {
    primaryPair = this$static.m_pairBuffer[i];
    userDataA = $getUserData(this$static.m_tree, primaryPair.proxyIdA);
    userDataB = $getUserData(this$static.m_tree, primaryPair.proxyIdB);
    $addPair(callback, userDataA, userDataB);
    ++i;
    while (i < this$static.m_pairCount) {
      pair = this$static.m_pairBuffer[i];
      if (pair.proxyIdA != primaryPair.proxyIdA || pair.proxyIdB != primaryPair.proxyIdB) {
        break;
      }
      ++i;
    }
  }
}

function BroadPhase_0(strategy){
  var i;
  this.m_proxyCount = 0;
  this.m_pairCapacity = 16;
  this.m_pairCount = 0;
  this.m_pairBuffer = initDim(_3Lorg_jbox2d_collision_broadphase_Pair_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Pair, this.m_pairCapacity, 0);
  for (i = 0; i < this.m_pairCapacity; ++i) {
    this.m_pairBuffer[i] = new Pair_0;
  }
  this.m_moveCapacity = 16;
  this.m_moveCount = 0;
  this.m_moveBuffer = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, this.m_moveCapacity, 1);
  this.m_tree = strategy;
  this.m_queryProxyId = -1;
}

defineSeed(419, 1, {}, BroadPhase_0);
_.m_moveBuffer = null;
_.m_moveCapacity = 0;
_.m_moveCount = 0;
_.m_pairBuffer = null;
_.m_pairCapacity = 0;
_.m_pairCount = 0;
_.m_proxyCount = 0;
_.m_queryProxyId = 0;
_.m_tree = null;
function $allocateNode(this$static){
  var i, nodeId, old, treeNode;
  if (this$static.m_freeList == -1) {
    old = this$static.m_nodes;
    this$static.m_nodeCapacity *= 2;
    this$static.m_nodes = initDim(_3Lorg_jbox2d_collision_broadphase_DynamicTreeNode_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$DynamicTreeNode, this$static.m_nodeCapacity, 0);
    arraycopy(old, 0, this$static.m_nodes, 0, old.length);
    for (i = this$static.m_nodeCapacity - 1; i >= this$static.m_nodeCount; --i) {
      this$static.m_nodes[i] = new DynamicTreeNode_0(i);
      this$static.m_nodes[i].parent_0 = i == this$static.m_nodeCapacity - 1?null:this$static.m_nodes[i + 1];
      this$static.m_nodes[i].height_0 = -1;
    }
    this$static.m_freeList = this$static.m_nodeCount;
  }
  nodeId = this$static.m_freeList;
  treeNode = this$static.m_nodes[nodeId];
  this$static.m_freeList = treeNode.parent_0?treeNode.parent_0.id_0:-1;
  treeNode.parent_0 = null;
  treeNode.child1 = null;
  treeNode.child2 = null;
  treeNode.height_0 = 0;
  treeNode.userData = null;
  ++this$static.m_nodeCount;
  return treeNode;
}

function $balance(this$static, iA){
  var balance, iB, iC, iD, iE, iF, iG;
  if (!iA.child1 || iA.height_0 < 2) {
    return iA;
  }
  iB = iA.child1;
  iC = iA.child2;
  balance = iC.height_0 - iB.height_0;
  if (balance > 1) {
    iF = iC.child1;
    iG = iC.child2;
    iC.child1 = iA;
    iC.parent_0 = iA.parent_0;
    iA.parent_0 = iC;
    iC.parent_0?iC.parent_0.child1 == iA?(iC.parent_0.child1 = iC):(iC.parent_0.child2 = iC):(this$static.m_root = iC);
    if (iF.height_0 > iG.height_0) {
      iC.child2 = iF;
      iA.child2 = iG;
      iG.parent_0 = iA;
      $combine(iA.aabb, iB.aabb, iG.aabb);
      $combine(iC.aabb, iA.aabb, iF.aabb);
      iA.height_0 = 1 + max_1(iB.height_0, iG.height_0);
      iC.height_0 = 1 + max_1(iA.height_0, iF.height_0);
    }
     else {
      iC.child2 = iG;
      iA.child2 = iF;
      iF.parent_0 = iA;
      $combine(iA.aabb, iB.aabb, iF.aabb);
      $combine(iC.aabb, iA.aabb, iG.aabb);
      iA.height_0 = 1 + max_1(iB.height_0, iF.height_0);
      iC.height_0 = 1 + max_1(iA.height_0, iG.height_0);
    }
    return iC;
  }
  if (balance < -1) {
    iD = iB.child1;
    iE = iB.child2;
    iB.child1 = iA;
    iB.parent_0 = iA.parent_0;
    iA.parent_0 = iB;
    iB.parent_0?iB.parent_0.child1 == iA?(iB.parent_0.child1 = iB):(iB.parent_0.child2 = iB):(this$static.m_root = iB);
    if (iD.height_0 > iE.height_0) {
      iB.child2 = iD;
      iA.child1 = iE;
      iE.parent_0 = iA;
      $combine(iA.aabb, iC.aabb, iE.aabb);
      $combine(iB.aabb, iA.aabb, iD.aabb);
      iA.height_0 = 1 + max_1(iC.height_0, iE.height_0);
      iB.height_0 = 1 + max_1(iA.height_0, iD.height_0);
    }
     else {
      iB.child2 = iE;
      iA.child1 = iD;
      iD.parent_0 = iA;
      $combine(iA.aabb, iC.aabb, iD.aabb);
      $combine(iB.aabb, iA.aabb, iE.aabb);
      iA.height_0 = 1 + max_1(iC.height_0, iD.height_0);
      iB.height_0 = 1 + max_1(iA.height_0, iE.height_0);
    }
    return iB;
  }
  return iA;
}

function $createProxy_0(this$static, aabb, userData){
  var node, nodeAABB, proxyId;
  node = $allocateNode(this$static);
  proxyId = node.id_0;
  nodeAABB = node.aabb;
  nodeAABB.lowerBound.x = aabb.lowerBound.x - 0.10000000149011612;
  nodeAABB.lowerBound.y = aabb.lowerBound.y - 0.10000000149011612;
  nodeAABB.upperBound.x = aabb.upperBound.x + 0.10000000149011612;
  nodeAABB.upperBound.y = aabb.upperBound.y + 0.10000000149011612;
  node.userData = userData;
  $insertLeaf(this$static, proxyId);
  return proxyId;
}

function $destroyProxy_0(this$static, proxyId){
  var node;
  node = this$static.m_nodes[proxyId];
  $removeLeaf(this$static, node);
  $freeNode(this$static, node);
}

function $freeNode(this$static, node){
  node.parent_0 = this$static.m_freeList != -1?this$static.m_nodes[this$static.m_freeList]:null;
  node.height_0 = -1;
  this$static.m_freeList = node.id_0;
  --this$static.m_nodeCount;
}

function $getFatAABB(this$static, proxyId){
  return this$static.m_nodes[proxyId].aabb;
}

function $getUserData(this$static, proxyId){
  return this$static.m_nodes[proxyId].userData;
}

function $insertLeaf(this$static, leaf_index){
  var area, child1, child2, combinedArea, cost, cost1, cost2, index, inheritanceCost, leaf, leafAABB, newArea, newParent, oldArea, oldParent;
  ++this$static.m_insertionCount;
  leaf = this$static.m_nodes[leaf_index];
  if (!this$static.m_root) {
    this$static.m_root = leaf;
    this$static.m_root.parent_0 = null;
    return;
  }
  leafAABB = leaf.aabb;
  index = this$static.m_root;
  while (index.child1) {
    child1 = index.child1;
    child2 = index.child2;
    area = $getPerimeter(index.aabb);
    $combine(this$static.combinedAABB, index.aabb, leafAABB);
    combinedArea = $getPerimeter(this$static.combinedAABB);
    cost = 2 * combinedArea;
    inheritanceCost = 2 * (combinedArea - area);
    if (!child1.child1) {
      $combine(this$static.combinedAABB, leafAABB, child1.aabb);
      cost1 = $getPerimeter(this$static.combinedAABB) + inheritanceCost;
    }
     else {
      $combine(this$static.combinedAABB, leafAABB, child1.aabb);
      oldArea = $getPerimeter(child1.aabb);
      newArea = $getPerimeter(this$static.combinedAABB);
      cost1 = newArea - oldArea + inheritanceCost;
    }
    if (!child2.child1) {
      $combine(this$static.combinedAABB, leafAABB, child2.aabb);
      cost2 = $getPerimeter(this$static.combinedAABB) + inheritanceCost;
    }
     else {
      $combine(this$static.combinedAABB, leafAABB, child2.aabb);
      oldArea = $getPerimeter(child2.aabb);
      newArea = $getPerimeter(this$static.combinedAABB);
      cost2 = newArea - oldArea + inheritanceCost;
    }
    if (cost < cost1 && cost < cost2) {
      break;
    }
    cost1 < cost2?(index = child1):(index = child2);
  }
  oldParent = this$static.m_nodes[index.id_0].parent_0;
  newParent = $allocateNode(this$static);
  newParent.parent_0 = oldParent;
  newParent.userData = null;
  $combine(newParent.aabb, leafAABB, index.aabb);
  newParent.height_0 = index.height_0 + 1;
  if (oldParent) {
    oldParent.child1 == index?(oldParent.child1 = newParent):(oldParent.child2 = newParent);
    newParent.child1 = index;
    newParent.child2 = leaf;
    index.parent_0 = newParent;
    leaf.parent_0 = newParent;
  }
   else {
    newParent.child1 = index;
    newParent.child2 = leaf;
    index.parent_0 = newParent;
    leaf.parent_0 = newParent;
    this$static.m_root = newParent;
  }
  index = leaf.parent_0;
  while (index) {
    index = $balance(this$static, index);
    child1 = index.child1;
    child2 = index.child2;
    index.height_0 = 1 + max_1(child1.height_0, child2.height_0);
    $combine(index.aabb, child1.aabb, child2.aabb);
    index = index.parent_0;
  }
}

function $moveProxy_0(this$static, proxyId, aabb, displacement){
  var dx, dy, lowerBound, node, nodeAABB, upperBound;
  node = this$static.m_nodes[proxyId];
  nodeAABB = node.aabb;
  if (nodeAABB.lowerBound.x > aabb.lowerBound.x && nodeAABB.lowerBound.y > aabb.lowerBound.y && aabb.upperBound.x > nodeAABB.upperBound.x && aabb.upperBound.y > nodeAABB.upperBound.y) {
    return false;
  }
  $removeLeaf(this$static, node);
  lowerBound = nodeAABB.lowerBound;
  upperBound = nodeAABB.upperBound;
  lowerBound.x = aabb.lowerBound.x - 0.10000000149011612;
  lowerBound.y = aabb.lowerBound.y - 0.10000000149011612;
  upperBound.x = aabb.upperBound.x + 0.10000000149011612;
  upperBound.y = aabb.upperBound.y + 0.10000000149011612;
  dx = displacement.x * 2;
  dy = displacement.y * 2;
  dx < 0?(lowerBound.x += dx):(upperBound.x += dx);
  dy < 0?(lowerBound.y += dy):(upperBound.y += dy);
  $insertLeaf(this$static, proxyId);
  return true;
}

function $query(this$static, callback, aabb){
  var node, proceed;
  this$static.nodeStack.position_0 = 0;
  $push_2(this$static.nodeStack, this$static.m_root);
  while (this$static.nodeStack.position_0 > 0) {
    node = $pop_0(this$static.nodeStack);
    if (!node) {
      continue;
    }
    if (testOverlap(node.aabb, aabb)) {
      if (!node.child1) {
        proceed = $treeCallback(callback, node.id_0);
        if (!proceed) {
          return;
        }
      }
       else {
        $push_2(this$static.nodeStack, node.child1);
        $push_2(this$static.nodeStack, node.child2);
      }
    }
  }
}

function $removeLeaf(this$static, leaf){
  var child1, child2, grandParent, index, parent_0, sibling;
  if (leaf == this$static.m_root) {
    this$static.m_root = null;
    return;
  }
  parent_0 = leaf.parent_0;
  grandParent = parent_0.parent_0;
  parent_0.child1 == leaf?(sibling = parent_0.child2):(sibling = parent_0.child1);
  if (grandParent) {
    grandParent.child1 == parent_0?(grandParent.child1 = sibling):(grandParent.child2 = sibling);
    sibling.parent_0 = grandParent;
    $freeNode(this$static, parent_0);
    index = grandParent;
    while (index) {
      index = $balance(this$static, index);
      child1 = index.child1;
      child2 = index.child2;
      $combine(index.aabb, child1.aabb, child2.aabb);
      index.height_0 = 1 + max_1(child1.height_0, child2.height_0);
      index = index.parent_0;
    }
  }
   else {
    this$static.m_root = sibling;
    sibling.parent_0 = null;
    $freeNode(this$static, parent_0);
  }
}

function DynamicTree_0(){
  var i;
  this.drawVecs = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, 4, 0);
  this.nodeStack = new DynamicTree$TreeNodeStack_0;
  new Vec2_0;
  new AABB_0;
  new RayCastInput_0;
  this.combinedAABB = new AABB_0;
  new Vec2_0;
  this.m_root = null;
  this.m_nodeCount = 0;
  this.m_nodeCapacity = 16;
  this.m_nodes = initDim(_3Lorg_jbox2d_collision_broadphase_DynamicTreeNode_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$DynamicTreeNode, 16, 0);
  for (i = this.m_nodeCapacity - 1; i >= 0; --i) {
    this.m_nodes[i] = new DynamicTreeNode_0(i);
    this.m_nodes[i].parent_0 = i == this.m_nodeCapacity - 1?null:this.m_nodes[i + 1];
    this.m_nodes[i].height_0 = -1;
  }
  this.m_freeList = 0;
  this.m_insertionCount = 0;
  for (i = 0; i < this.drawVecs.length; ++i) {
    this.drawVecs[i] = new Vec2_0;
  }
}

defineSeed(420, 1, {}, DynamicTree_0);
_.m_freeList = 0;
_.m_insertionCount = 0;
_.m_nodeCapacity = 0;
_.m_nodeCount = 0;
_.m_nodes = null;
_.m_root = null;
function $pop_0(this$static){
  return this$static.stack_0[--this$static.position_0];
}

function $push_2(this$static, i){
  var old;
  if (this$static.position_0 == this$static.size) {
    old = this$static.stack_0;
    this$static.stack_0 = initDim(_3Lorg_jbox2d_collision_broadphase_DynamicTreeNode_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$DynamicTreeNode, this$static.size * 2, 0);
    this$static.size = this$static.stack_0.length;
    arraycopy(old, 0, this$static.stack_0, 0, old.length);
  }
  this$static.stack_0[this$static.position_0++] = i;
}

function DynamicTree$TreeNodeStack_0(){
  this.stack_0 = initDim(_3Lorg_jbox2d_collision_broadphase_DynamicTreeNode_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$DynamicTreeNode, 10, 0);
  this.position_0 = 0;
  this.size = 10;
}

defineSeed(421, 1, {}, DynamicTree$TreeNodeStack_0);
_.position_0 = 0;
_.size = 0;
_.stack_0 = null;
function DynamicTreeNode_0(id){
  this.aabb = new AABB_0;
  this.id_0 = id;
}

defineSeed(422, 1, makeCastMap([Q$DynamicTreeNode]), DynamicTreeNode_0);
_.child1 = null;
_.child2 = null;
_.height_0 = 0;
_.id_0 = 0;
_.parent_0 = null;
_.userData = null;
function $compareTo_2(this$static, pair2){
  if (this$static.proxyIdA < pair2.proxyIdA) {
    return -1;
  }
  if (this$static.proxyIdA == pair2.proxyIdA) {
    return this$static.proxyIdB < pair2.proxyIdB?-1:this$static.proxyIdB == pair2.proxyIdB?0:1;
  }
  return 1;
}

function Pair_0(){
}

defineSeed(423, 1, makeCastMap([Q$Comparable, Q$Pair]), Pair_0);
_.compareTo$ = function compareTo_8(pair2){
  return $compareTo_2(this, pair2);
}
;
_.proxyIdA = 0;
_.proxyIdB = 0;
function $setRadius(this$static, radius){
  this$static.m_radius = radius;
}

function Shape_0(type){
  this.m_type = type;
}

defineSeed(425, 1, {});
_.m_radius = 0;
_.m_type = null;
function CircleShape_0(){
  Shape_0.call(this, ($clinit_ShapeType() , CIRCLE));
  this.m_p = new Vec2_0;
  this.m_radius = 0;
}

defineSeed(424, 425, {}, CircleShape_0);
_.clone = function clone(){
  var shape;
  shape = new CircleShape_0;
  shape.m_p.x = this.m_p.x;
  shape.m_p.y = this.m_p.y;
  shape.m_radius = this.m_radius;
  return shape;
}
;
_.computeAABB = function computeAABB(aabb, transform, childIndex){
  var px, py, tp, tq;
  tq = transform.q;
  tp = transform.p;
  px = tq.c * this.m_p.x - tq.s * this.m_p.y + tp.x;
  py = tq.s * this.m_p.x + tq.c * this.m_p.y + tp.y;
  aabb.lowerBound.x = px - this.m_radius;
  aabb.lowerBound.y = py - this.m_radius;
  aabb.upperBound.x = px + this.m_radius;
  aabb.upperBound.y = py + this.m_radius;
}
;
_.computeMass = function computeMass(massData, density){
  massData.mass = density * 3.1415927410125732 * this.m_radius * this.m_radius;
  massData.center.x = this.m_p.x;
  massData.center.y = this.m_p.y;
  massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
}
;
_.getChildCount = function getChildCount(){
  return 1;
}
;
_.m_p = null;
function EdgeShape_0(){
  Shape_0.call(this, ($clinit_ShapeType() , EDGE));
  this.m_vertex1 = new Vec2_0;
  this.m_vertex2 = new Vec2_0;
  this.m_vertex0 = new Vec2_0;
  this.m_vertex3 = new Vec2_0;
  new Vec2_0;
  this.m_radius = 0.009999999776482582;
}

defineSeed(426, 425, {}, EdgeShape_0);
_.clone = function clone_0(){
  var edge;
  edge = new EdgeShape_0;
  edge.m_radius = this.m_radius;
  edge.m_hasVertex0 = this.m_hasVertex0;
  edge.m_hasVertex3 = this.m_hasVertex3;
  $set_12(edge.m_vertex0, this.m_vertex0);
  $set_12(edge.m_vertex1, this.m_vertex1);
  $set_12(edge.m_vertex2, this.m_vertex2);
  $set_12(edge.m_vertex3, this.m_vertex3);
  return edge;
}
;
_.computeAABB = function computeAABB_0(aabb, xf, childIndex){
  var lowerBound, upperBound, v1x, v1y, v2x, v2y, xfq;
  lowerBound = aabb.lowerBound;
  upperBound = aabb.upperBound;
  xfq = xf.q;
  v1x = xfq.c * this.m_vertex1.x - xfq.s * this.m_vertex1.y + xf.p.x;
  v1y = xfq.s * this.m_vertex1.x + xfq.c * this.m_vertex1.y + xf.p.y;
  v2x = xfq.c * this.m_vertex2.x - xfq.s * this.m_vertex2.y + xf.p.x;
  v2y = xfq.s * this.m_vertex2.x + xfq.c * this.m_vertex2.y + xf.p.y;
  lowerBound.x = v1x < v2x?v1x:v2x;
  lowerBound.y = v1y < v2y?v1y:v2y;
  upperBound.x = v1x > v2x?v1x:v2x;
  upperBound.y = v1y > v2y?v1y:v2y;
  lowerBound.x -= this.m_radius;
  lowerBound.y -= this.m_radius;
  upperBound.x += this.m_radius;
  upperBound.y += this.m_radius;
}
;
_.computeMass = function computeMass_0(massData, density){
  massData.mass = 0;
  $mulLocal($addLocal($set_12(massData.center, this.m_vertex1), this.m_vertex2), 0.5);
  massData.I = 0;
}
;
_.getChildCount = function getChildCount_0(){
  return 1;
}
;
_.m_hasVertex0 = false;
_.m_hasVertex3 = false;
function MassData_0(){
  this.mass = this.I = 0;
  this.center = new Vec2_0;
}

defineSeed(427, 1, {}, MassData_0);
_.I = 0;
_.center = null;
_.mass = 0;
function $setAsBox(this$static, hx, hy){
  this$static.m_count = 4;
  $set_11(this$static.m_vertices[0], -hx, -hy);
  $set_11(this$static.m_vertices[1], hx, -hy);
  $set_11(this$static.m_vertices[2], hx, hy);
  $set_11(this$static.m_vertices[3], -hx, hy);
  $set_11(this$static.m_normals[0], 0, -1);
  $set_11(this$static.m_normals[1], 1, 0);
  $set_11(this$static.m_normals[2], 0, 1);
  $set_11(this$static.m_normals[3], -1, 0);
  $setZero_0(this$static.m_centroid);
}

function PolygonShape_0(){
  var i;
  Shape_0.call(this, ($clinit_ShapeType() , POLYGON));
  this.m_centroid = new Vec2_0;
  this.pool1 = new Vec2_0;
  this.pool2 = new Vec2_0;
  this.pool3 = new Vec2_0;
  this.pool4 = new Vec2_0;
  new Transform_0;
  this.m_count = 0;
  this.m_vertices = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, 8, 0);
  for (i = 0; i < this.m_vertices.length; ++i) {
    this.m_vertices[i] = new Vec2_0;
  }
  this.m_normals = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, 8, 0);
  for (i = 0; i < this.m_normals.length; ++i) {
    this.m_normals[i] = new Vec2_0;
  }
  this.m_radius = 0.009999999776482582;
  $setZero_0(this.m_centroid);
}

defineSeed(428, 425, {}, PolygonShape_0);
_.clone = function clone_1(){
  var i, shape;
  shape = new PolygonShape_0;
  $set_12(shape.m_centroid, this.m_centroid);
  for (i = 0; i < shape.m_normals.length; ++i) {
    $set_12(shape.m_normals[i], this.m_normals[i]);
    $set_12(shape.m_vertices[i], this.m_vertices[i]);
  }
  $setRadius(shape, this.m_radius);
  shape.m_count = this.m_count;
  return shape;
}
;
_.computeAABB = function computeAABB_1(aabb, xf, childIndex){
  var i, lower, upper, v1, v2, vx, vy, xfp, xfq;
  lower = aabb.lowerBound;
  upper = aabb.upperBound;
  v1 = this.m_vertices[0];
  xfq = xf.q;
  xfp = xf.p;
  lower.x = xfq.c * v1.x - xfq.s * v1.y + xfp.x;
  lower.y = xfq.s * v1.x + xfq.c * v1.y + xfp.y;
  upper.x = lower.x;
  upper.y = lower.y;
  for (i = 1; i < this.m_count; ++i) {
    v2 = this.m_vertices[i];
    vx = xfq.c * v2.x - xfq.s * v2.y + xfp.x;
    vy = xfq.s * v2.x + xfq.c * v2.y + xfp.y;
    lower.x = lower.x < vx?lower.x:vx;
    lower.y = lower.y < vy?lower.y:vy;
    upper.x = upper.x > vx?upper.x:vx;
    upper.y = upper.y > vy?upper.y:vy;
  }
  lower.x -= this.m_radius;
  lower.y -= this.m_radius;
  upper.x += this.m_radius;
  upper.y += this.m_radius;
}
;
_.computeMass = function computeMass_1(massData, density){
  var D, I, area, center, e1, e2, ex1, ex2, ey1, ey2, i, intx2, inty2, s, triangleArea;
  center = this.pool1;
  center.x = 0;
  center.y = 0;
  area = 0;
  I = 0;
  s = this.pool2;
  s.x = 0;
  s.y = 0;
  for (i = 0; i < this.m_count; ++i) {
    $addLocal(s, this.m_vertices[i]);
  }
  $mulLocal(s, 1 / this.m_count);
  e1 = this.pool3;
  e2 = this.pool4;
  for (i = 0; i < this.m_count; ++i) {
    $subLocal($set_12(e1, this.m_vertices[i]), s);
    $addLocal($negateLocal($set_12(e2, s)), i + 1 < this.m_count?this.m_vertices[i + 1]:this.m_vertices[0]);
    D = e1.x * e2.y - e1.y * e2.x;
    triangleArea = 0.5 * D;
    area += triangleArea;
    center.x += triangleArea * 0.3333333432674408 * (e1.x + e2.x);
    center.y += triangleArea * 0.3333333432674408 * (e1.y + e2.y);
    ex1 = e1.x;
    ey1 = e1.y;
    ex2 = e2.x;
    ey2 = e2.y;
    intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;
    inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;
    I += 0.0833333358168602 * D * (intx2 + inty2);
  }
  massData.mass = density * area;
  $mulLocal(center, 1 / area);
  $addLocal($set_12(massData.center, center), s);
  massData.I = I * density;
  massData.I += massData.mass * dot_0(massData.center, massData.center);
}
;
_.getChildCount = function getChildCount_1(){
  return 1;
}
;
_.m_count = 0;
_.m_normals = null;
_.m_vertices = null;
function $clinit_ShapeType(){
  $clinit_ShapeType = nullMethod;
  CIRCLE = new ShapeType_0('CIRCLE', 0);
  EDGE = new ShapeType_0('EDGE', 1);
  POLYGON = new ShapeType_0('POLYGON', 2);
  CHAIN = new ShapeType_0('CHAIN', 3);
  $VALUES_18 = initValues(_3Lorg_jbox2d_collision_shapes_ShapeType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ShapeType, [CIRCLE, EDGE, POLYGON, CHAIN]);
}

function ShapeType_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_19(){
  $clinit_ShapeType();
  return $VALUES_18;
}

defineSeed(429, 39, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$ShapeType]), ShapeType_0);
var $VALUES_18, CHAIN, CIRCLE, EDGE, POLYGON;
function $invertToOut(this$static, out){
  var a, b, c, d, det;
  a = this$static.ex.x;
  b = this$static.ey.x;
  c = this$static.ex.y;
  d = this$static.ey.y;
  det = a * d - b * c;
  det = 1 / det;
  out.ex.x = det * d;
  out.ey.x = -det * b;
  out.ex.y = -det * c;
  out.ey.y = det * a;
}

function $setZero(this$static){
  this$static.ex.x = 0;
  this$static.ey.x = 0;
  this$static.ex.y = 0;
  this$static.ey.y = 0;
}

function Mat22_0(){
  this.ex = new Vec2_0;
  this.ey = new Vec2_0;
}

function mulToOutUnsafe(R, v, out){
  out.x = R.ex.x * v.x + R.ey.x * v.y;
  out.y = R.ex.y * v.x + R.ey.y * v.y;
}

defineSeed(430, 1, makeCastMap([Q$Serializable]), Mat22_0);
_.equals$ = function equals_14(obj){
  var other;
  if (this === obj)
    return true;
  if (obj == null)
    return false;
  if (Lorg_jbox2d_common_Mat22_2_classLit != getClass__devirtual$(obj))
    return false;
  other = obj;
  if (!this.ex) {
    if (other.ex)
      return false;
  }
   else if (!$equals_1(this.ex, other.ex))
    return false;
  if (!this.ey) {
    if (other.ey)
      return false;
  }
   else if (!$equals_1(this.ey, other.ey))
    return false;
  return true;
}
;
_.hashCode$ = function hashCode_13(){
  var result;
  result = 31 + (!this.ex?0:$hashCode(this.ex));
  result = 31 * result + (!this.ey?0:$hashCode(this.ey));
  return result;
}
;
_.toString$ = function toString_28(){
  var s;
  s = '';
  s += '[' + this.ex.x + ',' + this.ey.x + ']\n';
  s += '[' + this.ex.y + ',' + this.ey.y + ']';
  return s;
}
;
_.ex = null;
_.ey = null;
function $clinit_Mat33(){
  $clinit_Mat33 = nullMethod;
  new Mat33_1(new Vec3_1(1, 0, 0), new Vec3_1(0, 1, 0), new Vec3_1(0, 0, 1));
}

function Mat33_0(){
  $clinit_Mat33();
  this.ex = new Vec3_0;
  this.ey = new Vec3_0;
  this.ez = new Vec3_0;
}

function Mat33_1(argCol1, argCol2, argCol3){
  this.ex = new Vec3_2(argCol1);
  this.ey = new Vec3_2(argCol2);
  this.ez = new Vec3_2(argCol3);
}

defineSeed(431, 1, makeCastMap([Q$Serializable]), Mat33_0, Mat33_1);
_.equals$ = function equals_15(obj){
  var other;
  if (this === obj)
    return true;
  if (obj == null)
    return false;
  if (Lorg_jbox2d_common_Mat33_2_classLit != getClass__devirtual$(obj))
    return false;
  other = obj;
  if (!this.ex) {
    if (other.ex)
      return false;
  }
   else if (!$equals_2(this.ex, other.ex))
    return false;
  if (!this.ey) {
    if (other.ey)
      return false;
  }
   else if (!$equals_2(this.ey, other.ey))
    return false;
  if (!this.ez) {
    if (other.ez)
      return false;
  }
   else if (!$equals_2(this.ez, other.ez))
    return false;
  return true;
}
;
_.hashCode$ = function hashCode_14(){
  var result;
  result = 31 + (!this.ex?0:$hashCode_0(this.ex));
  result = 31 * result + (!this.ey?0:$hashCode_0(this.ey));
  result = 31 * result + (!this.ez?0:$hashCode_0(this.ez));
  return result;
}
;
_.ex = null;
_.ey = null;
_.ez = null;
function $clinit_MathUtils(){
  $clinit_MathUtils = nullMethod;
  var i;
  sinLUT = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, ($clinit_Settings() , SINCOS_LUT_LENGTH), 1);
  for (i = 0; i < SINCOS_LUT_LENGTH; ++i) {
    sinLUT[i] = Math.sin(i * 1.1000000085914508E-4);
  }
}

function clamp(a, low, high){
  $clinit_MathUtils();
  return low > (a < high?a:high)?low:a < high?a:high;
}

function cos(x){
  $clinit_MathUtils();
  $clinit_Settings();
  return sinLUT_0(1.5707963705062866 - x);
}

function distanceSquared(v1, v2){
  $clinit_MathUtils();
  var dx, dy;
  dx = v1.x - v2.x;
  dy = v1.y - v2.y;
  return dx * dx + dy * dy;
}

function floor_0(x){
  $clinit_MathUtils();
  var y;
  $clinit_Settings();
  y = round_int(x);
  if (x < 0 && x != y) {
    return y - 1;
  }
  return y;
}

function max_1(a, b){
  $clinit_MathUtils();
  return a > b?a:b;
}

function min(a, b){
  $clinit_MathUtils();
  return a < b?a:b;
}

function sin(x){
  $clinit_MathUtils();
  $clinit_Settings();
  return sinLUT_0(x);
}

function sinLUT_0(x){
  $clinit_MathUtils();
  x %= 6.2831854820251465;
  x < 0 && (x += 6.2831854820251465);
  $clinit_Settings();
  return sinLUT[floor_0(x / 1.1000000085914508E-4 + 0.5) % SINCOS_LUT_LENGTH];
}

var sinLUT;
function $set_7(this$static, angle){
  this$static.s = ($clinit_MathUtils() , $clinit_Settings() , sinLUT_0(angle));
  this$static.c = sinLUT_0(1.5707963705062866 - angle);
  return this$static;
}

function $set_8(this$static, other){
  this$static.s = other.s;
  this$static.c = other.c;
  return this$static;
}

function Rot_0(){
  this.s = 0;
  this.c = 1;
}

function mulToOutUnsafe_0(q, v, out){
  out.x = q.c * v.x - q.s * v.y;
  out.y = q.s * v.x + q.c * v.y;
}

function mulTransUnsafe(q, r, out){
  out.s = q.c * r.s - q.s * r.c;
  out.c = q.c * r.c + q.s * r.s;
}

function mulTransUnsafe_0(q, v, out){
  out.x = q.c * v.x + q.s * v.y;
  out.y = -q.s * v.x + q.c * v.y;
}

defineSeed(434, 1, makeCastMap([Q$Serializable]), Rot_0);
_.toString$ = function toString_29(){
  return 'Rot(s:' + this.s + ', c:' + this.c + ')';
}
;
_.c = 0;
_.s = 0;
function $clinit_Settings(){
  $clinit_Settings = nullMethod;
  SINCOS_LUT_LENGTH = round_int(Math.ceil(57119.86598277577));
}

var SINCOS_LUT_LENGTH;
--></script>
<script><!--
function $advance(this$static, alpha){
  this$static.c0.x = (1 - alpha) * this$static.c0.x + alpha * this$static.c.x;
  this$static.c0.y = (1 - alpha) * this$static.c0.y + alpha * this$static.c.y;
  this$static.a0 = (1 - alpha) * this$static.a0 + alpha * this$static.a_0;
}

function $getTransform(this$static, xf, beta){
  var q;
  xf.p.x = (1 - beta) * this$static.c0.x + beta * this$static.c.x;
  xf.p.y = (1 - beta) * this$static.c0.y + beta * this$static.c.y;
  $set_7(xf.q, (1 - beta) * this$static.a0 + beta * this$static.a_0);
  q = xf.q;
  xf.p.x -= q.c * this$static.localCenter.x - q.s * this$static.localCenter.y;
  xf.p.y -= q.s * this$static.localCenter.x + q.c * this$static.localCenter.y;
}

function $normalize(this$static){
  var d;
  d = 6.2831854820251465 * floor_0(this$static.a0 / 6.2831854820251465);
  this$static.a0 -= d;
  this$static.a_0 -= d;
}

function $set_9(this$static, argCloneFrom){
  $set_12(this$static.localCenter, argCloneFrom.localCenter);
  $set_12(this$static.c0, argCloneFrom.c0);
  $set_12(this$static.c, argCloneFrom.c);
  this$static.a0 = argCloneFrom.a0;
  this$static.a_0 = argCloneFrom.a_0;
  return this$static;
}

function Sweep_0(){
  this.localCenter = new Vec2_0;
  this.c0 = new Vec2_0;
  this.c = new Vec2_0;
}

defineSeed(436, 1, makeCastMap([Q$Serializable]), Sweep_0);
_.toString$ = function toString_30(){
  var s;
  s = 'Sweep:\nlocalCenter: ' + this.localCenter + '\n';
  s += 'c0: ' + this.c0 + ', c: ' + this.c + '\n';
  s += 'a0: ' + this.a0 + ', a: ' + this.a_0 + '\n';
  return s;
}
;
_.a_0 = 0;
_.a0 = 0;
_.alpha0 = 0;
_.c = null;
_.c0 = null;
_.localCenter = null;
function $getMilliseconds(this$static){
  return Date.now() - this$static.resetMillis;
}

function Timer_2(){
  this.resetMillis = Date.now();
}

defineSeed(437, 1, {}, Timer_2);
_.resetMillis = 0;
function $clinit_Transform(){
  $clinit_Transform = nullMethod;
  pool_0 = new Vec2_0;
}

function $set_10(this$static, xf){
  $set_12(this$static.p, xf.p);
  $set_8(this$static.q, xf.q);
  return this$static;
}

function Transform_0(){
  $clinit_Transform();
  this.p = new Vec2_0;
  this.q = new Rot_0;
}

function mulToOut(T, v, out){
  $clinit_Transform();
  var tempy;
  tempy = T.q.s * v.x + T.q.c * v.y + T.p.y;
  out.x = T.q.c * v.x - T.q.s * v.y + T.p.x;
  out.y = tempy;
}

function mulToOutUnsafe_1(T, v, out){
  $clinit_Transform();
  out.x = T.q.c * v.x - T.q.s * v.y + T.p.x;
  out.y = T.q.s * v.x + T.q.c * v.y + T.p.y;
}

function mulTransToOutUnsafe(A, B, out){
  $clinit_Transform();
  mulTransUnsafe(A.q, B.q, out.q);
  $subLocal($set_12(pool_0, B.p), A.p);
  mulTransUnsafe_0(A.q, pool_0, out.p);
}

function mulTransToOutUnsafe_0(T, v, out){
  $clinit_Transform();
  var px, py;
  px = v.x - T.p.x;
  py = v.y - T.p.y;
  out.x = T.q.c * px + T.q.s * py;
  out.y = -T.q.s * px + T.q.c * py;
}

defineSeed(438, 1, makeCastMap([Q$Serializable]), Transform_0);
_.toString$ = function toString_31(){
  var s;
  s = 'XForm:\n';
  s += 'Position: ' + this.p + '\n';
  s += 'R: \n' + this.q + '\n';
  return s;
}
;
_.p = null;
_.q = null;
var pool_0;
function $addLocal(this$static, v){
  this$static.x += v.x;
  this$static.y += v.y;
  return this$static;
}

function $equals_1(this$static, obj){
  var other;
  if (this$static === obj)
    return true;
  if (obj == null)
    return false;
  if (Lorg_jbox2d_common_Vec2_2_classLit != getClass__devirtual$(obj))
    return false;
  other = obj;
  if (floatToIntBits(this$static.x) != floatToIntBits(other.x))
    return false;
  if (floatToIntBits(this$static.y) != floatToIntBits(other.y))
    return false;
  return true;
}

function $hashCode(this$static){
  var result;
  result = 31 + floatToIntBits(this$static.x);
  result = 31 * result + floatToIntBits(this$static.y);
  return result;
}

function $lengthSquared(this$static){
  return this$static.x * this$static.x + this$static.y * this$static.y;
}

function $mulLocal(this$static, a){
  this$static.x *= a;
  this$static.y *= a;
  return this$static;
}

function $negateLocal(this$static){
  this$static.x = -this$static.x;
  this$static.y = -this$static.y;
  return this$static;
}

function $normalize_0(this$static){
  var invLength, length_0;
  length_0 = ($clinit_MathUtils() , sqrt(this$static.x * this$static.x + this$static.y * this$static.y));
  if (length_0 < 1.1920928955078125E-7) {
    return 0;
  }
  invLength = 1 / length_0;
  this$static.x *= invLength;
  this$static.y *= invLength;
  return length_0;
}

function $set_11(this$static, x, y){
  this$static.x = x;
  this$static.y = y;
  return this$static;
}

function $set_12(this$static, v){
  this$static.x = v.x;
  this$static.y = v.y;
  return this$static;
}

function $setZero_0(this$static){
  this$static.x = 0;
  this$static.y = 0;
}

function $subLocal(this$static, v){
  this$static.x -= v.x;
  this$static.y -= v.y;
  return this$static;
}

function Vec2_0(){
  Vec2_1.call(this, 0, 0);
}

function Vec2_1(x, y){
  this.x = x;
  this.y = y;
}

function cross(a, b){
  return a.x * b.y - a.y * b.x;
}

function crossToOutUnsafe(s, a, out){
  out.x = -s * a.y;
  out.y = s * a.x;
}

function crossToOutUnsafe_0(a, s, out){
  out.x = s * a.y;
  out.y = -s * a.x;
}

function dot_0(a, b){
  return a.x * b.x + a.y * b.y;
}

defineSeed(439, 1, makeCastMap([Q$Serializable, Q$Vec2]), Vec2_0, Vec2_1);
_.equals$ = function equals_16(obj){
  return $equals_1(this, obj);
}
;
_.hashCode$ = function hashCode_15(){
  return $hashCode(this);
}
;
_.toString$ = function toString_32(){
  return '(' + this.x + ',' + this.y + ')';
}
;
_.x = 0;
_.y = 0;
function $equals_2(this$static, obj){
  var other;
  if (this$static === obj)
    return true;
  if (obj == null)
    return false;
  if (Lorg_jbox2d_common_Vec3_2_classLit != getClass__devirtual$(obj))
    return false;
  other = obj;
  if (floatToIntBits(this$static.x) != floatToIntBits(other.x))
    return false;
  if (floatToIntBits(this$static.y) != floatToIntBits(other.y))
    return false;
  if (floatToIntBits(this$static.z) != floatToIntBits(other.z))
    return false;
  return true;
}

function $hashCode_0(this$static){
  var result;
  result = 31 + floatToIntBits(this$static.x);
  result = 31 * result + floatToIntBits(this$static.y);
  result = 31 * result + floatToIntBits(this$static.z);
  return result;
}

function Vec3_0(){
  this.x = this.y = this.z = 0;
}

function Vec3_1(argX, argY, argZ){
  this.x = argX;
  this.y = argY;
  this.z = argZ;
}

function Vec3_2(argCopy){
  this.x = argCopy.x;
  this.y = argCopy.y;
  this.z = argCopy.z;
}

defineSeed(440, 1, makeCastMap([Q$Serializable]), Vec3_0, Vec3_1, Vec3_2);
_.equals$ = function equals_17(obj){
  return $equals_2(this, obj);
}
;
_.hashCode$ = function hashCode_16(){
  return $hashCode_0(this);
}
;
_.toString$ = function toString_33(){
  return '(' + this.x + ',' + this.y + ',' + this.z + ')';
}
;
_.x = 0;
_.y = 0;
_.z = 0;
function $advance_0(this$static, t){
  $advance(this$static.m_sweep, t);
  $set_12(this$static.m_sweep.c, this$static.m_sweep.c0);
  this$static.m_sweep.a_0 = this$static.m_sweep.a0;
  $set_7(this$static.m_xf.q, this$static.m_sweep.a_0);
  mulToOutUnsafe_0(this$static.m_xf.q, this$static.m_sweep.localCenter, this$static.m_xf.p);
  $addLocal($mulLocal(this$static.m_xf.p, -1), this$static.m_sweep.c);
}

function $createFixture(this$static, def){
  var broadPhase, fixture;
  if ((this$static.m_world.m_flags & 2) == 2) {
    return null;
  }
  fixture = new Fixture_0;
  $create(fixture, this$static, def);
  if ((this$static.m_flags & 32) == 32) {
    broadPhase = this$static.m_world.m_contactManager.m_broadPhase;
    $createProxies(fixture, broadPhase, this$static.m_xf);
  }
  fixture.m_next = this$static.m_fixtureList;
  this$static.m_fixtureList = fixture;
  ++this$static.m_fixtureCount;
  fixture.m_body = this$static;
  fixture.m_density > 0 && $resetMassData(this$static);
  this$static.m_world.m_flags |= 1;
  return fixture;
}

function $resetMassData(this$static){
  var f, localCenter, massData, oldCenter, temp;
  this$static.m_mass = 0;
  this$static.m_invMass = 0;
  this$static.m_I = 0;
  this$static.m_invI = 0;
  $setZero_0(this$static.m_sweep.localCenter);
  if (this$static.m_type == ($clinit_BodyType() , STATIC_0) || this$static.m_type == KINEMATIC) {
    $set_12(this$static.m_sweep.c0, this$static.m_xf.p);
    $set_12(this$static.m_sweep.c, this$static.m_xf.p);
    this$static.m_sweep.a0 = this$static.m_sweep.a_0;
    return;
  }
  localCenter = $pop_1(this$static.m_world.pool.vecs);
  localCenter.x = 0;
  localCenter.y = 0;
  temp = $pop_1(this$static.m_world.pool.vecs);
  massData = this$static.pmd;
  for (f = this$static.m_fixtureList; f; f = f.m_next) {
    if (f.m_density == 0) {
      continue;
    }
    f.m_shape.computeMass(massData, f.m_density);
    this$static.m_mass += massData.mass;
    $mulLocal($set_12(temp, massData.center), massData.mass);
    localCenter.x += temp.x;
    localCenter.y += temp.y;
    this$static.m_I += massData.I;
  }
  if (this$static.m_mass > 0) {
    this$static.m_invMass = 1 / this$static.m_mass;
    $mulLocal(localCenter, this$static.m_invMass);
  }
   else {
    this$static.m_mass = 1;
    this$static.m_invMass = 1;
  }
  if (this$static.m_I > 0 && (this$static.m_flags & 16) == 0) {
    this$static.m_I -= this$static.m_mass * (localCenter.x * localCenter.x + localCenter.y * localCenter.y);
    this$static.m_invI = 1 / this$static.m_I;
  }
   else {
    this$static.m_I = 0;
    this$static.m_invI = 0;
  }
  oldCenter = $pop_1(this$static.m_world.pool.vecs);
  $set_12(oldCenter, this$static.m_sweep.c);
  $set_12(this$static.m_sweep.localCenter, localCenter);
  mulToOutUnsafe_1(this$static.m_xf, this$static.m_sweep.localCenter, this$static.m_sweep.c0);
  $set_12(this$static.m_sweep.c, this$static.m_sweep.c0);
  $subLocal($set_12(temp, this$static.m_sweep.c), oldCenter);
  crossToOutUnsafe(this$static.m_angularVelocity, temp, oldCenter);
  $addLocal(this$static.m_linearVelocity, oldCenter);
  this$static.m_world.pool.vecs.index_0 -= 3;
}

function $setActive(this$static){
  var broadPhase, f;
  if ((this$static.m_flags & 32) == 32) {
    return;
  }
  this$static.m_flags |= 32;
  broadPhase = this$static.m_world.m_contactManager.m_broadPhase;
  for (f = this$static.m_fixtureList; f; f = f.m_next) {
    $createProxies(f, broadPhase, this$static.m_xf);
  }
}

function $setAwake(this$static, flag){
  if (flag) {
    if ((this$static.m_flags & 2) == 0) {
      this$static.m_flags |= 2;
      this$static.m_sleepTime = 0;
    }
  }
   else {
    this$static.m_flags &= -3;
    this$static.m_sleepTime = 0;
    $setZero_0(this$static.m_linearVelocity);
    this$static.m_angularVelocity = 0;
    $setZero_0(this$static.m_force);
    this$static.m_torque = 0;
  }
}

function $setLinearVelocity(this$static, v){
  if (this$static.m_type == ($clinit_BodyType() , STATIC_0)) {
    return;
  }
  v.x * v.x + v.y * v.y > 0 && $setAwake(this$static, true);
  $set_12(this$static.m_linearVelocity, v);
}

function $setTransform(this$static, position){
  var broadPhase, f;
  if ((this$static.m_world.m_flags & 2) == 2) {
    return;
  }
  $set_7(this$static.m_xf.q, 0);
  $set_12(this$static.m_xf.p, position);
  mulToOutUnsafe_1(this$static.m_xf, this$static.m_sweep.localCenter, this$static.m_sweep.c);
  this$static.m_sweep.a_0 = 0;
  $set_12(this$static.m_sweep.c0, this$static.m_sweep.c);
  this$static.m_sweep.a0 = this$static.m_sweep.a_0;
  broadPhase = this$static.m_world.m_contactManager.m_broadPhase;
  for (f = this$static.m_fixtureList; f; f = f.m_next) {
    $synchronize(f, broadPhase, this$static.m_xf, this$static.m_xf);
  }
  $findNewContacts(this$static.m_world.m_contactManager);
}

function $setType(this$static, type){
  var broadPhase, ce, ce0, f, i, proxyCount;
  if ((this$static.m_world.m_flags & 2) == 2) {
    return;
  }
  if (this$static.m_type == type) {
    return;
  }
  this$static.m_type = type;
  $resetMassData(this$static);
  if (this$static.m_type == ($clinit_BodyType() , STATIC_0)) {
    $setZero_0(this$static.m_linearVelocity);
    this$static.m_angularVelocity = 0;
    this$static.m_sweep.a0 = this$static.m_sweep.a_0;
    $set_12(this$static.m_sweep.c0, this$static.m_sweep.c);
    $synchronizeFixtures(this$static);
  }
  $setAwake(this$static, true);
  $setZero_0(this$static.m_force);
  this$static.m_torque = 0;
  ce = this$static.m_contactList;
  while (ce) {
    ce0 = ce;
    ce = ce.next;
    $destroy_1(this$static.m_world.m_contactManager, ce0.contact);
  }
  this$static.m_contactList = null;
  broadPhase = this$static.m_world.m_contactManager.m_broadPhase;
  for (f = this$static.m_fixtureList; f; f = f.m_next) {
    proxyCount = f.m_proxyCount;
    for (i = 0; i < proxyCount; ++i) {
      $bufferMove(broadPhase, f.m_proxies[i].proxyId);
    }
  }
}

function $shouldCollide_0(this$static, other){
  if (this$static.m_type != ($clinit_BodyType() , DYNAMIC) && other.m_type != DYNAMIC) {
    return false;
  }
  return true;
}

function $synchronizeFixtures(this$static){
  var f, xf1;
  xf1 = this$static.pxf;
  xf1.q.s = sin(this$static.m_sweep.a0);
  xf1.q.c = cos(this$static.m_sweep.a0);
  xf1.p.x = this$static.m_sweep.c0.x - xf1.q.c * this$static.m_sweep.localCenter.x + xf1.q.s * this$static.m_sweep.localCenter.y;
  xf1.p.y = this$static.m_sweep.c0.y - xf1.q.s * this$static.m_sweep.localCenter.x - xf1.q.c * this$static.m_sweep.localCenter.y;
  for (f = this$static.m_fixtureList; f; f = f.m_next) {
    $synchronize(f, this$static.m_world.m_contactManager.m_broadPhase, xf1, this$static.m_xf);
  }
}

function $synchronizeTransform(this$static){
  var q, v;
  this$static.m_xf.q.s = sin(this$static.m_sweep.a_0);
  this$static.m_xf.q.c = cos(this$static.m_sweep.a_0);
  q = this$static.m_xf.q;
  v = this$static.m_sweep.localCenter;
  this$static.m_xf.p.x = this$static.m_sweep.c.x - q.c * v.x + q.s * v.y;
  this$static.m_xf.p.y = this$static.m_sweep.c.y - q.s * v.x - q.c * v.y;
}

function Body_0(bd, world){
  this.m_xf = new Transform_0;
  this.m_sweep = new Sweep_0;
  this.m_linearVelocity = new Vec2_0;
  this.m_force = new Vec2_0;
  new FixtureDef_0;
  this.pmd = new MassData_0;
  this.pxf = new Transform_0;
  this.m_flags = 0;
  bd.bullet && (this.m_flags |= 8);
  bd.fixedRotation && (this.m_flags |= 16);
  bd.allowSleep && (this.m_flags |= 4);
  bd.awake && (this.m_flags |= 2);
  bd.active && (this.m_flags |= 32);
  this.m_world = world;
  $set_12(this.m_xf.p, bd.position_0);
  $set_7(this.m_xf.q, bd.angle);
  $setZero_0(this.m_sweep.localCenter);
  $set_12(this.m_sweep.c0, this.m_xf.p);
  $set_12(this.m_sweep.c, this.m_xf.p);
  this.m_sweep.a0 = bd.angle;
  this.m_sweep.a_0 = bd.angle;
  this.m_sweep.alpha0 = 0;
  this.m_contactList = null;
  this.m_prev = null;
  this.m_next = null;
  $set_12(this.m_linearVelocity, bd.linearVelocity);
  this.m_angularVelocity = bd.angularVelocity;
  this.m_linearDamping = bd.linearDamping;
  this.m_angularDamping = bd.angularDamping;
  this.m_gravityScale = bd.gravityScale;
  $setZero_0(this.m_force);
  this.m_torque = 0;
  this.m_sleepTime = 0;
  this.m_type = bd.type_0;
  if (this.m_type == ($clinit_BodyType() , DYNAMIC)) {
    this.m_mass = 1;
    this.m_invMass = 1;
  }
   else {
    this.m_mass = 0;
    this.m_invMass = 0;
  }
  this.m_I = 0;
  this.m_invI = 0;
  this.m_fixtureList = null;
  this.m_fixtureCount = 0;
}

defineSeed(441, 1, makeCastMap([Q$Body]), Body_0);
_.m_I = 0;
_.m_angularDamping = 0;
_.m_angularVelocity = 0;
_.m_contactList = null;
_.m_fixtureCount = 0;
_.m_fixtureList = null;
_.m_flags = 0;
_.m_gravityScale = 0;
_.m_invI = 0;
_.m_invMass = 0;
_.m_islandIndex = 0;
_.m_linearDamping = 0;
_.m_mass = 0;
_.m_next = null;
_.m_prev = null;
_.m_sleepTime = 0;
_.m_torque = 0;
_.m_type = null;
_.m_world = null;
function BodyDef_0(){
  this.position_0 = new Vec2_0;
  this.angle = 0;
  this.linearVelocity = new Vec2_0;
  this.angularVelocity = 0;
  this.linearDamping = 0;
  this.angularDamping = 0;
  this.allowSleep = true;
  this.awake = true;
  this.fixedRotation = false;
  this.bullet = false;
  this.type_0 = ($clinit_BodyType() , STATIC_0);
  this.active = true;
  this.gravityScale = 1;
}

defineSeed(442, 1, {}, BodyDef_0);
_.active = false;
_.allowSleep = false;
_.angle = 0;
_.angularDamping = 0;
_.angularVelocity = 0;
_.awake = false;
_.bullet = false;
_.fixedRotation = false;
_.gravityScale = 0;
_.linearDamping = 0;
_.linearVelocity = null;
_.position_0 = null;
_.type_0 = null;
function $clinit_BodyType(){
  $clinit_BodyType = nullMethod;
  STATIC_0 = new BodyType_0('STATIC', 0);
  KINEMATIC = new BodyType_0('KINEMATIC', 1);
  DYNAMIC = new BodyType_0('DYNAMIC', 2);
  $VALUES_19 = initValues(_3Lorg_jbox2d_dynamics_BodyType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$BodyType, [STATIC_0, KINEMATIC, DYNAMIC]);
}

function BodyType_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_20(){
  $clinit_BodyType();
  return $VALUES_19;
}

defineSeed(443, 39, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$BodyType]), BodyType_0);
var $VALUES_19, DYNAMIC, KINEMATIC, STATIC_0;
function $addPair(this$static, proxyUserDataA, proxyUserDataB){
  var bodyA, bodyB, c, edge, fA, fB, fixtureA, fixtureB, iA, iB, indexA, indexB;
  fixtureA = proxyUserDataA.fixture;
  fixtureB = proxyUserDataB.fixture;
  indexA = proxyUserDataA.childIndex;
  indexB = proxyUserDataB.childIndex;
  bodyA = fixtureA.m_body;
  bodyB = fixtureB.m_body;
  if (bodyA == bodyB) {
    return;
  }
  edge = bodyB.m_contactList;
  while (edge) {
    if (edge.other == bodyA) {
      fA = edge.contact.m_fixtureA;
      fB = edge.contact.m_fixtureB;
      iA = edge.contact.m_indexA;
      iB = edge.contact.m_indexB;
      if (fA == fixtureA && iA == indexA && fB == fixtureB && iB == indexB) {
        return;
      }
      if (fA == fixtureB && iA == indexB && fB == fixtureA && iB == indexA) {
        return;
      }
    }
    edge = edge.next;
  }
  if (!$shouldCollide_0(bodyB, bodyA)) {
    return;
  }
  if (!!this$static.m_contactFilter && !$shouldCollide(fixtureA, fixtureB)) {
    return;
  }
  c = $popContact(this$static.pool, fixtureA, indexA, fixtureB, indexB);
  if (!c) {
    return;
  }
  fixtureA = c.m_fixtureA;
  fixtureB = c.m_fixtureB;
  bodyA = fixtureA.m_body;
  bodyB = fixtureB.m_body;
  c.m_prev = null;
  c.m_next = this$static.m_contactList;
  !!this$static.m_contactList && (this$static.m_contactList.m_prev = c);
  this$static.m_contactList = c;
  c.m_nodeA.contact = c;
  c.m_nodeA.other = bodyB;
  c.m_nodeA.prev = null;
  c.m_nodeA.next = bodyA.m_contactList;
  !!bodyA.m_contactList && (bodyA.m_contactList.prev = c.m_nodeA);
  bodyA.m_contactList = c.m_nodeA;
  c.m_nodeB.contact = c;
  c.m_nodeB.other = bodyA;
  c.m_nodeB.prev = null;
  c.m_nodeB.next = bodyB.m_contactList;
  !!bodyB.m_contactList && (bodyB.m_contactList.prev = c.m_nodeB);
  bodyB.m_contactList = c.m_nodeB;
  if (!fixtureA.m_isSensor && !fixtureB.m_isSensor) {
    $setAwake(bodyA, true);
    $setAwake(bodyB, true);
  }
  ++this$static.m_contactCount;
}

function $collide_0(this$static){
  var activeA, activeB, bodyA, bodyB, c, cNuke, fixtureA, fixtureB, indexA, indexB, overlap, proxyIdA, proxyIdB;
  c = this$static.m_contactList;
  while (c) {
    fixtureA = c.m_fixtureA;
    fixtureB = c.m_fixtureB;
    indexA = c.m_indexA;
    indexB = c.m_indexB;
    bodyA = fixtureA.m_body;
    bodyB = fixtureB.m_body;
    if ((c.m_flags & 8) == 8) {
      if (!$shouldCollide_0(bodyB, bodyA)) {
        cNuke = c;
        c = c.m_next;
        $destroy_1(this$static, cNuke);
        continue;
      }
      if (!!this$static.m_contactFilter && !$shouldCollide(fixtureA, fixtureB)) {
        cNuke = c;
        c = c.m_next;
        $destroy_1(this$static, cNuke);
        continue;
      }
      c.m_flags &= -9;
    }
    activeA = (bodyA.m_flags & 2) == 2 && bodyA.m_type != ($clinit_BodyType() , STATIC_0);
    activeB = (bodyB.m_flags & 2) == 2 && bodyB.m_type != ($clinit_BodyType() , STATIC_0);
    if (!activeA && !activeB) {
      c = c.m_next;
      continue;
    }
    proxyIdA = fixtureA.m_proxies[indexA].proxyId;
    proxyIdB = fixtureB.m_proxies[indexB].proxyId;
    overlap = $testOverlap_0(this$static.m_broadPhase, proxyIdA, proxyIdB);
    if (!overlap) {
      cNuke = c;
      c = c.m_next;
      $destroy_1(this$static, cNuke);
      continue;
    }
    $update_6(c, this$static.m_contactListener);
    c = c.m_next;
  }
}

function $destroy_1(this$static, c){
  var bodyA, bodyB, fixtureA, fixtureB;
  fixtureA = c.m_fixtureA;
  fixtureB = c.m_fixtureB;
  bodyA = fixtureA.m_body;
  bodyB = fixtureB.m_body;
  !!this$static.m_contactListener && (c.m_flags & 2) == 2 && $endContact(this$static.m_contactListener, c);
  !!c.m_prev && (c.m_prev.m_next = c.m_next);
  !!c.m_next && (c.m_next.m_prev = c.m_prev);
  c == this$static.m_contactList && (this$static.m_contactList = c.m_next);
  !!c.m_nodeA.prev && (c.m_nodeA.prev.next = c.m_nodeA.next);
  !!c.m_nodeA.next && (c.m_nodeA.next.prev = c.m_nodeA.prev);
  c.m_nodeA == bodyA.m_contactList && (bodyA.m_contactList = c.m_nodeA.next);
  !!c.m_nodeB.prev && (c.m_nodeB.prev.next = c.m_nodeB.next);
  !!c.m_nodeB.next && (c.m_nodeB.next.prev = c.m_nodeB.prev);
  c.m_nodeB == bodyB.m_contactList && (bodyB.m_contactList = c.m_nodeB.next);
  $pushContact(this$static.pool, c);
  --this$static.m_contactCount;
}

function $findNewContacts(this$static){
  $updatePairs(this$static.m_broadPhase, this$static);
}

function ContactManager_0(argPool, strategy){
  this.m_contactList = null;
  this.m_contactCount = 0;
  this.m_contactFilter = new ContactFilter_0;
  this.m_contactListener = null;
  this.m_broadPhase = new BroadPhase_0(strategy);
  this.pool = argPool;
}

defineSeed(444, 1, {}, ContactManager_0);
_.m_broadPhase = null;
_.m_contactCount = 0;
_.m_contactFilter = null;
_.m_contactList = null;
_.m_contactListener = null;
_.pool = null;
function $set_13(this$static, argOther){
  this$static.categoryBits = argOther.categoryBits;
  this$static.maskBits = argOther.maskBits;
  this$static.groupIndex = argOther.groupIndex;
}

function Filter_0(){
  this.categoryBits = 1;
  this.maskBits = 65535;
  this.groupIndex = 0;
}

defineSeed(445, 1, {}, Filter_0);
_.categoryBits = 0;
_.groupIndex = 0;
_.maskBits = 0;
function $create(this$static, body, def){
  var childCount, i, newLen, old;
  this$static.m_friction = def.friction;
  this$static.m_restitution = def.restitution;
  this$static.m_body = body;
  this$static.m_next = null;
  $set_13(this$static.m_filter, def.filter);
  this$static.m_isSensor = def.isSensor;
  this$static.m_shape = def.shape.clone();
  childCount = this$static.m_shape.getChildCount();
  if (this$static.m_proxies == null) {
    this$static.m_proxies = initDim(_3Lorg_jbox2d_dynamics_FixtureProxy_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$FixtureProxy, childCount, 0);
    for (i = 0; i < childCount; ++i) {
      this$static.m_proxies[i] = new FixtureProxy_0;
      this$static.m_proxies[i].fixture = null;
      this$static.m_proxies[i].proxyId = -1;
    }
  }
  if (this$static.m_proxies.length < childCount) {
    old = this$static.m_proxies;
    newLen = max_1(old.length * 2, childCount);
    this$static.m_proxies = initDim(_3Lorg_jbox2d_dynamics_FixtureProxy_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$FixtureProxy, newLen, 0);
    arraycopy(old, 0, this$static.m_proxies, 0, old.length);
    for (i = 0; i < newLen; ++i) {
      i >= old.length && (this$static.m_proxies[i] = new FixtureProxy_0);
      this$static.m_proxies[i].fixture = null;
      this$static.m_proxies[i].proxyId = -1;
    }
  }
  this$static.m_proxyCount = 0;
  this$static.m_density = def.density;
}

function $createProxies(this$static, broadPhase, xf){
  var i, proxy;
  this$static.m_proxyCount = this$static.m_shape.getChildCount();
  for (i = 0; i < this$static.m_proxyCount; ++i) {
    proxy = this$static.m_proxies[i];
    this$static.m_shape.computeAABB(proxy.aabb, xf, i);
    proxy.proxyId = $createProxy(broadPhase, proxy.aabb, proxy);
    proxy.fixture = this$static;
    proxy.childIndex = i;
  }
}

function $destroyProxies(this$static, broadPhase){
  var i, proxy;
  for (i = 0; i < this$static.m_proxyCount; ++i) {
    proxy = this$static.m_proxies[i];
    $destroyProxy(broadPhase, proxy.proxyId);
    proxy.proxyId = -1;
  }
  this$static.m_proxyCount = 0;
}

function $setSensor(this$static, sensor){
  if (sensor != this$static.m_isSensor) {
    $setAwake(this$static.m_body, true);
    this$static.m_isSensor = sensor;
  }
}

function $synchronize(this$static, broadPhase, transform1, transform2){
  var aab, aabb1, i, proxy;
  if (this$static.m_proxyCount == 0) {
    return;
  }
  for (i = 0; i < this$static.m_proxyCount; ++i) {
    proxy = this$static.m_proxies[i];
    aabb1 = this$static.pool1;
    aab = this$static.pool2;
    this$static.m_shape.computeAABB(aabb1, transform1, proxy.childIndex);
    this$static.m_shape.computeAABB(aab, transform2, proxy.childIndex);
    proxy.aabb.lowerBound.x = aabb1.lowerBound.x < aab.lowerBound.x?aabb1.lowerBound.x:aab.lowerBound.x;
    proxy.aabb.lowerBound.y = aabb1.lowerBound.y < aab.lowerBound.y?aabb1.lowerBound.y:aab.lowerBound.y;
    proxy.aabb.upperBound.x = aabb1.upperBound.x > aab.upperBound.x?aabb1.upperBound.x:aab.upperBound.x;
    proxy.aabb.upperBound.y = aabb1.upperBound.y > aab.upperBound.y?aabb1.upperBound.y:aab.upperBound.y;
    this$static.displacement.x = transform2.p.x - transform1.p.x;
    this$static.displacement.y = transform2.p.y - transform1.p.y;
    $moveProxy(broadPhase, proxy.proxyId, proxy.aabb, this$static.displacement);
  }
}

function Fixture_0(){
  this.pool1 = new AABB_0;
  this.pool2 = new AABB_0;
  this.displacement = new Vec2_0;
  this.m_body = null;
  this.m_next = null;
  this.m_proxies = null;
  this.m_proxyCount = 0;
  this.m_shape = null;
  this.m_filter = new Filter_0;
}

defineSeed(446, 1, {}, Fixture_0);
_.m_body = null;
_.m_density = 0;
_.m_filter = null;
_.m_friction = 0;
_.m_isSensor = false;
_.m_next = null;
_.m_proxies = null;
_.m_proxyCount = 0;
_.m_restitution = 0;
_.m_shape = null;
function FixtureDef_0(){
  this.shape = null;
  this.friction = 0.20000000298023224;
  this.restitution = 0;
  this.density = 0;
  this.filter = new Filter_0;
  this.isSensor = false;
}

defineSeed(447, 1, {}, FixtureDef_0);
_.density = 0;
_.filter = null;
_.friction = 0;
_.isSensor = false;
_.restitution = 0;
_.shape = null;
function FixtureProxy_0(){
  this.aabb = new AABB_0;
}

defineSeed(448, 1, makeCastMap([Q$FixtureProxy]), FixtureProxy_0);
_.childIndex = 0;
_.fixture = null;
_.proxyId = 0;
function $add_11(this$static, body){
  body.m_islandIndex = this$static.m_bodyCount;
  this$static.m_bodies[this$static.m_bodyCount] = body;
  ++this$static.m_bodyCount;
}

function $add_12(this$static, contact){
  setCheck(this$static.m_contacts, this$static.m_contactCount++, contact);
}

function $clear_3(this$static){
  this$static.m_bodyCount = 0;
  this$static.m_contactCount = 0;
  this$static.m_jointCount = 0;
}

function $init_0(this$static, bodyCapacity, contactCapacity, jointCapacity, listener){
  var i, old;
  this$static.m_bodyCapacity = bodyCapacity;
  this$static.m_contactCapacity = contactCapacity;
  this$static.m_jointCapacity = jointCapacity;
  this$static.m_bodyCount = 0;
  this$static.m_contactCount = 0;
  this$static.m_jointCount = 0;
  this$static.m_listener = listener;
  (this$static.m_bodies == null || this$static.m_bodyCapacity > this$static.m_bodies.length) && (this$static.m_bodies = initDim(_3Lorg_jbox2d_dynamics_Body_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Body, this$static.m_bodyCapacity, 0));
  (this$static.m_joints == null || this$static.m_jointCapacity > this$static.m_joints.length) && (this$static.m_joints = initDim(_3Lorg_jbox2d_dynamics_joints_Joint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Joint, this$static.m_jointCapacity, 0));
  (this$static.m_contacts == null || this$static.m_contactCapacity > this$static.m_contacts.length) && (this$static.m_contacts = initDim(_3Lorg_jbox2d_dynamics_contacts_Contact_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Contact, this$static.m_contactCapacity, 0));
  if (this$static.m_velocities == null || this$static.m_bodyCapacity > this$static.m_velocities.length) {
    old = this$static.m_velocities == null?initDim(_3Lorg_jbox2d_dynamics_contacts_Velocity_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Velocity, 0, 0):this$static.m_velocities;
    this$static.m_velocities = initDim(_3Lorg_jbox2d_dynamics_contacts_Velocity_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Velocity, this$static.m_bodyCapacity, 0);
    arraycopy(old, 0, this$static.m_velocities, 0, old.length);
    for (i = old.length; i < this$static.m_velocities.length; ++i) {
      this$static.m_velocities[i] = new Velocity_0;
    }
  }
  if (this$static.m_positions == null || this$static.m_bodyCapacity > this$static.m_positions.length) {
    old = this$static.m_positions == null?initDim(_3Lorg_jbox2d_dynamics_contacts_Position_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Position, 0, 0):this$static.m_positions;
    this$static.m_positions = initDim(_3Lorg_jbox2d_dynamics_contacts_Position_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Position, this$static.m_bodyCapacity, 0);
    arraycopy(old, 0, this$static.m_positions, 0, old.length);
    for (i = old.length; i < this$static.m_positions.length; ++i) {
      this$static.m_positions[i] = new Position_0;
    }
  }
}

function $report(this$static, constraints){
  var i, j, vc;
  if (!this$static.m_listener) {
    return;
  }
  for (i = 0; i < this$static.m_contactCount; ++i) {
    vc = constraints[i];
    for (j = 0; j < vc.pointCount; ++j) {
      this$static.impulse.normalImpulses[j] = vc.points[j].normalImpulse;
      this$static.impulse.tangentImpulses[j] = vc.points[j].tangentImpulse;
    }
  }
}

--></script>
<script><!--
function $solve(this$static, profile, step, gravity, allowSleep){
  var a, a1, b, body, c, contactsOkay, h_0, i, j, jointOkay, jointsOkay, minSleepTime, positionSolved, ratio, rotation, translationx, translationy, v, w;
  h_0 = step.dt;
  for (i = 0; i < this$static.m_bodyCount; ++i) {
    b = this$static.m_bodies[i];
    c = b.m_sweep.c;
    a = b.m_sweep.a_0;
    v = b.m_linearVelocity;
    w = b.m_angularVelocity;
    $set_12(b.m_sweep.c0, b.m_sweep.c);
    b.m_sweep.a0 = b.m_sweep.a_0;
    if (b.m_type == ($clinit_BodyType() , DYNAMIC)) {
      v.x += h_0 * (b.m_gravityScale * gravity.x + b.m_invMass * b.m_force.x);
      v.y += h_0 * (b.m_gravityScale * gravity.y + b.m_invMass * b.m_force.y);
      w += h_0 * b.m_invI * b.m_torque;
      a1 = clamp(1 - h_0 * b.m_linearDamping, 0, 1);
      v.x *= a1;
      v.y *= a1;
      w *= clamp(1 - h_0 * b.m_angularDamping, 0, 1);
    }
    this$static.m_positions[i].c.x = c.x;
    this$static.m_positions[i].c.y = c.y;
    this$static.m_positions[i].a_0 = a;
    this$static.m_velocities[i].v.x = v.x;
    this$static.m_velocities[i].v.y = v.y;
    this$static.m_velocities[i].w = w;
  }
  this$static.timer.resetMillis = Date.now();
  this$static.solverDef.step = step;
  this$static.solverDef.contacts = this$static.m_contacts;
  this$static.solverDef.count = this$static.m_contactCount;
  this$static.solverDef.positions = this$static.m_positions;
  this$static.solverDef.velocities = this$static.m_velocities;
  $init_2(this$static.contactSolver, this$static.solverDef);
  $initializeVelocityConstraints(this$static.contactSolver);
  step.warmStarting && $warmStart(this$static.contactSolver);
  for (i = 0; i < this$static.m_jointCount; ++i) {
    null.nullMethod();
  }
  profile.solveInit = $getMilliseconds(this$static.timer);
  this$static.timer.resetMillis = Date.now();
  for (i = 0; i < step.velocityIterations; ++i) {
    for (j = 0; j < this$static.m_jointCount; ++j) {
      null.nullMethod();
    }
    $solveVelocityConstraints(this$static.contactSolver);
  }
  $storeImpulses(this$static.contactSolver);
  profile.solveVelocity = $getMilliseconds(this$static.timer);
  for (i = 0; i < this$static.m_bodyCount; ++i) {
    c = this$static.m_positions[i].c;
    a = this$static.m_positions[i].a_0;
    v = this$static.m_velocities[i].v;
    w = this$static.m_velocities[i].w;
    translationx = v.x * h_0;
    translationy = v.y * h_0;
    if (translationx * translationx + translationy * translationy > 4) {
      ratio = 2 / ($clinit_MathUtils() , Math.sqrt(translationx * translationx + translationy * translationy));
      v.x *= ratio;
      v.y *= ratio;
    }
    rotation = h_0 * w;
    if (rotation * rotation > ($clinit_Settings() , 2.4674012660980225)) {
      ratio = 1.5707963705062866 / ($clinit_MathUtils() , rotation > 0?rotation:-rotation);
      w *= ratio;
    }
    c.x += h_0 * v.x;
    c.y += h_0 * v.y;
    a += h_0 * w;
    this$static.m_positions[i].a_0 = a;
    this$static.m_velocities[i].w = w;
  }
  this$static.timer.resetMillis = Date.now();
  positionSolved = false;
  for (i = 0; i < step.positionIterations; ++i) {
    contactsOkay = $solvePositionConstraints(this$static.contactSolver);
    jointsOkay = true;
    for (j = 0; j < this$static.m_jointCount; ++j) {
      jointOkay = null.nullMethod();
      jointsOkay = jointsOkay && jointOkay;
    }
    if (contactsOkay && jointsOkay) {
      positionSolved = true;
      break;
    }
  }
  for (i = 0; i < this$static.m_bodyCount; ++i) {
    body = this$static.m_bodies[i];
    body.m_sweep.c.x = this$static.m_positions[i].c.x;
    body.m_sweep.c.y = this$static.m_positions[i].c.y;
    body.m_sweep.a_0 = this$static.m_positions[i].a_0;
    body.m_linearVelocity.x = this$static.m_velocities[i].v.x;
    body.m_linearVelocity.y = this$static.m_velocities[i].v.y;
    body.m_angularVelocity = this$static.m_velocities[i].w;
    $synchronizeTransform(body);
  }
  profile.solvePosition = $getMilliseconds(this$static.timer);
  $report(this$static, this$static.contactSolver.m_velocityConstraints);
  if (allowSleep) {
    minSleepTime = 3.4028234663852886E38;
    for (i = 0; i < this$static.m_bodyCount; ++i) {
      b = this$static.m_bodies[i];
      if (b.m_type == ($clinit_BodyType() , STATIC_0)) {
        continue;
      }
      if ((b.m_flags & 4) == 0 || b.m_angularVelocity * b.m_angularVelocity > 0.001218469929881394 || dot_0(b.m_linearVelocity, b.m_linearVelocity) > 9.999999747378752E-5) {
        b.m_sleepTime = 0;
        minSleepTime = 0;
      }
       else {
        b.m_sleepTime += h_0;
        minSleepTime = min(minSleepTime, b.m_sleepTime);
      }
    }
    if (minSleepTime >= 0.5 && positionSolved) {
      for (i = 0; i < this$static.m_bodyCount; ++i) {
        b = this$static.m_bodies[i];
        $setAwake(b, false);
      }
    }
  }
}

function $solveTOI(this$static, subStep, toiIndexA, toiIndexB){
  var a, body, c, contactsOkay, h_0, i, ratio, rotation, translationx, translationy, v, w;
  for (i = 0; i < this$static.m_bodyCount; ++i) {
    this$static.m_positions[i].c.x = this$static.m_bodies[i].m_sweep.c.x;
    this$static.m_positions[i].c.y = this$static.m_bodies[i].m_sweep.c.y;
    this$static.m_positions[i].a_0 = this$static.m_bodies[i].m_sweep.a_0;
    this$static.m_velocities[i].v.x = this$static.m_bodies[i].m_linearVelocity.x;
    this$static.m_velocities[i].v.y = this$static.m_bodies[i].m_linearVelocity.y;
    this$static.m_velocities[i].w = this$static.m_bodies[i].m_angularVelocity;
  }
  this$static.toiSolverDef.contacts = this$static.m_contacts;
  this$static.toiSolverDef.count = this$static.m_contactCount;
  this$static.toiSolverDef.step = subStep;
  this$static.toiSolverDef.positions = this$static.m_positions;
  this$static.toiSolverDef.velocities = this$static.m_velocities;
  $init_2(this$static.toiContactSolver, this$static.toiSolverDef);
  for (i = 0; i < subStep.positionIterations; ++i) {
    contactsOkay = $solveTOIPositionConstraints(this$static.toiContactSolver, toiIndexA, toiIndexB);
    if (contactsOkay) {
      break;
    }
  }
  this$static.m_bodies[toiIndexA].m_sweep.c0.x = this$static.m_positions[toiIndexA].c.x;
  this$static.m_bodies[toiIndexA].m_sweep.c0.y = this$static.m_positions[toiIndexA].c.y;
  this$static.m_bodies[toiIndexA].m_sweep.a0 = this$static.m_positions[toiIndexA].a_0;
  $set_12(this$static.m_bodies[toiIndexB].m_sweep.c0, this$static.m_positions[toiIndexB].c);
  this$static.m_bodies[toiIndexB].m_sweep.a0 = this$static.m_positions[toiIndexB].a_0;
  $initializeVelocityConstraints(this$static.toiContactSolver);
  for (i = 0; i < subStep.velocityIterations; ++i) {
    $solveVelocityConstraints(this$static.toiContactSolver);
  }
  h_0 = subStep.dt;
  for (i = 0; i < this$static.m_bodyCount; ++i) {
    c = this$static.m_positions[i].c;
    a = this$static.m_positions[i].a_0;
    v = this$static.m_velocities[i].v;
    w = this$static.m_velocities[i].w;
    translationx = v.x * h_0;
    translationy = v.y * h_0;
    if (translationx * translationx + translationy * translationy > 4) {
      ratio = 2 / ($clinit_MathUtils() , Math.sqrt(translationx * translationx + translationy * translationy));
      $mulLocal(v, ratio);
    }
    rotation = h_0 * w;
    if (rotation * rotation > ($clinit_Settings() , 2.4674012660980225)) {
      ratio = 1.5707963705062866 / ($clinit_MathUtils() , rotation > 0?rotation:-rotation);
      w *= ratio;
    }
    c.x += v.x * h_0;
    c.y += v.y * h_0;
    a += h_0 * w;
    this$static.m_positions[i].c.x = c.x;
    this$static.m_positions[i].c.y = c.y;
    this$static.m_positions[i].a_0 = a;
    this$static.m_velocities[i].v.x = v.x;
    this$static.m_velocities[i].v.y = v.y;
    this$static.m_velocities[i].w = w;
    body = this$static.m_bodies[i];
    body.m_sweep.c.x = c.x;
    body.m_sweep.c.y = c.y;
    body.m_sweep.a_0 = a;
    body.m_linearVelocity.x = v.x;
    body.m_linearVelocity.y = v.y;
    body.m_angularVelocity = w;
    $synchronizeTransform(body);
  }
  $report(this$static, this$static.toiContactSolver.m_velocityConstraints);
}

function Island_0(){
  this.contactSolver = new ContactSolver_0;
  this.timer = new Timer_2;
  this.solverDef = new ContactSolver$ContactSolverDef_0;
  this.toiContactSolver = new ContactSolver_0;
  this.toiSolverDef = new ContactSolver$ContactSolverDef_0;
  this.impulse = new ContactImpulse_0;
}

defineSeed(449, 1, {}, Island_0);
_.m_bodies = null;
_.m_bodyCapacity = 0;
_.m_bodyCount = 0;
_.m_contactCapacity = 0;
_.m_contactCount = 0;
_.m_contacts = null;
_.m_jointCapacity = 0;
_.m_jointCount = 0;
_.m_joints = null;
_.m_listener = null;
_.m_positions = null;
_.m_velocities = null;
function Profile_0(){
}

defineSeed(450, 1, {}, Profile_0);
_.solveInit = 0;
_.solvePosition = 0;
_.solveVelocity = 0;
function TimeStep_0(){
}

defineSeed(451, 1, {}, TimeStep_0);
_.dt = 0;
_.dtRatio = 0;
_.inv_dt = 0;
_.positionIterations = 0;
_.velocityIterations = 0;
_.warmStarting = false;
function $clinit_World(){
  $clinit_World = nullMethod;
  new Integer_0(1234598372);
}

function $addType(this$static, creator, type1, type2){
  var register, register2;
  register = new ContactRegister_0;
  register.creator = creator;
  register.primary = true;
  this$static.contactStacks[type1.ordinal][type2.ordinal] = register;
  if (type1 != type2) {
    register2 = new ContactRegister_0;
    register2.creator = creator;
    register2.primary = false;
    this$static.contactStacks[type2.ordinal][type1.ordinal] = register2;
  }
}

function $clearForces(this$static){
  var body;
  for (body = this$static.m_bodyList; body; body = body.m_next) {
    $setZero_0(body.m_force);
    body.m_torque = 0;
  }
}

function $createBody(this$static, def){
  var b;
  if ((this$static.m_flags & 2) == 2) {
    return null;
  }
  b = new Body_0(def, this$static);
  b.m_prev = null;
  b.m_next = this$static.m_bodyList;
  !!this$static.m_bodyList && (this$static.m_bodyList.m_prev = b);
  this$static.m_bodyList = b;
  ++this$static.m_bodyCount;
  return b;
}

function $destroyBody(this$static, body){
  var ce, ce0, f, f0;
  if ((this$static.m_flags & 2) == 2) {
    return;
  }
  ce = body.m_contactList;
  while (ce) {
    ce0 = ce;
    ce = ce.next;
    $destroy_1(this$static.m_contactManager, ce0.contact);
  }
  body.m_contactList = null;
  f = body.m_fixtureList;
  while (f) {
    f0 = f;
    f = f.m_next;
    $destroyProxies(f0, this$static.m_contactManager.m_broadPhase);
    f0.m_shape = null;
    f0.m_proxies = null;
    f0.m_next = null;
    body.m_fixtureList = f;
    body.m_fixtureCount -= 1;
  }
  body.m_fixtureList = null;
  body.m_fixtureCount = 0;
  !!body.m_prev && (body.m_prev.m_next = body.m_next);
  !!body.m_next && (body.m_next.m_prev = body.m_prev);
  body == this$static.m_bodyList && (this$static.m_bodyList = body.m_next);
  --this$static.m_bodyCount;
}

function $popContact(this$static, fixtureA, indexA, fixtureB, indexB){
  var c, creator, reg, type1, type2;
  type1 = fixtureA.m_shape.m_type;
  type2 = fixtureB.m_shape.m_type;
  reg = this$static.contactStacks[type1.ordinal][type2.ordinal];
  creator = reg.creator;
  if (creator) {
    if (reg.primary) {
      c = (creator.index_0 >= creator.size && $extendStack(creator, creator.size * 2) , creator.stack_0[creator.index_0++]);
      c.init(fixtureA, indexA, fixtureB, indexB);
      return c;
    }
     else {
      c = (creator.index_0 >= creator.size && $extendStack(creator, creator.size * 2) , creator.stack_0[creator.index_0++]);
      c.init(fixtureB, indexB, fixtureA, indexA);
      return c;
    }
  }
   else {
    return null;
  }
}

function $pushContact(this$static, contact){
  var creator, fixtureA, fixtureB, type1, type2;
  fixtureA = contact.m_fixtureA;
  fixtureB = contact.m_fixtureB;
  if (contact.m_manifold.pointCount > 0 && !fixtureA.m_isSensor && !fixtureB.m_isSensor) {
    $setAwake(fixtureA.m_body, true);
    $setAwake(fixtureB.m_body, true);
  }
  type1 = fixtureA.m_shape.m_type;
  type2 = fixtureB.m_shape.m_type;
  creator = this$static.contactStacks[type1.ordinal][type2.ordinal].creator;
  setCheck(creator.stack_0, --creator.index_0, contact);
}

function $solve_0(this$static, step){
  var b, c, ce, contact, i, other, seed, sensorA, sensorB, stackCount, stackSize;
  this$static.m_profile.solveInit = 0;
  this$static.m_profile.solveVelocity = 0;
  this$static.m_profile.solvePosition = 0;
  $init_0(this$static.island, this$static.m_bodyCount, this$static.m_contactManager.m_contactCount, this$static.m_jointCount, this$static.m_contactManager.m_contactListener);
  for (b = this$static.m_bodyList; b; b = b.m_next) {
    b.m_flags &= -2;
  }
  for (c = this$static.m_contactManager.m_contactList; c; c = c.m_next) {
    c.m_flags &= -2;
  }
  stackSize = this$static.m_bodyCount;
  this$static.stack_0.length < stackSize && (this$static.stack_0 = initDim(_3Lorg_jbox2d_dynamics_Body_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Body, stackSize, 0));
  for (seed = this$static.m_bodyList; seed; seed = seed.m_next) {
    if ((seed.m_flags & 1) == 1) {
      continue;
    }
    if ((seed.m_flags & 2) != 2 || (seed.m_flags & 32) != 32) {
      continue;
    }
    if (seed.m_type == ($clinit_BodyType() , STATIC_0)) {
      continue;
    }
    $clear_3(this$static.island);
    stackCount = 0;
    this$static.stack_0[stackCount++] = seed;
    seed.m_flags |= 1;
    while (stackCount > 0) {
      b = this$static.stack_0[--stackCount];
      $add_11(this$static.island, b);
      $setAwake(b, true);
      if (b.m_type == STATIC_0) {
        continue;
      }
      for (ce = b.m_contactList; ce; ce = ce.next) {
        contact = ce.contact;
        if ((contact.m_flags & 1) == 1) {
          continue;
        }
        if ((contact.m_flags & 4) != 4 || (contact.m_flags & 2) != 2) {
          continue;
        }
        sensorA = contact.m_fixtureA.m_isSensor;
        sensorB = contact.m_fixtureB.m_isSensor;
        if (sensorA || sensorB) {
          continue;
        }
        $add_12(this$static.island, contact);
        contact.m_flags |= 1;
        other = ce.other;
        if ((other.m_flags & 1) == 1) {
          continue;
        }
        this$static.stack_0[stackCount++] = other;
        other.m_flags |= 1;
      }
    }
    $solve(this$static.island, this$static.islandProfile, step, this$static.m_gravity, this$static.m_allowSleep);
    this$static.m_profile.solveInit += this$static.islandProfile.solveInit;
    this$static.m_profile.solveVelocity += this$static.islandProfile.solveVelocity;
    this$static.m_profile.solvePosition += this$static.islandProfile.solvePosition;
    for (i = 0; i < this$static.island.m_bodyCount; ++i) {
      b = this$static.island.m_bodies[i];
      b.m_type == STATIC_0 && (b.m_flags &= -2);
    }
  }
  this$static.broadphaseTimer.resetMillis = Date.now();
  for (b = this$static.m_bodyList; b; b = b.m_next) {
    if ((b.m_flags & 1) == 0) {
      continue;
    }
    if (b.m_type == ($clinit_BodyType() , STATIC_0)) {
      continue;
    }
    $synchronizeFixtures(b);
  }
  $findNewContacts(this$static.m_contactManager);
  $getMilliseconds(this$static.broadphaseTimer);
}

function $solveTOI_0(this$static, step){
  var activeA, activeB, alpha, alpha0, b, bA, bB, beta, body, c, ce, collideA, collideB, contact, fA, fB, i, indexA, indexB, input, island, minAlpha, minContact, other, sensorA, sensorB, typeA, typeB;
  island = this$static.toiIsland;
  $init_0(island, 64, 32, 0, this$static.m_contactManager.m_contactListener);
  if (this$static.m_stepComplete) {
    for (b = this$static.m_bodyList; b; b = b.m_next) {
      b.m_flags &= -2;
      b.m_sweep.alpha0 = 0;
    }
    for (c = this$static.m_contactManager.m_contactList; c; c = c.m_next) {
      c.m_flags &= -34;
      c.m_toiCount = 0;
      c.m_toi = 1;
    }
  }
  for (;;) {
    minContact = null;
    minAlpha = 1;
    for (c = this$static.m_contactManager.m_contactList; c; c = c.m_next) {
      if ((c.m_flags & 4) != 4) {
        continue;
      }
      if (c.m_toiCount > 8) {
        continue;
      }
      if ((c.m_flags & 32) != 0) {
        alpha = c.m_toi;
      }
       else {
        fA = c.m_fixtureA;
        fB = c.m_fixtureB;
        if (fA.m_isSensor || fB.m_isSensor) {
          continue;
        }
        bA = fA.m_body;
        bB = fB.m_body;
        typeA = bA.m_type;
        typeB = bB.m_type;
        activeA = (bA.m_flags & 2) == 2 && typeA != ($clinit_BodyType() , STATIC_0);
        activeB = (bB.m_flags & 2) == 2 && typeB != ($clinit_BodyType() , STATIC_0);
        if (!activeA && !activeB) {
          continue;
        }
        collideA = (bA.m_flags & 8) == 8 || typeA != ($clinit_BodyType() , DYNAMIC);
        collideB = (bB.m_flags & 8) == 8 || typeB != ($clinit_BodyType() , DYNAMIC);
        if (!collideA && !collideB) {
          continue;
        }
        alpha0 = bA.m_sweep.alpha0;
        if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {
          alpha0 = bB.m_sweep.alpha0;
          $advance(bA.m_sweep, alpha0);
        }
         else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {
          alpha0 = bA.m_sweep.alpha0;
          $advance(bB.m_sweep, alpha0);
        }
        indexA = c.m_indexA;
        indexB = c.m_indexB;
        input = this$static.toiInput;
        $set_3(input.proxyA, fA.m_shape, indexA);
        $set_3(input.proxyB, fB.m_shape, indexB);
        $set_9(input.sweepA, bA.m_sweep);
        $set_9(input.sweepB, bB.m_sweep);
        input.tMax = 1;
        $timeOfImpact(this$static.pool.toi, this$static.toiOutput, input);
        beta = this$static.toiOutput.t;
        this$static.toiOutput.state == ($clinit_TimeOfImpact$TOIOutputState() , TOUCHING)?(alpha = ($clinit_MathUtils() , alpha0 + (1 - alpha0) * beta < 1?alpha0 + (1 - alpha0) * beta:1)):(alpha = 1);
        c.m_toi = alpha;
        c.m_flags |= 32;
      }
      if (alpha < minAlpha) {
        minContact = c;
        minAlpha = alpha;
      }
    }
    if (!minContact || 0.9999988079071045 < minAlpha) {
      this$static.m_stepComplete = true;
      break;
    }
    fA = minContact.m_fixtureA;
    fB = minContact.m_fixtureB;
    bA = fA.m_body;
    bB = fB.m_body;
    $set_9(this$static.backup1, bA.m_sweep);
    $set_9(this$static.backup2, bB.m_sweep);
    $advance_0(bA, minAlpha);
    $advance_0(bB, minAlpha);
    $update_6(minContact, this$static.m_contactManager.m_contactListener);
    minContact.m_flags &= -33;
    ++minContact.m_toiCount;
    if ((minContact.m_flags & 4) != 4 || (minContact.m_flags & 2) != 2) {
      minContact.m_flags &= -5;
      $set_9(bA.m_sweep, this$static.backup1);
      $set_9(bB.m_sweep, this$static.backup2);
      $synchronizeTransform(bA);
      $synchronizeTransform(bB);
      continue;
    }
    $setAwake(bA, true);
    $setAwake(bB, true);
    $clear_3(island);
    $add_11(island, bA);
    $add_11(island, bB);
    setCheck(island.m_contacts, island.m_contactCount++, minContact);
    bA.m_flags |= 1;
    bB.m_flags |= 1;
    minContact.m_flags |= 1;
    this$static.tempBodies[0] = bA;
    this$static.tempBodies[1] = bB;
    for (i = 0; i < 2; ++i) {
      body = this$static.tempBodies[i];
      if (body.m_type == ($clinit_BodyType() , DYNAMIC)) {
        for (ce = body.m_contactList; ce; ce = ce.next) {
          if (island.m_bodyCount == island.m_bodyCapacity) {
            break;
          }
          if (island.m_contactCount == island.m_contactCapacity) {
            break;
          }
          contact = ce.contact;
          if ((contact.m_flags & 1) != 0) {
            continue;
          }
          other = ce.other;
          if (other.m_type == DYNAMIC && (body.m_flags & 8) != 8 && (other.m_flags & 8) != 8) {
            continue;
          }
          sensorA = contact.m_fixtureA.m_isSensor;
          sensorB = contact.m_fixtureB.m_isSensor;
          if (sensorA || sensorB) {
            continue;
          }
          $set_9(this$static.backup1, other.m_sweep);
          (other.m_flags & 1) == 0 && $advance_0(other, minAlpha);
          $update_6(contact, this$static.m_contactManager.m_contactListener);
          if ((contact.m_flags & 4) != 4) {
            $set_9(other.m_sweep, this$static.backup1);
            $synchronizeTransform(other);
            continue;
          }
          if ((contact.m_flags & 2) != 2) {
            $set_9(other.m_sweep, this$static.backup1);
            $synchronizeTransform(other);
            continue;
          }
          contact.m_flags |= 1;
          setCheck(island.m_contacts, island.m_contactCount++, contact);
          if ((other.m_flags & 1) != 0) {
            continue;
          }
          other.m_flags |= 1;
          other.m_type != STATIC_0 && $setAwake(other, true);
          $add_11(island, other);
        }
      }
    }
    this$static.subStep.dt = (1 - minAlpha) * step.dt;
    this$static.subStep.inv_dt = 1 / this$static.subStep.dt;
    this$static.subStep.dtRatio = 1;
    this$static.subStep.positionIterations = 20;
    this$static.subStep.velocityIterations = step.velocityIterations;
    this$static.subStep.warmStarting = false;
    $solveTOI(island, this$static.subStep, bA.m_islandIndex, bB.m_islandIndex);
    for (i = 0; i < island.m_bodyCount; ++i) {
      body = island.m_bodies[i];
      body.m_flags &= -2;
      if (body.m_type != ($clinit_BodyType() , DYNAMIC)) {
        continue;
      }
      $synchronizeFixtures(body);
      for (ce = body.m_contactList; ce; ce = ce.next) {
        ce.contact.m_flags &= -34;
      }
    }
    $findNewContacts(this$static.m_contactManager);
    if (this$static.m_subStepping) {
      this$static.m_stepComplete = false;
      break;
    }
  }
}

function $step(this$static){
  this$static.stepTimer.resetMillis = Date.now();
  if ((this$static.m_flags & 1) == 1) {
    $findNewContacts(this$static.m_contactManager);
    this$static.m_flags &= -2;
  }
  this$static.m_flags |= 2;
  this$static.step.dt = 0.032999999821186066;
  this$static.step.velocityIterations = 6;
  this$static.step.positionIterations = 3;
  this$static.step.inv_dt = 30.303030014038086;
  this$static.step.dtRatio = this$static.m_inv_dt0 * 0.032999999821186066;
  this$static.step.warmStarting = this$static.m_warmStarting;
  this$static.tempTimer.resetMillis = Date.now();
  $collide_0(this$static.m_contactManager);
  $getMilliseconds(this$static.tempTimer);
  if (this$static.m_stepComplete && this$static.step.dt > 0) {
    this$static.tempTimer.resetMillis = Date.now();
    $solve_0(this$static, this$static.step);
    $getMilliseconds(this$static.tempTimer);
  }
  if (this$static.m_continuousPhysics && this$static.step.dt > 0) {
    this$static.tempTimer.resetMillis = Date.now();
    $solveTOI_0(this$static, this$static.step);
    $getMilliseconds(this$static.tempTimer);
  }
  this$static.step.dt > 0 && (this$static.m_inv_dt0 = this$static.step.inv_dt);
  (this$static.m_flags & 4) == 4 && $clearForces(this$static);
  this$static.m_flags &= -3;
  $getMilliseconds(this$static.stepTimer);
}

function World_0(gravity){
  $clinit_World();
  World_1.call(this, gravity, new DefaultWorldPool_0);
}

function World_1(gravity, pool){
  World_2.call(this, gravity, pool, new DynamicTree_0);
}

function World_2(gravity, argPool, broadPhaseStrategy){
  this.m_gravity = new Vec2_0;
  this.contactStacks = initDims([_3_3Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit, _3Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit], [makeCastMap([Q$Serializable, Q$Object_$1]), makeCastMap([Q$Serializable, Q$Object_$1, Q$ContactRegister_$1])], [Q$ContactRegister_$1, Q$ContactRegister], [($clinit_ShapeType() , $clinit_ShapeType() , $VALUES_18).length, $VALUES_18.length], 2, 0);
  this.step = new TimeStep_0;
  this.stepTimer = new Timer_2;
  this.tempTimer = new Timer_2;
  new Transform_0;
  new Vec2_0;
  new Vec2_0;
  new Vec2Array_0;
  new WorldRayCastWrapper_0;
  new RayCastInput_0;
  this.island = new Island_0;
  this.stack_0 = initDim(_3Lorg_jbox2d_dynamics_Body_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Body, 10, 0);
  this.islandProfile = new Profile_0;
  this.broadphaseTimer = new Timer_2;
  this.toiIsland = new Island_0;
  this.toiInput = new TimeOfImpact$TOIInput_0;
  this.toiOutput = new TimeOfImpact$TOIOutput_0;
  this.subStep = new TimeStep_0;
  this.tempBodies = initDim(_3Lorg_jbox2d_dynamics_Body_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Body, 2, 0);
  this.backup1 = new Sweep_0;
  this.backup2 = new Sweep_0;
  new Vec2_0;
  new Vec2_0;
  new Vec2_0;
  new Vec2_0;
  new Vec2_0;
  new Vec2_0;
  new Vec2Array_0;
  this.pool = argPool;
  this.m_bodyList = null;
  this.m_bodyCount = 0;
  this.m_jointCount = 0;
  this.m_warmStarting = true;
  this.m_continuousPhysics = true;
  this.m_subStepping = false;
  this.m_stepComplete = true;
  this.m_allowSleep = true;
  $set_12(this.m_gravity, gravity);
  this.m_flags = 4;
  this.m_inv_dt0 = 0;
  this.m_contactManager = new ContactManager_0(this, broadPhaseStrategy);
  this.m_profile = new Profile_0;
  $addType(this, this.pool.ccstack, CIRCLE, CIRCLE);
  $addType(this, this.pool.cpstack, POLYGON, CIRCLE);
  $addType(this, this.pool.pcstack, POLYGON, POLYGON);
  $addType(this, this.pool.ecstack, EDGE, CIRCLE);
  $addType(this, this.pool.epstack, EDGE, POLYGON);
  $addType(this, this.pool.chcstack, CHAIN, CIRCLE);
  $addType(this, this.pool.chpstack, CHAIN, POLYGON);
}

defineSeed(452, 1, {}, World_0);
_.m_allowSleep = false;
_.m_bodyCount = 0;
_.m_bodyList = null;
_.m_contactManager = null;
_.m_continuousPhysics = false;
_.m_flags = 0;
_.m_inv_dt0 = 0;
_.m_jointCount = 0;
_.m_profile = null;
_.m_stepComplete = false;
_.m_subStepping = false;
_.m_warmStarting = false;
_.pool = null;
function WorldRayCastWrapper_0(){
  new RayCastOutput_0;
  new Vec2_0;
  new Vec2_0;
}

defineSeed(453, 1, {}, WorldRayCastWrapper_0);
function $init_1(this$static, fA, indexA, fB, indexB){
  this$static.m_flags = 0;
  this$static.m_fixtureA = fA;
  this$static.m_fixtureB = fB;
  this$static.m_indexA = indexA;
  this$static.m_indexB = indexB;
  this$static.m_manifold.pointCount = 0;
  this$static.m_prev = null;
  this$static.m_next = null;
  this$static.m_nodeA.contact = null;
  this$static.m_nodeA.prev = null;
  this$static.m_nodeA.next = null;
  this$static.m_nodeA.other = null;
  this$static.m_nodeB.contact = null;
  this$static.m_nodeB.prev = null;
  this$static.m_nodeB.next = null;
  this$static.m_nodeB.other = null;
  this$static.m_toiCount = 0;
  this$static.m_friction = ($clinit_MathUtils() , sqrt(fA.m_friction * fB.m_friction));
  this$static.m_restitution = mixRestitution(fA.m_restitution, fB.m_restitution);
  this$static.m_tangentSpeed = 0;
}

function $update_6(this$static, listener){
  var bodyA, bodyB, i, id2, j, mp1, mp2, sensor, sensorA, sensorB, shapeA, shapeB, touching, wasTouching, xfA, xfB;
  $set_5(this$static.oldManifold, this$static.m_manifold);
  this$static.m_flags |= 4;
  wasTouching = (this$static.m_flags & 2) == 2;
  sensorA = this$static.m_fixtureA.m_isSensor;
  sensorB = this$static.m_fixtureB.m_isSensor;
  sensor = sensorA || sensorB;
  bodyA = this$static.m_fixtureA.m_body;
  bodyB = this$static.m_fixtureB.m_body;
  xfA = bodyA.m_xf;
  xfB = bodyB.m_xf;
  if (sensor) {
    shapeA = this$static.m_fixtureA.m_shape;
    shapeB = this$static.m_fixtureB.m_shape;
    touching = $testOverlap(this$static.pool.collision, shapeA, this$static.m_indexA, shapeB, this$static.m_indexB, xfA, xfB);
    this$static.m_manifold.pointCount = 0;
  }
   else {
    this$static.evaluate(this$static.m_manifold, xfA, xfB);
    touching = this$static.m_manifold.pointCount > 0;
    for (i = 0; i < this$static.m_manifold.pointCount; ++i) {
      mp2 = this$static.m_manifold.points[i];
      mp2.normalImpulse = 0;
      mp2.tangentImpulse = 0;
      id2 = mp2.id_0;
      for (j = 0; j < this$static.oldManifold.pointCount; ++j) {
        mp1 = this$static.oldManifold.points[j];
        if ($isEqual(mp1.id_0, id2)) {
          mp2.normalImpulse = mp1.normalImpulse;
          mp2.tangentImpulse = mp1.tangentImpulse;
          break;
        }
      }
    }
    if (touching != wasTouching) {
      $setAwake(bodyA, true);
      $setAwake(bodyB, true);
    }
  }
  touching?(this$static.m_flags |= 2):(this$static.m_flags &= -3);
  if (!listener) {
    return;
  }
  !wasTouching && touching && $add_10(listener.contacts, this$static);
  wasTouching && !touching && $add_10(listener.release, this$static);
}

function Contact_0(argPool){
  this.oldManifold = new Manifold_0;
  this.m_fixtureA = null;
  this.m_fixtureB = null;
  this.m_nodeA = new ContactEdge_0;
  this.m_nodeB = new ContactEdge_0;
  this.m_manifold = new Manifold_0;
  this.pool = argPool;
}

function mixRestitution(restitution1, restitution2){
  return restitution1 > restitution2?restitution1:restitution2;
}

defineSeed(455, 1, makeCastMap([Q$Contact]));
_.init = function init_0(fA, indexA, fB, indexB){
  $init_1(this, fA, indexA, fB, indexB);
}
;
_.m_fixtureA = null;
_.m_fixtureB = null;
_.m_flags = 0;
_.m_friction = 0;
_.m_indexA = 0;
_.m_indexB = 0;
_.m_manifold = null;
_.m_next = null;
_.m_nodeA = null;
_.m_nodeB = null;
_.m_prev = null;
_.m_restitution = 0;
_.m_tangentSpeed = 0;
_.m_toi = 0;
_.m_toiCount = 0;
_.pool = null;
function ChainAndCircleContact_0(argPool){
  Contact_0.call(this, argPool);
  this.edge = new EdgeShape_0;
}

defineSeed(454, 455, makeCastMap([Q$Contact]), ChainAndCircleContact_0);
_.evaluate = function evaluate(manifold, xfA, xfB){
  this.m_fixtureA.m_shape;
  null.nullMethod();
  $collideEdgeAndCircle(this.pool.collision, manifold, this.edge, xfA, this.m_fixtureB.m_shape, xfB);
}
;
_.init = function init_1(fA, indexA, fB, indexB){
  $init_1(this, fA, indexA, fB, indexB);
}
;
function ChainAndPolygonContact_0(argPool){
  Contact_0.call(this, argPool);
  this.edge = new EdgeShape_0;
}

defineSeed(456, 455, makeCastMap([Q$Contact]), ChainAndPolygonContact_0);
--></script>
<script><!--
_.evaluate = function evaluate_0(manifold, xfA, xfB){
  this.m_fixtureA.m_shape;
  null.nullMethod();
  $collideEdgeAndPolygon(this.pool.collision, manifold, this.edge, xfA, this.m_fixtureB.m_shape, xfB);
}
;
_.init = function init_2(fA, indexA, fB, indexB){
  $init_1(this, fA, indexA, fB, indexB);
}
;
function CircleContact_0(argPool){
  Contact_0.call(this, argPool);
}

defineSeed(457, 455, makeCastMap([Q$Contact]), CircleContact_0);
_.evaluate = function evaluate_1(manifold, xfA, xfB){
  $collideCircles(manifold, this.m_fixtureA.m_shape, xfA, this.m_fixtureB.m_shape, xfB);
}
;
function ContactEdge_0(){
}

defineSeed(458, 1, {}, ContactEdge_0);
_.contact = null;
_.next = null;
_.other = null;
_.prev = null;
function ContactPositionConstraint_0(){
  var i;
  this.localPoints = initDim(_3Lorg_jbox2d_common_Vec2_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Vec2, 2, 0);
  this.localNormal = new Vec2_0;
  this.localPoint = new Vec2_0;
  this.localCenterA = new Vec2_0;
  this.localCenterB = new Vec2_0;
  for (i = 0; i < this.localPoints.length; ++i) {
    this.localPoints[i] = new Vec2_0;
  }
}

defineSeed(459, 1, makeCastMap([Q$ContactPositionConstraint]), ContactPositionConstraint_0);
_.indexA = 0;
_.indexB = 0;
_.invIA = 0;
_.invIB = 0;
_.invMassA = 0;
_.invMassB = 0;
_.pointCount = 0;
_.radiusA = 0;
_.radiusB = 0;
_.type_0 = null;
function ContactRegister_0(){
}

defineSeed(460, 1, makeCastMap([Q$ContactRegister]), ContactRegister_0);
_.creator = null;
_.primary = false;
function $init_2(this$static, def){
  var bodyA, bodyB, contact, cp, fixtureA, fixtureB, i, j, manifold, old, pc, pointCount, radiusA, radiusB, shapeA, shapeB, vc, vcp;
  this$static.m_step = def.step;
  this$static.m_count = def.count;
  if (this$static.m_positionConstraints.length < this$static.m_count) {
    old = this$static.m_positionConstraints;
    this$static.m_positionConstraints = initDim(_3Lorg_jbox2d_dynamics_contacts_ContactPositionConstraint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ContactPositionConstraint, max_1(old.length * 2, this$static.m_count), 0);
    arraycopy(old, 0, this$static.m_positionConstraints, 0, old.length);
    for (i = old.length; i < this$static.m_positionConstraints.length; ++i) {
      this$static.m_positionConstraints[i] = new ContactPositionConstraint_0;
    }
  }
  if (this$static.m_velocityConstraints.length < this$static.m_count) {
    old = this$static.m_velocityConstraints;
    this$static.m_velocityConstraints = initDim(_3Lorg_jbox2d_dynamics_contacts_ContactVelocityConstraint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ContactVelocityConstraint, max_1(old.length * 2, this$static.m_count), 0);
    arraycopy(old, 0, this$static.m_velocityConstraints, 0, old.length);
    for (i = old.length; i < this$static.m_velocityConstraints.length; ++i) {
      this$static.m_velocityConstraints[i] = new ContactVelocityConstraint_0;
    }
  }
  this$static.m_positions = def.positions;
  this$static.m_velocities = def.velocities;
  this$static.m_contacts = def.contacts;
  for (i = 0; i < this$static.m_count; ++i) {
    contact = this$static.m_contacts[i];
    fixtureA = contact.m_fixtureA;
    fixtureB = contact.m_fixtureB;
    shapeA = fixtureA.m_shape;
    shapeB = fixtureB.m_shape;
    radiusA = shapeA.m_radius;
    radiusB = shapeB.m_radius;
    bodyA = fixtureA.m_body;
    bodyB = fixtureB.m_body;
    manifold = contact.m_manifold;
    pointCount = manifold.pointCount;
    vc = this$static.m_velocityConstraints[i];
    vc.friction = contact.m_friction;
    vc.restitution = contact.m_restitution;
    vc.tangentSpeed = contact.m_tangentSpeed;
    vc.indexA = bodyA.m_islandIndex;
    vc.indexB = bodyB.m_islandIndex;
    vc.invMassA = bodyA.m_invMass;
    vc.invMassB = bodyB.m_invMass;
    vc.invIA = bodyA.m_invI;
    vc.invIB = bodyB.m_invI;
    vc.contactIndex = i;
    vc.pointCount = pointCount;
    $setZero(vc.K);
    $setZero(vc.normalMass);
    pc = this$static.m_positionConstraints[i];
    pc.indexA = bodyA.m_islandIndex;
    pc.indexB = bodyB.m_islandIndex;
    pc.invMassA = bodyA.m_invMass;
    pc.invMassB = bodyB.m_invMass;
    $set_12(pc.localCenterA, bodyA.m_sweep.localCenter);
    $set_12(pc.localCenterB, bodyB.m_sweep.localCenter);
    pc.invIA = bodyA.m_invI;
    pc.invIB = bodyB.m_invI;
    $set_12(pc.localNormal, manifold.localNormal);
    $set_12(pc.localPoint, manifold.localPoint);
    pc.pointCount = pointCount;
    pc.radiusA = radiusA;
    pc.radiusB = radiusB;
    pc.type_0 = manifold.type_0;
    for (j = 0; j < pointCount; ++j) {
      cp = manifold.points[j];
      vcp = vc.points[j];
      if (this$static.m_step.warmStarting) {
        vcp.normalImpulse = this$static.m_step.dtRatio * cp.normalImpulse;
        vcp.tangentImpulse = this$static.m_step.dtRatio * cp.tangentImpulse;
      }
       else {
        vcp.normalImpulse = 0;
        vcp.tangentImpulse = 0;
      }
      $setZero_0(vcp.rA);
      $setZero_0(vcp.rB);
      vcp.normalMass = 0;
      vcp.tangentMass = 0;
      vcp.velocityBias = 0;
      pc.localPoints[j].x = cp.localPoint.x;
      pc.localPoints[j].y = cp.localPoint.y;
    }
  }
}

function $initializeVelocityConstraints(this$static){
  var aA, aB, cA, cB, i, iA, iB, indexA, indexB, j, k11, k12, k22, kNormal, kTangent, localCenterA, localCenterB, mA, mB, manifold, pc, pointCount, radiusA, radiusB, rn1A, rn1B, rn2A, rn2B, rnA, rnB, rtA, rtB, tangentx, tangenty, tempx, tempy, vA, vB, vRel, vc, vcp, vcp1, vcp2, wA, wB;
  for (i = 0; i < this$static.m_count; ++i) {
    vc = this$static.m_velocityConstraints[i];
    pc = this$static.m_positionConstraints[i];
    radiusA = pc.radiusA;
    radiusB = pc.radiusB;
    manifold = this$static.m_contacts[vc.contactIndex].m_manifold;
    indexA = vc.indexA;
    indexB = vc.indexB;
    mA = vc.invMassA;
    mB = vc.invMassB;
    iA = vc.invIA;
    iB = vc.invIB;
    localCenterA = pc.localCenterA;
    localCenterB = pc.localCenterB;
    cA = this$static.m_positions[indexA].c;
    aA = this$static.m_positions[indexA].a_0;
    vA = this$static.m_velocities[indexA].v;
    wA = this$static.m_velocities[indexA].w;
    cB = this$static.m_positions[indexB].c;
    aB = this$static.m_positions[indexB].a_0;
    vB = this$static.m_velocities[indexB].v;
    wB = this$static.m_velocities[indexB].w;
    $set_7(this$static.xfA.q, aA);
    $set_7(this$static.xfB.q, aB);
    this$static.xfA.p.x = cA.x - (this$static.xfA.q.c * localCenterA.x - this$static.xfA.q.s * localCenterA.y);
    this$static.xfA.p.y = cA.y - (this$static.xfA.q.s * localCenterA.x + this$static.xfA.q.c * localCenterA.y);
    this$static.xfB.p.x = cB.x - (this$static.xfB.q.c * localCenterB.x - this$static.xfB.q.s * localCenterB.y);
    this$static.xfB.p.y = cB.y - (this$static.xfB.q.s * localCenterB.x + this$static.xfB.q.c * localCenterB.y);
    $initialize_0(this$static.worldManifold, manifold, this$static.xfA, radiusA, this$static.xfB, radiusB);
    $set_12(vc.normal, this$static.worldManifold.normal);
    pointCount = vc.pointCount;
    for (j = 0; j < pointCount; ++j) {
      vcp = vc.points[j];
      $subLocal($set_12(vcp.rA, this$static.worldManifold.points[j]), cA);
      $subLocal($set_12(vcp.rB, this$static.worldManifold.points[j]), cB);
      rnA = vcp.rA.x * vc.normal.y - vcp.rA.y * vc.normal.x;
      rnB = vcp.rB.x * vc.normal.y - vcp.rB.y * vc.normal.x;
      kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
      vcp.normalMass = kNormal > 0?1 / kNormal:0;
      tangentx = vc.normal.y;
      tangenty = -vc.normal.x;
      rtA = vcp.rA.x * tangenty - vcp.rA.y * tangentx;
      rtB = vcp.rB.x * tangenty - vcp.rB.y * tangentx;
      kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
      vcp.tangentMass = kTangent > 0?1 / kTangent:0;
      vcp.velocityBias = 0;
      tempx = vB.x + -wB * vcp.rB.y - vA.x - -wA * vcp.rA.y;
      tempy = vB.y + wB * vcp.rB.x - vA.y - wA * vcp.rA.x;
      vRel = vc.normal.x * tempx + vc.normal.y * tempy;
      vRel < -1 && (vcp.velocityBias = -vc.restitution * vRel);
    }
    if (vc.pointCount == 2) {
      vcp1 = vc.points[0];
      vcp2 = vc.points[1];
      rn1A = cross(vcp1.rA, vc.normal);
      rn1B = cross(vcp1.rB, vc.normal);
      rn2A = cross(vcp2.rA, vc.normal);
      rn2B = cross(vcp2.rB, vc.normal);
      k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
      k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
      k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
      if (k11 * k11 < 100 * (k11 * k22 - k12 * k12)) {
        $set_11(vc.K.ex, k11, k12);
        $set_11(vc.K.ey, k12, k22);
        $invertToOut(vc.K, vc.normalMass);
      }
       else {
        vc.pointCount = 1;
      }
    }
  }
}

function $solvePositionConstraints(this$static){
  var C, K, aA, aB, cA, cB, i, iA, iB, impulse, indexA, indexB, j, localCenterA, localCenterB, mA, mB, minSeparation, normal, pc, point, pointCount, psm, rnA, rnB, separation;
  minSeparation = 0;
  for (i = 0; i < this$static.m_count; ++i) {
    pc = this$static.m_positionConstraints[i];
    indexA = pc.indexA;
    indexB = pc.indexB;
    mA = pc.invMassA;
    iA = pc.invIA;
    localCenterA = pc.localCenterA;
    mB = pc.invMassB;
    iB = pc.invIB;
    localCenterB = pc.localCenterB;
    pointCount = pc.pointCount;
    cA = this$static.m_positions[indexA].c;
    aA = this$static.m_positions[indexA].a_0;
    cB = this$static.m_positions[indexB].c;
    aB = this$static.m_positions[indexB].a_0;
    for (j = 0; j < pointCount; ++j) {
      $set_7(this$static.xfA.q, aA);
      $set_7(this$static.xfB.q, aB);
      mulToOutUnsafe_0(this$static.xfA.q, localCenterA, this$static.xfA.p);
      $addLocal($negateLocal(this$static.xfA.p), cA);
      mulToOutUnsafe_0(this$static.xfB.q, localCenterB, this$static.xfB.p);
      $addLocal($negateLocal(this$static.xfB.p), cB);
      psm = this$static.psolver;
      $initialize_1(psm, pc, this$static.xfA, this$static.xfB, j);
      normal = psm.normal;
      point = psm.point;
      separation = psm.separation;
      $subLocal($set_12(this$static.rA, point), cA);
      $subLocal($set_12(this$static.rB, point), cB);
      minSeparation = ($clinit_MathUtils() , minSeparation < separation?minSeparation:separation);
      C = -0.20000000298023224 > (0.20000000298023224 * (separation + 0.004999999888241291) < 0?0.20000000298023224 * (separation + 0.004999999888241291):0)?-0.20000000298023224:0.20000000298023224 * (separation + 0.004999999888241291) < 0?0.20000000298023224 * (separation + 0.004999999888241291):0;
      rnA = cross(this$static.rA, normal);
      rnB = cross(this$static.rB, normal);
      K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
      impulse = K > 0?-C / K:0;
      $mulLocal($set_12(this$static.P, normal), impulse);
      $subLocal(cA, $mulLocal($set_12(this$static.temp, this$static.P), mA));
      aA -= iA * cross(this$static.rA, this$static.P);
      $addLocal(cB, $mulLocal($set_12(this$static.temp, this$static.P), mB));
      aB += iB * cross(this$static.rB, this$static.P);
    }
    this$static.m_positions[indexA].a_0 = aA;
    this$static.m_positions[indexB].a_0 = aB;
  }
  return minSeparation >= -0.014999999664723873;
}

function $solveTOIPositionConstraints(this$static, toiIndexA, toiIndexB){
  var C, K, aA, aB, cA, cB, i, iA, iB, impulse, indexA, indexB, j, localCenterA, localCenterB, mA, mB, minSeparation, normal, pc, point, pointCount, psm, rnA, rnB, separation;
  minSeparation = 0;
  for (i = 0; i < this$static.m_count; ++i) {
    pc = this$static.m_positionConstraints[i];
    indexA = pc.indexA;
    indexB = pc.indexB;
    localCenterA = pc.localCenterA;
    localCenterB = pc.localCenterB;
    pointCount = pc.pointCount;
    mA = 0;
    iA = 0;
    if (indexA == toiIndexA || indexA == toiIndexB) {
      mA = pc.invMassA;
      iA = pc.invIA;
    }
    mB = 0;
    iB = 0;
    if (indexB == toiIndexA || indexB == toiIndexB) {
      mB = pc.invMassB;
      iB = pc.invIB;
    }
    cA = this$static.m_positions[indexA].c;
    aA = this$static.m_positions[indexA].a_0;
    cB = this$static.m_positions[indexB].c;
    aB = this$static.m_positions[indexB].a_0;
    for (j = 0; j < pointCount; ++j) {
      $set_7(this$static.xfA.q, aA);
      $set_7(this$static.xfB.q, aB);
      mulToOutUnsafe_0(this$static.xfA.q, localCenterA, this$static.xfA.p);
      $addLocal($negateLocal(this$static.xfA.p), cA);
      mulToOutUnsafe_0(this$static.xfB.q, localCenterB, this$static.xfB.p);
      $addLocal($negateLocal(this$static.xfB.p), cB);
      psm = this$static.psolver;
      $initialize_1(psm, pc, this$static.xfA, this$static.xfB, j);
      normal = psm.normal;
      point = psm.point;
      separation = psm.separation;
      $subLocal($set_12(this$static.rA, point), cA);
      $subLocal($set_12(this$static.rB, point), cB);
      minSeparation = ($clinit_MathUtils() , minSeparation < separation?minSeparation:separation);
      C = -0.20000000298023224 > (0.75 * (separation + 0.004999999888241291) < 0?0.75 * (separation + 0.004999999888241291):0)?-0.20000000298023224:0.75 * (separation + 0.004999999888241291) < 0?0.75 * (separation + 0.004999999888241291):0;
      rnA = cross(this$static.rA, normal);
      rnB = cross(this$static.rB, normal);
      K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
      impulse = K > 0?-C / K:0;
      $mulLocal($set_12(this$static.P, normal), impulse);
      $subLocal(cA, $mulLocal($set_12(this$static.temp, this$static.P), mA));
      aA -= iA * cross(this$static.rA, this$static.P);
      $addLocal(cB, $mulLocal($set_12(this$static.temp, this$static.P), mB));
      aB += iB * cross(this$static.rB, this$static.P);
    }
    this$static.m_positions[indexA].a_0 = aA;
    this$static.m_positions[indexB].a_0 = aB;
  }
  return minSeparation >= -0.007499999832361937;
}

function $solveVelocityConstraints(this$static){
  var Px, Py, R, a, cp1, cp2, dvx, dvy, friction, i, iA, iB, indexA, indexB, j, lambda, mA, mB, maxFriction, newImpulse, normal, pointCount, vA, vB, vc, vcp, vn, vn1, vn2, vt, wA, wB;
  for (i = 0; i < this$static.m_count; ++i) {
    vc = this$static.m_velocityConstraints[i];
    indexA = vc.indexA;
    indexB = vc.indexB;
    mA = vc.invMassA;
    mB = vc.invMassB;
    iA = vc.invIA;
    iB = vc.invIB;
    pointCount = vc.pointCount;
    vA = this$static.m_velocities[indexA].v;
    wA = this$static.m_velocities[indexA].w;
    vB = this$static.m_velocities[indexB].v;
    wB = this$static.m_velocities[indexB].w;
    normal = vc.normal;
    this$static.tangent.x = vc.normal.y;
    this$static.tangent.y = -vc.normal.x;
    friction = vc.friction;
    for (j = 0; j < pointCount; ++j) {
      vcp = vc.points[j];
      a = vcp.rA;
      dvx = -wB * vcp.rB.y + vB.x - vA.x + wA * a.y;
      dvy = wB * vcp.rB.x + vB.y - vA.y - wA * a.x;
      vt = dvx * this$static.tangent.x + dvy * this$static.tangent.y - vc.tangentSpeed;
      lambda = vcp.tangentMass * -vt;
      maxFriction = friction * vcp.normalImpulse;
      newImpulse = clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);
      lambda = newImpulse - vcp.tangentImpulse;
      vcp.tangentImpulse = newImpulse;
      Px = this$static.tangent.x * lambda;
      Py = this$static.tangent.y * lambda;
      vA.x -= Px * mA;
      vA.y -= Py * mA;
      wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
      vB.x += Px * mB;
      vB.y += Py * mB;
      wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
    }
    if (vc.pointCount == 1) {
      vcp = vc.points[0];
      dvx = -wB * vcp.rB.y + vB.x - vA.x + wA * vcp.rA.y;
      dvy = wB * vcp.rB.x + vB.y - vA.y - wA * vcp.rA.x;
      vn = dvx * normal.x + dvy * normal.y;
      lambda = -vcp.normalMass * (vn - vcp.velocityBias);
      a = vcp.normalImpulse + lambda;
      newImpulse = a > 0?a:0;
      lambda = newImpulse - vcp.normalImpulse;
      vcp.normalImpulse = newImpulse;
      Px = normal.x * lambda;
      Py = normal.y * lambda;
      vA.x -= Px * mA;
      vA.y -= Py * mA;
      wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
      vB.x += Px * mB;
      vB.y += Py * mB;
      wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
    }
     else {
      cp1 = vc.points[0];
      cp2 = vc.points[1];
      this$static.a_0.x = cp1.normalImpulse;
      this$static.a_0.y = cp2.normalImpulse;
      this$static.dv1.x = -wB * cp1.rB.y + vB.x - vA.x + wA * cp1.rA.y;
      this$static.dv1.y = wB * cp1.rB.x + vB.y - vA.y - wA * cp1.rA.x;
      this$static.dv2.x = -wB * cp2.rB.y + vB.x - vA.x + wA * cp2.rA.y;
      this$static.dv2.y = wB * cp2.rB.x + vB.y - vA.y - wA * cp2.rA.x;
      vn1 = this$static.dv1.x * normal.x + this$static.dv1.y * normal.y;
      vn2 = this$static.dv2.x * normal.x + this$static.dv2.y * normal.y;
      this$static.b.x = vn1 - cp1.velocityBias;
      this$static.b.y = vn2 - cp2.velocityBias;
      R = vc.K;
      this$static.b.x -= R.ex.x * this$static.a_0.x + R.ey.x * this$static.a_0.y;
      this$static.b.y -= R.ex.y * this$static.a_0.x + R.ey.y * this$static.a_0.y;
      for (;;) {
        mulToOutUnsafe(vc.normalMass, this$static.b, this$static.x);
        this$static.x.x *= -1;
        this$static.x.y *= -1;
        if (this$static.x.x >= 0 && this$static.x.y >= 0) {
          $subLocal($set_12(this$static.d, this$static.x), this$static.a_0);
          $mulLocal($set_12(this$static.P1, normal), this$static.d.x);
          $mulLocal($set_12(this$static.P2, normal), this$static.d.y);
          $addLocal($set_12(this$static.temp1, this$static.P1), this$static.P2);
          $mulLocal($set_12(this$static.temp2, this$static.temp1), mA);
          $subLocal(vA, this$static.temp2);
          $mulLocal($set_12(this$static.temp2, this$static.temp1), mB);
          $addLocal(vB, this$static.temp2);
          wA -= iA * (cross(cp1.rA, this$static.P1) + cross(cp2.rA, this$static.P2));
          wB += iB * (cross(cp1.rB, this$static.P1) + cross(cp2.rB, this$static.P2));
          cp1.normalImpulse = this$static.x.x;
          cp2.normalImpulse = this$static.x.y;
          break;
        }
        this$static.x.x = -cp1.normalMass * this$static.b.x;
        this$static.x.y = 0;
        vn2 = vc.K.ex.y * this$static.x.x + this$static.b.y;
        if (this$static.x.x >= 0 && vn2 >= 0) {
          $subLocal($set_12(this$static.d, this$static.x), this$static.a_0);
          $mulLocal($set_12(this$static.P1, normal), this$static.d.x);
          $mulLocal($set_12(this$static.P2, normal), this$static.d.y);
          $addLocal($set_12(this$static.temp1, this$static.P1), this$static.P2);
          $mulLocal($set_12(this$static.temp2, this$static.temp1), mA);
          $subLocal(vA, this$static.temp2);
          $mulLocal($set_12(this$static.temp2, this$static.temp1), mB);
          $addLocal(vB, this$static.temp2);
          wA -= iA * (cross(cp1.rA, this$static.P1) + cross(cp2.rA, this$static.P2));
          wB += iB * (cross(cp1.rB, this$static.P1) + cross(cp2.rB, this$static.P2));
          cp1.normalImpulse = this$static.x.x;
          cp2.normalImpulse = this$static.x.y;
          break;
        }
        this$static.x.x = 0;
        this$static.x.y = -cp2.normalMass * this$static.b.y;
        vn1 = vc.K.ey.x * this$static.x.y + this$static.b.x;
        if (this$static.x.y >= 0 && vn1 >= 0) {
          $subLocal($set_12(this$static.d, this$static.x), this$static.a_0);
          $mulLocal($set_12(this$static.P1, normal), this$static.d.x);
          $mulLocal($set_12(this$static.P2, normal), this$static.d.y);
          $addLocal($set_12(this$static.temp1, this$static.P1), this$static.P2);
          $mulLocal($set_12(this$static.temp2, this$static.temp1), mA);
          $subLocal(vA, this$static.temp2);
          $mulLocal($set_12(this$static.temp2, this$static.temp1), mB);
          $addLocal(vB, this$static.temp2);
          wA -= iA * (cross(cp1.rA, this$static.P1) + cross(cp2.rA, this$static.P2));
          wB += iB * (cross(cp1.rB, this$static.P1) + cross(cp2.rB, this$static.P2));
          cp1.normalImpulse = this$static.x.x;
          cp2.normalImpulse = this$static.x.y;
          break;
        }
        this$static.x.x = 0;
        this$static.x.y = 0;
        vn1 = this$static.b.x;
        vn2 = this$static.b.y;
        if (vn1 >= 0 && vn2 >= 0) {
          $subLocal($set_12(this$static.d, this$static.x), this$static.a_0);
          $mulLocal($set_12(this$static.P1, normal), this$static.d.x);
          $mulLocal($set_12(this$static.P2, normal), this$static.d.y);
          $addLocal($set_12(this$static.temp1, this$static.P1), this$static.P2);
          $mulLocal($set_12(this$static.temp2, this$static.temp1), mA);
          $subLocal(vA, this$static.temp2);
          $mulLocal($set_12(this$static.temp2, this$static.temp1), mB);
          $addLocal(vB, this$static.temp2);
          wA -= iA * (cross(cp1.rA, this$static.P1) + cross(cp2.rA, this$static.P2));
          wB += iB * (cross(cp1.rB, this$static.P1) + cross(cp2.rB, this$static.P2));
          cp1.normalImpulse = this$static.x.x;
          cp2.normalImpulse = this$static.x.y;
          break;
        }
        break;
      }
    }
    this$static.m_velocities[indexA].w = wA;
    this$static.m_velocities[indexB].w = wB;
  }
}

function $storeImpulses(this$static){
  var i, j, manifold, vc;
  for (i = 0; i < this$static.m_count; ++i) {
    vc = this$static.m_velocityConstraints[i];
    manifold = this$static.m_contacts[vc.contactIndex].m_manifold;
    for (j = 0; j < vc.pointCount; ++j) {
      manifold.points[j].normalImpulse = vc.points[j].normalImpulse;
      manifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;
    }
  }
}

function $warmStart(this$static){
  var Px, Py, i, iA, iB, indexA, indexB, j, mA, mB, normal, pointCount, tangentx, tangenty, vA, vB, vc, vcp, wA, wB;
  for (i = 0; i < this$static.m_count; ++i) {
    vc = this$static.m_velocityConstraints[i];
    indexA = vc.indexA;
    indexB = vc.indexB;
    mA = vc.invMassA;
    iA = vc.invIA;
    mB = vc.invMassB;
    iB = vc.invIB;
    pointCount = vc.pointCount;
    vA = this$static.m_velocities[indexA].v;
    wA = this$static.m_velocities[indexA].w;
    vB = this$static.m_velocities[indexB].v;
    wB = this$static.m_velocities[indexB].w;
    normal = vc.normal;
    tangentx = normal.y;
    tangenty = -normal.x;
    for (j = 0; j < pointCount; ++j) {
      vcp = vc.points[j];
      Px = tangentx * vcp.tangentImpulse + normal.x * vcp.normalImpulse;
      Py = tangenty * vcp.tangentImpulse + normal.y * vcp.normalImpulse;
      wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
      vA.x -= Px * mA;
      vA.y -= Py * mA;
      wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
      vB.x += Px * mB;
      vB.y += Py * mB;
    }
    this$static.m_velocities[indexA].w = wA;
    this$static.m_velocities[indexB].w = wB;
  }
}

function ContactSolver_0(){
  var i;
  this.tangent = new Vec2_0;
  this.temp1 = new Vec2_0;
  this.temp2 = new Vec2_0;
  this.P = new Vec2_0;
  this.temp = new Vec2_0;
  this.xfA = new Transform_0;
  this.xfB = new Transform_0;
  this.worldManifold = new WorldManifold_0;
  this.a_0 = new Vec2_0;
  this.b = new Vec2_0;
  this.dv1 = new Vec2_0;
  this.dv2 = new Vec2_0;
  this.x = new Vec2_0;
  this.d = new Vec2_0;
  this.P1 = new Vec2_0;
  this.P2 = new Vec2_0;
  this.psolver = new PositionSolverManifold_0;
  this.rA = new Vec2_0;
  this.rB = new Vec2_0;
  this.m_positionConstraints = initDim(_3Lorg_jbox2d_dynamics_contacts_ContactPositionConstraint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ContactPositionConstraint, 256, 0);
  this.m_velocityConstraints = initDim(_3Lorg_jbox2d_dynamics_contacts_ContactVelocityConstraint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ContactVelocityConstraint, 256, 0);
  for (i = 0; i < 256; ++i) {
    this.m_positionConstraints[i] = new ContactPositionConstraint_0;
    this.m_velocityConstraints[i] = new ContactVelocityConstraint_0;
  }
}

defineSeed(461, 1, {}, ContactSolver_0);
_.m_contacts = null;
_.m_count = 0;
_.m_positionConstraints = null;
_.m_positions = null;
_.m_step = null;
_.m_velocities = null;
_.m_velocityConstraints = null;
function ContactSolver$ContactSolverDef_0(){
}

defineSeed(462, 1, {}, ContactSolver$ContactSolverDef_0);
_.contacts = null;
_.count = 0;
_.positions = null;
_.step = null;
_.velocities = null;
function ContactVelocityConstraint_0(){
  var i;
  this.points = initDim(_3Lorg_jbox2d_dynamics_contacts_ContactVelocityConstraint$VelocityConstraintPoint_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$ContactVelocityConstraint$VelocityConstraintPoint, 2, 0);
  this.normal = new Vec2_0;
  this.normalMass = new Mat22_0;
  this.K = new Mat22_0;
  for (i = 0; i < this.points.length; ++i) {
    this.points[i] = new ContactVelocityConstraint$VelocityConstraintPoint_0;
  }
}

defineSeed(463, 1, makeCastMap([Q$ContactVelocityConstraint]), ContactVelocityConstraint_0);
_.contactIndex = 0;
_.friction = 0;
_.indexA = 0;
_.indexB = 0;
_.invIA = 0;
_.invIB = 0;
_.invMassA = 0;
_.invMassB = 0;
_.pointCount = 0;
_.restitution = 0;
_.tangentSpeed = 0;
function ContactVelocityConstraint$VelocityConstraintPoint_0(){
  this.rA = new Vec2_0;
  this.rB = new Vec2_0;
}

defineSeed(464, 1, makeCastMap([Q$ContactVelocityConstraint$VelocityConstraintPoint]), ContactVelocityConstraint$VelocityConstraintPoint_0);
_.normalImpulse = 0;
_.normalMass = 0;
_.tangentImpulse = 0;
_.tangentMass = 0;
_.velocityBias = 0;
function EdgeAndCircleContact_0(argPool){
  Contact_0.call(this, argPool);
}

defineSeed(465, 455, makeCastMap([Q$Contact]), EdgeAndCircleContact_0);
_.evaluate = function evaluate_2(manifold, xfA, xfB){
  $collideEdgeAndCircle(this.pool.collision, manifold, this.m_fixtureA.m_shape, xfA, this.m_fixtureB.m_shape, xfB);
}
;
_.init = function init_3(fA, indexA, fB, indexB){
  $init_1(this, fA, indexA, fB, indexB);
}
;
function EdgeAndPolygonContact_0(argPool){
  Contact_0.call(this, argPool);
}

defineSeed(466, 455, makeCastMap([Q$Contact]), EdgeAndPolygonContact_0);
_.evaluate = function evaluate_3(manifold, xfA, xfB){
  $collideEdgeAndPolygon(this.pool.collision, manifold, this.m_fixtureA.m_shape, xfA, this.m_fixtureB.m_shape, xfB);
}
;
_.init = function init_4(fA, indexA, fB, indexB){
  $init_1(this, fA, indexA, fB, indexB);
}
;
function PolygonAndCircleContact_0(argPool){
  Contact_0.call(this, argPool);
}

defineSeed(467, 455, makeCastMap([Q$Contact]), PolygonAndCircleContact_0);
_.evaluate = function evaluate_4(manifold, xfA, xfB){
  $collidePolygonAndCircle(manifold, this.m_fixtureA.m_shape, xfA, this.m_fixtureB.m_shape, xfB);
}
;
function PolygonContact_0(argPool){
  Contact_0.call(this, argPool);
}

defineSeed(468, 455, makeCastMap([Q$Contact]), PolygonContact_0);
_.evaluate = function evaluate_5(manifold, xfA, xfB){
  $collidePolygons(this.pool.collision, manifold, this.m_fixtureA.m_shape, xfA, this.m_fixtureB.m_shape, xfB);
}
;
function Position_0(){
  this.c = new Vec2_0;
}

defineSeed(469, 1, makeCastMap([Q$Position]), Position_0);
_.a_0 = 0;
--></script>
<script><!--
function $initialize_1(this$static, pc, xfA, xfB, index){
  var clipPointx, clipPointy, pLocalPoints0, pcLocalNormal, pcLocalPoint, pcLocalPointsI, planePointx, planePointy, plocalPoint, pointAx, pointAy, pointBx, pointBy, tempx, tempy, xfAq, xfBq;
  xfAq = xfA.q;
  xfBq = xfB.q;
  pcLocalPointsI = pc.localPoints[index];
  switch (pc.type_0.ordinal) {
    case 0:
      {
        plocalPoint = pc.localPoint;
        pLocalPoints0 = pc.localPoints[0];
        pointAx = xfAq.c * plocalPoint.x - xfAq.s * plocalPoint.y + xfA.p.x;
        pointAy = xfAq.s * plocalPoint.x + xfAq.c * plocalPoint.y + xfA.p.y;
        pointBx = xfBq.c * pLocalPoints0.x - xfBq.s * pLocalPoints0.y + xfB.p.x;
        pointBy = xfBq.s * pLocalPoints0.x + xfBq.c * pLocalPoints0.y + xfB.p.y;
        this$static.normal.x = pointBx - pointAx;
        this$static.normal.y = pointBy - pointAy;
        $normalize_0(this$static.normal);
        this$static.point.x = (pointAx + pointBx) * 0.5;
        this$static.point.y = (pointAy + pointBy) * 0.5;
        tempx = pointBx - pointAx;
        tempy = pointBy - pointAy;
        this$static.separation = tempx * this$static.normal.x + tempy * this$static.normal.y - pc.radiusA - pc.radiusB;
        break;
      }

    case 1:
      {
        pcLocalNormal = pc.localNormal;
        pcLocalPoint = pc.localPoint;
        this$static.normal.x = xfAq.c * pcLocalNormal.x - xfAq.s * pcLocalNormal.y;
        this$static.normal.y = xfAq.s * pcLocalNormal.x + xfAq.c * pcLocalNormal.y;
        planePointx = xfAq.c * pcLocalPoint.x - xfAq.s * pcLocalPoint.y + xfA.p.x;
        planePointy = xfAq.s * pcLocalPoint.x + xfAq.c * pcLocalPoint.y + xfA.p.y;
        clipPointx = xfBq.c * pcLocalPointsI.x - xfBq.s * pcLocalPointsI.y + xfB.p.x;
        clipPointy = xfBq.s * pcLocalPointsI.x + xfBq.c * pcLocalPointsI.y + xfB.p.y;
        tempx = clipPointx - planePointx;
        tempy = clipPointy - planePointy;
        this$static.separation = tempx * this$static.normal.x + tempy * this$static.normal.y - pc.radiusA - pc.radiusB;
        this$static.point.x = clipPointx;
        this$static.point.y = clipPointy;
        break;
      }

    case 2:
      {
        pcLocalNormal = pc.localNormal;
        pcLocalPoint = pc.localPoint;
        this$static.normal.x = xfBq.c * pcLocalNormal.x - xfBq.s * pcLocalNormal.y;
        this$static.normal.y = xfBq.s * pcLocalNormal.x + xfBq.c * pcLocalNormal.y;
        planePointx = xfBq.c * pcLocalPoint.x - xfBq.s * pcLocalPoint.y + xfB.p.x;
        planePointy = xfBq.s * pcLocalPoint.x + xfBq.c * pcLocalPoint.y + xfB.p.y;
        clipPointx = xfAq.c * pcLocalPointsI.x - xfAq.s * pcLocalPointsI.y + xfA.p.x;
        clipPointy = xfAq.s * pcLocalPointsI.x + xfAq.c * pcLocalPointsI.y + xfA.p.y;
        tempx = clipPointx - planePointx;
        tempy = clipPointy - planePointy;
        this$static.separation = tempx * this$static.normal.x + tempy * this$static.normal.y - pc.radiusA - pc.radiusB;
        this$static.point.x = clipPointx;
        this$static.point.y = clipPointy;
        this$static.normal.x *= -1;
        this$static.normal.y *= -1;
      }

  }
}

function PositionSolverManifold_0(){
  this.normal = new Vec2_0;
  this.point = new Vec2_0;
}

defineSeed(470, 1, {}, PositionSolverManifold_0);
_.separation = 0;
function Velocity_0(){
  this.v = new Vec2_0;
}

defineSeed(471, 1, makeCastMap([Q$Velocity]), Velocity_0);
_.w = 0;
function Vec2Array_0(){
  new HashMap_0;
}

defineSeed(472, 1, {}, Vec2Array_0);
function DefaultWorldPool_0(){
  new HashMap_0;
  new HashMap_0;
  new HashMap_0;
  this.world = this;
  this.pcstack = new DefaultWorldPool$1_0(this, ($clinit_Settings() , 10));
  this.ccstack = new DefaultWorldPool$2_0(this, 10);
  this.cpstack = new DefaultWorldPool$3_0(this, 10);
  this.ecstack = new DefaultWorldPool$4_0(this, 10);
  this.epstack = new DefaultWorldPool$5_0(this, 10);
  this.chcstack = new DefaultWorldPool$6_0(this, 10);
  this.chpstack = new DefaultWorldPool$7_0(this, 10);
  this.vecs = new DefaultWorldPool$8_0;
  new DefaultWorldPool$9_0;
  new DefaultWorldPool$10_0;
  new DefaultWorldPool$11_0;
  new DefaultWorldPool$12_0;
  new DefaultWorldPool$13_0;
  this.dist = new Distance_0;
  this.collision = new Collision_0(this);
  this.toi = new TimeOfImpact_0(this);
}

defineSeed(473, 1, {}, DefaultWorldPool_0);
_.collision = null;
_.dist = null;
_.toi = null;
_.vecs = null;
function $extendStack(this$static, argSize){
  var i, newStack;
  newStack = initDim(_3Ljava_lang_Object_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Object, argSize, 0);
  this$static.stack_0 != null && arraycopy(this$static.stack_0, 0, newStack, 0, this$static.size);
  for (i = 0; i < newStack.length; ++i) {
    setCheck(newStack, i, this$static.newInstance());
  }
  this$static.stack_0 = newStack;
  this$static.size = newStack.length;
}

function MutableStack_0(argInitSize){
  this.index_0 = 0;
  this.stack_0 = null;
  this.index_0 = 0;
  $extendStack(this, argInitSize);
}

defineSeed(475, 1, {});
_.index_0 = 0;
_.size = 0;
_.stack_0 = null;
function DefaultWorldPool$1_0(this$0, $anonymous0){
  this.this$0 = this$0;
  MutableStack_0.call(this, $anonymous0);
}

defineSeed(474, 475, {}, DefaultWorldPool$1_0);
_.newInstance = function newInstance(){
  return new PolygonContact_0(this.this$0.world);
}
;
_.this$0 = null;
function $pop_1(this$static){
  return this$static.pool[this$static.index_0++];
}

function OrderedStack_0(){
  var i;
  this.pool = initDim(_3Ljava_lang_Object_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Object, 100, 0);
  for (i = 0; i < 100; ++i) {
    setCheck(this.pool, i, this.newInstance());
  }
  this.index_0 = 0;
}

defineSeed(477, 1, {});
_.index_0 = 0;
_.pool = null;
function DefaultWorldPool$10_0(){
  OrderedStack_0.call(this);
}

defineSeed(476, 477, {}, DefaultWorldPool$10_0);
_.newInstance = function newInstance_0(){
  return new Mat22_0;
}
;
function DefaultWorldPool$11_0(){
  OrderedStack_0.call(this);
}

defineSeed(478, 477, {}, DefaultWorldPool$11_0);
_.newInstance = function newInstance_1(){
  return new AABB_0;
}
;
function DefaultWorldPool$12_0(){
  OrderedStack_0.call(this);
}

defineSeed(479, 477, {}, DefaultWorldPool$12_0);
_.newInstance = function newInstance_2(){
  return new Rot_0;
}
;
function DefaultWorldPool$13_0(){
  OrderedStack_0.call(this);
}

defineSeed(480, 477, {}, DefaultWorldPool$13_0);
_.newInstance = function newInstance_3(){
  return new Mat33_0;
}
;
function DefaultWorldPool$2_0(this$0, $anonymous0){
  this.this$0 = this$0;
  MutableStack_0.call(this, $anonymous0);
}

defineSeed(481, 475, {}, DefaultWorldPool$2_0);
_.newInstance = function newInstance_4(){
  return new CircleContact_0(this.this$0.world);
}
;
_.this$0 = null;
function DefaultWorldPool$3_0(this$0, $anonymous0){
  this.this$0 = this$0;
  MutableStack_0.call(this, $anonymous0);
}

defineSeed(482, 475, {}, DefaultWorldPool$3_0);
_.newInstance = function newInstance_5(){
  return new PolygonAndCircleContact_0(this.this$0.world);
}
;
_.this$0 = null;
function DefaultWorldPool$4_0(this$0, $anonymous0){
  this.this$0 = this$0;
  MutableStack_0.call(this, $anonymous0);
}

defineSeed(483, 475, {}, DefaultWorldPool$4_0);
_.newInstance = function newInstance_6(){
  return new EdgeAndCircleContact_0(this.this$0.world);
}
;
_.this$0 = null;
function DefaultWorldPool$5_0(this$0, $anonymous0){
  this.this$0 = this$0;
  MutableStack_0.call(this, $anonymous0);
}

defineSeed(484, 475, {}, DefaultWorldPool$5_0);
_.newInstance = function newInstance_7(){
  return new EdgeAndPolygonContact_0(this.this$0.world);
}
;
_.this$0 = null;
function DefaultWorldPool$6_0(this$0, $anonymous0){
  this.this$0 = this$0;
  MutableStack_0.call(this, $anonymous0);
}

defineSeed(485, 475, {}, DefaultWorldPool$6_0);
_.newInstance = function newInstance_8(){
  return new ChainAndCircleContact_0(this.this$0.world);
}
;
_.this$0 = null;
function DefaultWorldPool$7_0(this$0, $anonymous0){
  this.this$0 = this$0;
  MutableStack_0.call(this, $anonymous0);
}

defineSeed(486, 475, {}, DefaultWorldPool$7_0);
_.newInstance = function newInstance_9(){
  return new ChainAndPolygonContact_0(this.this$0.world);
}
;
_.this$0 = null;
function DefaultWorldPool$8_0(){
  OrderedStack_0.call(this);
}

defineSeed(487, 477, {}, DefaultWorldPool$8_0);
_.newInstance = function newInstance_10(){
  return new Vec2_0;
}
;
function DefaultWorldPool$9_0(){
  OrderedStack_0.call(this);
}

defineSeed(488, 477, {}, DefaultWorldPool$9_0);
_.newInstance = function newInstance_11(){
  return new Vec3_0;
}
;
defineSeed(489, 1, {});
defineSeed(490, 1, {});
_.height_1 = function height_0(){
  return this.height_0;
}
;
_.width_1 = function width_0(){
  return this.width_0;
}
;
_.height_0 = 0;
_.width_0 = 0;
function $equals_3(this$static, other){
  var ofont;
  if (instanceOf(other, Q$AbstractFont)) {
    ofont = other;
    return $equals(this$static.name_0, ofont.name_0) && this$static.style_0 == ofont.style_0 && this$static.size == ofont.size;
  }
   else {
    return false;
  }
}

function $hashCode_1(this$static){
  return getHashCode_0(this$static.name_0) ^ getHashCode(this$static.style_0) ^ round_int(this$static.size);
}

function AbstractFont_0(name_0, style, size){
  this.name_0 = name_0;
  this.style_0 = style;
  this.size = size;
}

defineSeed(491, 1, makeCastMap([Q$AbstractFont]));
_.equals$ = function equals_18(other){
  return $equals_3(this, other);
}
;
_.hashCode$ = function hashCode_17(){
  return $hashCode_1(this);
}
;
_.toString$ = function toString_34(){
  return this.name_0 + ' ' + this.style_0 + ' ' + this.size + 'pt';
}
;
_.name_0 = null;
_.size = 0;
_.style_0 = null;
function $addInteractor(this$static, listenerType, listener){
  var newint;
  newint = new AbstractLayer$Interactor_0(listenerType, listener, this$static.rootInteractor);
  this$static.rootInteractor = newint;
  $setInteractive(this$static, true);
  return new AbstractLayer$1_0;
}

function $interact(this$static, type, interaction, current, argument){
  var listener;
  if (!current)
    return;
  $interact(this$static, type, interaction, current.next, argument);
  if (current.listenerType == type) {
    listener = current.listener;
    interaction.interact(listener, argument);
  }
}

function $isSet(this$static, flag){
  return (this$static.flags & flag.bitmask) != 0;
}

function $onAdd(this$static){
  if ($isSet(this$static, ($clinit_AbstractLayer$Flag() , DESTROYED)))
    throw new IllegalStateException_1('Illegal to use destroyed layer: ' + this$static);
}

function $setFlag(this$static, flag, active){
  active?(this$static.flags |= flag.bitmask):(this$static.flags &= ~flag.bitmask);
}

function $setInteractive(this$static, interactive){
  if ($isSet(this$static, ($clinit_AbstractLayer$Flag() , INTERACTIVE)) != interactive) {
    interactive && !!this$static.parent_0 && this$static.parent_0.setInteractive(true);
    $setFlag(this$static, INTERACTIVE, interactive);
  }
  return this$static;
}

function $transform_0(this$static){
  var cosa, m10, sina, tx, ty;
  if ($isSet(this$static, ($clinit_AbstractLayer$Flag() , XFDIRTY))) {
    sina = Math.sin(0);
    cosa = Math.cos(0);
    m10 = -sina;
    tx = this$static.transform_0.tx_0();
    ty = this$static.transform_0.ty_0();
    this$static.transform_0.setTransform(cosa, sina, m10, cosa, tx, ty);
    $setFlag(this$static, XFDIRTY, false);
  }
  return this$static.transform_0;
}

function AbstractLayer_0(transform){
  this.transform_0 = transform;
  $setFlag(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1), true);
}

defineSeed(492, 1, makeCastMap([Q$AbstractLayer, Q$Layer]));
_.addListener = function addListener(listener){
  return $addInteractor(this, Lplayn_core_Pointer$Listener_2_classLit, listener);
}
;
_.destroy = function destroy_12(){
  !!this.parent_0 && this.parent_0.remove_4(this);
  $setFlag(this, ($clinit_AbstractLayer$Flag() , DESTROYED), true);
}
;
_.height_1 = function height_1(){
  return 0;
}
;
_.hitTest = function hitTest(p){
  return this.hitTestDefault(p);
}
;
_.hitTestDefault = function hitTestDefault(p){
  return p.x >= 0 && p.y >= 0 && p.x < this.width_1() && p.y < this.height_1()?this:null;
}
;
_.interactive = function interactive_0(){
  return $isSet(this, ($clinit_AbstractLayer$Flag() , INTERACTIVE));
}
;
_.onAdd = function onAdd(){
  $onAdd(this);
}
;
_.onRemove = function onRemove(){
}
;
_.originX_0 = function originX_0(){
  return this.originX;
}
;
_.originY_0 = function originY_0(){
  return this.originY;
}
;
_.parent_1 = function parent_1(){
  return this.parent_0;
}
;
_.setAlpha = function setAlpha(alpha){
  var ialpha;
  this.alpha_0 = alpha;
  ialpha = ~~Math.max(Math.min(255 * (alpha < 0?0:alpha > 1?1:alpha), 2147483647), -2147483648);
  this.tint = ialpha << 24 | this.tint & 16777215;
  return this;
}
;
_.setInteractive = function setInteractive(interactive){
  return $setInteractive(this, interactive);
}
;
_.setTranslation = function setTranslation(x, y){
  this.transform_0.setTranslation_0(x, y);
  return this;
}
;
_.toString$ = function toString_35(){
  var bldr, cname;
  cname = this.___clazz$.typeName;
  bldr = new StringBuilder_1($substring(cname, cname.lastIndexOf('.') + 1));
  $append_10((bldr.impl.string += ' [hashCode=' , bldr), getHashCode(this));
  $append_11((bldr.impl.string += ', tx=' , bldr), $transform_0(this));
  return bldr.impl.string;
}
;
_.transform_1 = function transform_0(){
  return $transform_0(this);
}
;
_.width_1 = function width_1(){
  return 0;
}
;
_.alpha_0 = 1;
_.depth = 0;
_.flags = 0;
_.originX = 0;
_.originY = 0;
_.parent_0 = null;
_.rootInteractor = null;
_.tint = -1;
_.transform_0 = null;
function AbstractLayer$1_0(){
}

defineSeed(493, 1, {}, AbstractLayer$1_0);
function $clinit_AbstractLayer$Flag(){
  $clinit_AbstractLayer$Flag = nullMethod;
  DESTROYED = new AbstractLayer$Flag_0('DESTROYED', 0, 1);
  VISIBLE_1 = new AbstractLayer$Flag_0('VISIBLE', 1, 2);
  INTERACTIVE = new AbstractLayer$Flag_0('INTERACTIVE', 2, 4);
  SHOWN = new AbstractLayer$Flag_0('SHOWN', 3, 8);
  XFDIRTY = new AbstractLayer$Flag_0('XFDIRTY', 4, 16);
  $VALUES_20 = initValues(_3Lplayn_core_AbstractLayer$Flag_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$AbstractLayer$Flag, [DESTROYED, VISIBLE_1, INTERACTIVE, SHOWN, XFDIRTY]);
}

function AbstractLayer$Flag_0(enum$name, enum$ordinal, bitmask){
  Enum_0.call(this, enum$name, enum$ordinal);
  this.bitmask = bitmask;
}

function values_21(){
  $clinit_AbstractLayer$Flag();
  return $VALUES_20;
}

defineSeed(494, 39, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$AbstractLayer$Flag]), AbstractLayer$Flag_0);
_.bitmask = 0;
var $VALUES_20, DESTROYED, INTERACTIVE, SHOWN, VISIBLE_1, XFDIRTY;
function AbstractLayer$Interactor_0(listenerType, listener, next){
  this.listenerType = listenerType;
  this.listener = listener;
  this.next = next;
}

defineSeed(495, 1, {}, AbstractLayer$Interactor_0);
_.listener = null;
_.listenerType = null;
_.next = null;
function AbstractPlatform_0(log){
  this.log_0 = log;
  this.runQueue = new RunQueue_0;
}

defineSeed(496, 1, {});
_.log_0 = null;
_.runQueue = null;
function $addCallback(this$static, callback){
  this$static.impl?(++callback.this$0.loaded , $update_7(callback.this$0)):this$static.error_0?$onFailure_0(callback, this$static.error_0):(this$static.callbacks = createAdd(this$static.callbacks, callback));
}

function $onLoadError(this$static, error){
  this$static.error_0 = error;
  this$static.callbacks = dispatchFailureClear(this$static.callbacks, error);
}

function $onLoaded(this$static, impl){
  this$static.impl = impl;
  this$static.callbacks = dispatchSuccessClear(this$static.callbacks, this$static);
  this$static.impl.setVolume_0(100);
  $setLoopingImpl(this$static, this$static.looping);
  this$static.playing && this$static.impl.play_0();
}

function $play_0(this$static){
  this$static.playing = true;
  return !!this$static.impl && this$static.impl.play_0();
}

function $setLooping_0(this$static, looping){
  this$static.looping = looping;
  !!this$static.impl && this$static.impl.setLooping_0(looping);
}

function $stop_0(this$static){
  this$static.playing = false;
  !!this$static.impl && this$static.impl.stop_0();
}

defineSeed(497, 1, {});
_.callbacks = null;
_.error_0 = null;
_.impl = null;
_.looping = false;
_.playing = false;
function $add_13(this$static, image){
  ++this$static.total;
  $addCallback_0(image, this$static.callback);
}

function $add_14(this$static, sound){
  ++this$static.total;
  $addCallback(sound, this$static.callback);
}

function $start_0(this$static){
  this$static.start = true;
  $update_7(this$static);
}

function $update_7(this$static){
  if (!this$static.listener)
    return;
  $progress(this$static.listener, this$static.loaded, this$static.total);
  this$static.start && this$static.loaded + this$static.errors == this$static.total && $start(this$static.listener.this$0.bomberman);
}

function AssetWatcher_0(listener){
  this.callback = new AssetWatcher$1_0(this);
  this.listener = listener;
}

defineSeed(498, 1, {}, AssetWatcher_0);
_.errors = 0;
_.listener = null;
_.loaded = 0;
_.start = false;
_.total = 0;
function $onFailure_0(this$static, e){
  ++this$static.this$0.errors;
  !!this$static.this$0.listener && $error(e);
  $update_7(this$static.this$0);
}

function AssetWatcher$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(499, 1, {}, AssetWatcher$1_0);
_.onFailure = function onFailure_2(e){
  $onFailure_0(this, e);
}
;
_.onSuccess = function onSuccess_2(resource){
  ++this.this$0.loaded;
  $update_7(this.this$0);
}
;
_.this$0 = null;
function $dispatch(listenerType, event_0, interaction){
  $dispatch_0(event_0.captureState.layer, listenerType, event_0, interaction);
}

function tryInteract(layer, listenerType, interaction, event_0){
  var $e0, t;
  try {
    $interact(layer, listenerType, interaction, layer.rootInteractor, event_0);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Throwable)) {
      t = $e0;
      $logImpl((platform_1.log_0 , 2), 'Interaction failure [layer=' + layer + ', iact=' + interaction + ', event=' + event_0 + ']', t);
    }
     else 
      throw $e0;
  }
}

function $dispatch_0(layer, listenerType, event_0, interaction){
  tryInteract(layer, listenerType, interaction, event_0.localize(layer));
}

function Dispatcher$CaptureState_0(){
}

defineSeed(502, 1, {}, Dispatcher$CaptureState_0);
_.layer = null;
function $clinit_Events(){
  $clinit_Events = nullMethod;
  scratchPoint = new Point_0;
}

var scratchPoint;
function $setPreventDefault(this$static, preventDefault){
  this$static.preventDefault_0 = preventDefault;
}

function Events$Flags$Impl_0(){
}

defineSeed(504, 1, {}, Events$Flags$Impl_0);
_.toString$ = function toString_36(){
  return this.preventDefault_0?'preventDefault':'normal';
}
;
_.preventDefault_0 = false;
function Events$Input$Impl_0(flags, time){
  this.flags = flags;
  this.time = time;
}

defineSeed(505, 1, makeCastMap([Q$Events$Input, Q$Events$Input$Impl]));
_.addFields = function addFields(builder){
  $append_11($append_12($append_8((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
}
;
_.name_2 = function name_1(){
  return 'Events.Input';
}
;
_.toString$ = function toString_37(){
  var builder;
  builder = $append_7(new StringBuilder_1(this.name_2()), 91);
  this.addFields(builder);
  return (builder.impl.string += ']' , builder).impl.string;
}
;
_.captureState = null;
_.flags = null;
_.time = 0;
function Events$Position$Impl_0(hit, flags, time, x, y){
  Events$Input$Impl_0.call(this, flags, time);
  this.hit = hit;
  this.x = x;
  this.y = y;
  if (!hit) {
    this.localX = x;
    this.localY = y;
  }
   else {
    screenToLayer(hit, $set_15(($clinit_Events() , scratchPoint), x, y), scratchPoint);
    this.localX = scratchPoint.x;
    this.localY = scratchPoint.y;
  }
}

defineSeed(506, 505, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]));
_.addFields = function addFields_0(builder){
  $append_11($append_12($append_8((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_11($append_12($append_9($append_12($append_9((builder.impl.string += ', x=' , builder), this.x), ', y='), this.y), ', hit='), this.hit);
}
;
_.localX_0 = function localX(){
  return this.localX;
}
;
_.localY_0 = function localY(){
  return this.localY;
}
;
_.name_2 = function name_2(){
  return 'Events.Position';
}
;
_.hit = null;
_.localX = 0;
_.localY = 0;
_.x = 0;
_.y = 0;
function $clinit_Font$Style(){
  $clinit_Font$Style = nullMethod;
  PLAIN = new Font$Style_0('PLAIN', 0);
  BOLD_0 = new Font$Style_0('BOLD', 1);
  ITALIC_0 = new Font$Style_0('ITALIC', 2);
  BOLD_ITALIC = new Font$Style_0('BOLD_ITALIC', 3);
  $VALUES_21 = initValues(_3Lplayn_core_Font$Style_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Font$Style, [PLAIN, BOLD_0, ITALIC_0, BOLD_ITALIC]);
}

function Font$Style_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_22(){
  $clinit_Font$Style();
  return $VALUES_21;
}

defineSeed(507, 39, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$Font$Style]), Font$Style_0);
var $VALUES_21, BOLD_0, BOLD_ITALIC, ITALIC_0, PLAIN;
function $add_15(this$static, self_0, child){
  var count, index, parent_0;
  parent_0 = child.parent_0;
  if (parent_0 == self_0) {
    return $findChild(this$static, child, child.depth);
  }
  count = this$static.children.size;
  count == 0 || $get(this$static.children, count - 1).depth <= child.depth?(index = count):(index = $findInsertion(this$static, child.depth));
  !!parent_0 && child.parent_0.remove_4(child);
  $add_3(this$static.children, index, child);
  child.parent_0 = self_0;
  child.onAdd();
  $isSet(child, ($clinit_AbstractLayer$Flag() , INTERACTIVE)) && self_0.setInteractive(true);
  return index;
}

function $destroyAll(this$static, self_0){
  var child, child$index, child$max, toDestroy;
  toDestroy = $toArray(this$static.children, initDim(_3Lplayn_core_AbstractLayer_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$AbstractLayer, this$static.children.size, 0));
  self_0.removeAll();
  for (child$index = 0 , child$max = toDestroy.length; child$index < child$max; ++child$index) {
    child = toDestroy[child$index];
    child.destroy();
  }
}

function $findChild(this$static, child, depth){
  var c, ii, ll, startIdx;
  startIdx = $findInsertion(this$static, depth);
  for (ii = startIdx - 1; ii >= 0; --ii) {
    c = $get(this$static.children, ii);
    if (c == child) {
      return ii;
    }
    if (c.depth != depth) {
      break;
    }
  }
  for (ii = startIdx , ll = this$static.children.size; ii < ll; ++ii) {
    c = $get(this$static.children, ii);
    if (c == child) {
      return ii;
    }
    if (c.depth != depth) {
      break;
    }
  }
  return -1;
}

function $findInsertion(this$static, depth){
  var high, low, mid, midDepth;
  low = 0;
  high = this$static.children.size - 1;
  while (low <= high) {
    mid = ~~(low + high) >>> 1;
    midDepth = $get(this$static.children, mid).depth;
    if (depth > midDepth) {
      low = mid + 1;
    }
     else if (depth < midDepth) {
      high = mid - 1;
    }
     else {
      return mid;
    }
  }
  return low;
}

function $hitTest(this$static, self_0, point){
  var $e0, child, ii, l_0, sawInteractiveChild, x, y;
  x = point.x;
  y = point.y;
  sawInteractiveChild = false;
  for (ii = this$static.children.size - 1; ii >= 0; --ii) {
    child = $get(this$static.children, ii);
    if (!$isSet(child, ($clinit_AbstractLayer$Flag() , INTERACTIVE)))
      continue;
    sawInteractiveChild = true;
    if (!$isSet(child, VISIBLE_1))
      continue;
    try {
      $transform_0(child).inverseTransform($set_15(point, x, y), point);
      point.x += child.originX;
      point.y += child.originY;
      l_0 = child.hitTestDefault(point);
      if (l_0)
        return l_0;
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$NoninvertibleTransformException)) {
        continue;
      }
       else 
        throw $e0;
    }
  }
  !sawInteractiveChild && !self_0.rootInteractor && self_0.setInteractive(false);
  return null;
}

function $onAdd_0(this$static){
  var ii, ll;
  for (ii = 0 , ll = this$static.children.size; ii < ll; ++ii) {
    $get(this$static.children, ii).onAdd();
  }
}

function $onRemove(this$static){
  var ii, ll;
  for (ii = 0 , ll = this$static.children.size; ii < ll; ++ii) {
    $get(this$static.children, ii).onRemove();
  }
}

function $remove_15(this$static, index){
  var child;
  child = $remove_2(this$static.children, index);
  child.onRemove();
  child.parent_0 = null;
}

function $remove_16(this$static, child){
  var index;
  index = $findChild(this$static, child, child.depth);
  if (index < 0) {
    throw new UnsupportedOperationException_1('Could not remove Layer because it is not a child of the GroupLayer');
  }
  $remove_15(this$static, index);
}

function $removeAll_1(this$static){
  while (this$static.children.size != 0) {
    $remove_15(this$static, this$static.children.size - 1);
  }
}

function GroupLayerImpl_0(){
  this.children = new ArrayList_0;
}

defineSeed(508, 1, {}, GroupLayerImpl_0);
--></script>
<script><!--
function $clinit_Key(){
  $clinit_Key = nullMethod;
  A_0 = new Key_0('A', 0);
  B_0 = new Key_0('B', 1);
  C_0 = new Key_0('C', 2);
  D_0 = new Key_0('D', 3);
  E = new Key_0('E', 4);
  F = new Key_0('F', 5);
  G = new Key_0('G', 6);
  H = new Key_0('H', 7);
  I_0 = new Key_0('I', 8);
  J = new Key_0('J', 9);
  K_0 = new Key_0('K', 10);
  L = new Key_0('L', 11);
  M = new Key_0('M', 12);
  N = new Key_0('N', 13);
  O = new Key_0('O', 14);
  P = new Key_0('P', 15);
  Q = new Key_0('Q', 16);
  R_0 = new Key_0('R', 17);
  S = new Key_0('S', 18);
  T_0 = new Key_0('T', 19);
  U = new Key_0('U', 20);
  V = new Key_0('V', 21);
  W = new Key_0('W', 22);
  X = new Key_0('X', 23);
  Y = new Key_0('Y', 24);
  Z = new Key_0('Z', 25);
  K0 = new Key_0('K0', 26);
  K1 = new Key_0('K1', 27);
  K2 = new Key_0('K2', 28);
  K3 = new Key_0('K3', 29);
  K4 = new Key_0('K4', 30);
  K5 = new Key_0('K5', 31);
  K6 = new Key_0('K6', 32);
  K7 = new Key_0('K7', 33);
  K8 = new Key_0('K8', 34);
  K9 = new Key_0('K9', 35);
  NP0 = new Key_0('NP0', 36);
  NP1 = new Key_0('NP1', 37);
  NP2 = new Key_0('NP2', 38);
  NP3 = new Key_0('NP3', 39);
  NP4 = new Key_0('NP4', 40);
  NP5 = new Key_0('NP5', 41);
  NP6 = new Key_0('NP6', 42);
  NP7 = new Key_0('NP7', 43);
  NP8 = new Key_0('NP8', 44);
  NP9 = new Key_0('NP9', 45);
  NP_ADD = new Key_0('NP_ADD', 46);
  NP_DECIMAL = new Key_0('NP_DECIMAL', 47);
  NP_DELETE = new Key_0('NP_DELETE', 48);
  NP_DIVIDE = new Key_0('NP_DIVIDE', 49);
  NP_MULTIPLY = new Key_0('NP_MULTIPLY', 50);
  NP_NUM_LOCK = new Key_0('NP_NUM_LOCK', 51);
  NP_SUBTRACT = new Key_0('NP_SUBTRACT', 52);
  NP_DOWN = new Key_0('NP_DOWN', 53);
  NP_LEFT = new Key_0('NP_LEFT', 54);
  NP_RIGHT = new Key_0('NP_RIGHT', 55);
  NP_UP = new Key_0('NP_UP', 56);
  F1 = new Key_0('F1', 57);
  F2 = new Key_0('F2', 58);
  F3 = new Key_0('F3', 59);
  F4 = new Key_0('F4', 60);
  F5 = new Key_0('F5', 61);
  F6 = new Key_0('F6', 62);
  F7 = new Key_0('F7', 63);
  F8 = new Key_0('F8', 64);
  F9 = new Key_0('F9', 65);
  F10 = new Key_0('F10', 66);
  F11 = new Key_0('F11', 67);
  F12 = new Key_0('F12', 68);
  AMPERSAND = new Key_0('AMPERSAND', 69);
  ASTERISK = new Key_0('ASTERISK', 70);
  AT = new Key_0('AT', 71);
  BACKQUOTE = new Key_0('BACKQUOTE', 72);
  BACKSLASH = new Key_0('BACKSLASH', 73);
  BANG = new Key_0('BANG', 74);
  CIRCUMFLEX = new Key_0('CIRCUMFLEX', 75);
  COLON = new Key_0('COLON', 76);
  COMMA = new Key_0('COMMA', 77);
  DOLLAR = new Key_0('DOLLAR', 78);
  DOUBLE_QUOTE = new Key_0('DOUBLE_QUOTE', 79);
  EQUALS = new Key_0('EQUALS', 80);
  GREATER = new Key_0('GREATER', 81);
  HASH = new Key_0('HASH', 82);
  LEFT_BRACE = new Key_0('LEFT_BRACE', 83);
  LEFT_BRACKET = new Key_0('LEFT_BRACKET', 84);
  LEFT_PAREN = new Key_0('LEFT_PAREN', 85);
  LESS = new Key_0('LESS', 86);
  MINUS = new Key_0('MINUS', 87);
  MULTIPLY = new Key_0('MULTIPLY', 88);
  PERCENT = new Key_0('PERCENT', 89);
  PERIOD = new Key_0('PERIOD', 90);
  PLUS = new Key_0('PLUS', 91);
  QUOTE = new Key_0('QUOTE', 92);
  RIGHT_BRACE = new Key_0('RIGHT_BRACE', 93);
  RIGHT_BRACKET = new Key_0('RIGHT_BRACKET', 94);
  RIGHT_PAREN = new Key_0('RIGHT_PAREN', 95);
  SEMICOLON = new Key_0('SEMICOLON', 96);
  SLASH = new Key_0('SLASH', 97);
  SPACE = new Key_0('SPACE', 98);
  TILDE = new Key_0('TILDE', 99);
  QUESTION_MARK = new Key_0('QUESTION_MARK', 100);
  UNDERSCORE = new Key_0('UNDERSCORE', 101);
  VERTICAL_BAR = new Key_0('VERTICAL_BAR', 102);
  ALT = new Key_0('ALT', 103);
  CONTROL = new Key_0('CONTROL', 104);
  CAPS_LOCK = new Key_0('CAPS_LOCK', 105);
  SHIFT = new Key_0('SHIFT', 106);
  META = new Key_0('META', 107);
  DOWN_0 = new Key_0('DOWN', 108);
  END = new Key_0('END', 109);
  HOME = new Key_0('HOME', 110);
  LEFT_0 = new Key_0('LEFT', 111);
  PAGE_UP = new Key_0('PAGE_UP', 112);
  PAGE_DOWN = new Key_0('PAGE_DOWN', 113);
  RIGHT_0 = new Key_0('RIGHT', 114);
  UP_0 = new Key_0('UP', 115);
  BACKSPACE = new Key_0('BACKSPACE', 116);
  DELETE = new Key_0('DELETE', 117);
  ENTER = new Key_0('ENTER', 118);
  INSERT = new Key_0('INSERT', 119);
  TAB = new Key_0('TAB', 120);
  ESCAPE = new Key_0('ESCAPE', 121);
  PAUSE = new Key_0('PAUSE', 122);
  PRINT_SCREEN = new Key_0('PRINT_SCREEN', 123);
  SCROLL_LOCK = new Key_0('SCROLL_LOCK', 124);
  WINDOWS = new Key_0('WINDOWS', 125);
  MEDIA_CLOSE = new Key_0('MEDIA_CLOSE', 126);
  MEDIA_EJECT = new Key_0('MEDIA_EJECT', 127);
  MEDIA_FAST_FORWARD = new Key_0('MEDIA_FAST_FORWARD', 128);
  MEDIA_NEXT = new Key_0('MEDIA_NEXT', 129);
  MEDIA_PAUSE = new Key_0('MEDIA_PAUSE', 130);
  MEDIA_PLAY = new Key_0('MEDIA_PLAY', 131);
  MEDIA_PLAY_PAUSE = new Key_0('MEDIA_PLAY_PAUSE', 132);
  MEDIA_PREVIOUS = new Key_0('MEDIA_PREVIOUS', 133);
  MEDIA_RECORD = new Key_0('MEDIA_RECORD', 134);
  MEDIA_REWIND = new Key_0('MEDIA_REWIND', 135);
  MEDIA_STOP = new Key_0('MEDIA_STOP', 136);
  BLUE = new Key_0('BLUE', 137);
  GREEN = new Key_0('GREEN', 138);
  RED = new Key_0('RED', 139);
  YELLOW = new Key_0('YELLOW', 140);
  APP_SWITCH = new Key_0('APP_SWITCH', 141);
  AVR_INPUT = new Key_0('AVR_INPUT', 142);
  AVR_POWER = new Key_0('AVR_POWER', 143);
  BACK = new Key_0('BACK', 144);
  BOOKMARK = new Key_0('BOOKMARK', 145);
  BREAK = new Key_0('BREAK', 146);
  BUTTON_1 = new Key_0('BUTTON_1', 147);
  BUTTON_2 = new Key_0('BUTTON_2', 148);
  BUTTON_3 = new Key_0('BUTTON_3', 149);
  BUTTON_4 = new Key_0('BUTTON_4', 150);
  BUTTON_5 = new Key_0('BUTTON_5', 151);
  BUTTON_6 = new Key_0('BUTTON_6', 152);
  BUTTON_7 = new Key_0('BUTTON_7', 153);
  BUTTON_8 = new Key_0('BUTTON_8', 154);
  BUTTON_9 = new Key_0('BUTTON_9', 155);
  BUTTON_10 = new Key_0('BUTTON_10', 156);
  BUTTON_11 = new Key_0('BUTTON_11', 157);
  BUTTON_12 = new Key_0('BUTTON_12', 158);
  BUTTON_13 = new Key_0('BUTTON_13', 159);
  BUTTON_14 = new Key_0('BUTTON_14', 160);
  BUTTON_15 = new Key_0('BUTTON_15', 161);
  BUTTON_16 = new Key_0('BUTTON_16', 162);
  BUTTON_A = new Key_0('BUTTON_A', 163);
  BUTTON_B = new Key_0('BUTTON_B', 164);
  BUTTON_C = new Key_0('BUTTON_C', 165);
  BUTTON_L1 = new Key_0('BUTTON_L1', 166);
  BUTTON_L2 = new Key_0('BUTTON_L2', 167);
  BUTTON_MODE = new Key_0('BUTTON_MODE', 168);
  BUTTON_R1 = new Key_0('BUTTON_R1', 169);
  BUTTON_R2 = new Key_0('BUTTON_R2', 170);
  BUTTON_SELECT = new Key_0('BUTTON_SELECT', 171);
  BUTTON_START = new Key_0('BUTTON_START', 172);
  BUTTON_THUMBL = new Key_0('BUTTON_THUMBL', 173);
  BUTTON_THUMBR = new Key_0('BUTTON_THUMBR', 174);
  BUTTON_X = new Key_0('BUTTON_X', 175);
  BUTTON_Y = new Key_0('BUTTON_Y', 176);
  BUTTON_Z = new Key_0('BUTTON_Z', 177);
  CALL = new Key_0('CALL', 178);
  CAMERA = new Key_0('CAMERA', 179);
  CAPTIONS = new Key_0('CAPTIONS', 180);
  CHANNEL_DOWN = new Key_0('CHANNEL_DOWN', 181);
  CHANNEL_UP = new Key_0('CHANNEL_UP', 182);
  CLEAR = new Key_0('CLEAR', 183);
  DPAD_CENTER = new Key_0('DPAD_CENTER', 184);
  DPAD_DOWN = new Key_0('DPAD_DOWN', 185);
  DPAD_LEFT = new Key_0('DPAD_LEFT', 186);
  DPAD_RIGHT = new Key_0('DPAD_RIGHT', 187);
  DPAD_UP = new Key_0('DPAD_UP', 188);
  DVR = new Key_0('DVR', 189);
  ENDCALL = new Key_0('ENDCALL', 190);
  ENVELOPE = new Key_0('ENVELOPE', 191);
  EXPLORER = new Key_0('EXPLORER', 192);
  FOCUS = new Key_0('FOCUS', 193);
  FORWARD = new Key_0('FORWARD', 194);
  FORWARD_DEL = new Key_0('FORWARD_DEL', 195);
  FUNCTION = new Key_0('FUNCTION', 196);
  GUIDE = new Key_0('GUIDE', 197);
  HEADSETHOOK = new Key_0('HEADSETHOOK', 198);
  INFO = new Key_0('INFO', 199);
  MENU = new Key_0('MENU', 200);
  MUTE = new Key_0('MUTE', 201);
  NOTIFICATION = new Key_0('NOTIFICATION', 202);
  NUM = new Key_0('NUM', 203);
  PICTSYMBOLS = new Key_0('PICTSYMBOLS', 204);
  POWER = new Key_0('POWER', 205);
  SEARCH = new Key_0('SEARCH', 206);
  SETTINGS = new Key_0('SETTINGS', 207);
  SOFT_LEFT = new Key_0('SOFT_LEFT', 208);
  SOFT_RIGHT = new Key_0('SOFT_RIGHT', 209);
  STAR = new Key_0('STAR', 210);
  STB_INPUT = new Key_0('STB_INPUT', 211);
  STB_POWER = new Key_0('STB_POWER', 212);
  SWITCH_CHARSET = new Key_0('SWITCH_CHARSET', 213);
  SYM = new Key_0('SYM', 214);
  SYSRQ = new Key_0('SYSRQ', 215);
  TV = new Key_0('TV', 216);
  TV_INPUT = new Key_0('TV_INPUT', 217);
  TV_POWER = new Key_0('TV_POWER', 218);
  VOLUME_DOWN = new Key_0('VOLUME_DOWN', 219);
  VOLUME_MUTE = new Key_0('VOLUME_MUTE', 220);
  VOLUME_UP = new Key_0('VOLUME_UP', 221);
  WINDOW = new Key_0('WINDOW', 222);
  ZOOM_IN = new Key_0('ZOOM_IN', 223);
  ZOOM_OUT = new Key_0('ZOOM_OUT', 224);
  UNKNOWN_1 = new Key_0('UNKNOWN', 225);
  $VALUES_22 = initValues(_3Lplayn_core_Key_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Key, [A_0, B_0, C_0, D_0, E, F, G, H, I_0, J, K_0, L, M, N, O, P, Q, R_0, S, T_0, U, V, W, X, Y, Z, K0, K1, K2, K3, K4, K5, K6, K7, K8, K9, NP0, NP1, NP2, NP3, NP4, NP5, NP6, NP7, NP8, NP9, NP_ADD, NP_DECIMAL, NP_DELETE, NP_DIVIDE, NP_MULTIPLY, NP_NUM_LOCK, NP_SUBTRACT, NP_DOWN, NP_LEFT, NP_RIGHT, NP_UP, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, AMPERSAND, ASTERISK, AT, BACKQUOTE, BACKSLASH, BANG, CIRCUMFLEX, COLON, COMMA, DOLLAR, DOUBLE_QUOTE, EQUALS, GREATER, HASH, LEFT_BRACE, LEFT_BRACKET, LEFT_PAREN, LESS, MINUS, MULTIPLY, PERCENT, PERIOD, PLUS, QUOTE, RIGHT_BRACE, RIGHT_BRACKET, RIGHT_PAREN, SEMICOLON, SLASH, SPACE, TILDE, QUESTION_MARK, UNDERSCORE, VERTICAL_BAR, ALT, CONTROL, CAPS_LOCK, SHIFT, META, DOWN_0, END, HOME, LEFT_0, PAGE_UP, PAGE_DOWN, RIGHT_0, UP_0, BACKSPACE, DELETE, ENTER, INSERT, TAB, ESCAPE, PAUSE, PRINT_SCREEN, SCROLL_LOCK, WINDOWS, MEDIA_CLOSE, MEDIA_EJECT, MEDIA_FAST_FORWARD, MEDIA_NEXT, MEDIA_PAUSE, MEDIA_PLAY, MEDIA_PLAY_PAUSE, MEDIA_PREVIOUS, MEDIA_RECORD, MEDIA_REWIND, MEDIA_STOP, BLUE, GREEN, RED, YELLOW, APP_SWITCH, AVR_INPUT, AVR_POWER, BACK, BOOKMARK, BREAK, BUTTON_1, BUTTON_2, BUTTON_3, BUTTON_4, BUTTON_5, BUTTON_6, BUTTON_7, BUTTON_8, BUTTON_9, BUTTON_10, BUTTON_11, BUTTON_12, BUTTON_13, BUTTON_14, BUTTON_15, BUTTON_16, BUTTON_A, BUTTON_B, BUTTON_C, BUTTON_L1, BUTTON_L2, BUTTON_MODE, BUTTON_R1, BUTTON_R2, BUTTON_SELECT, BUTTON_START, BUTTON_THUMBL, BUTTON_THUMBR, BUTTON_X, BUTTON_Y, BUTTON_Z, CALL, CAMERA, CAPTIONS, CHANNEL_DOWN, CHANNEL_UP, CLEAR, DPAD_CENTER, DPAD_DOWN, DPAD_LEFT, DPAD_RIGHT, DPAD_UP, DVR, ENDCALL, ENVELOPE, EXPLORER, FOCUS, FORWARD, FORWARD_DEL, FUNCTION, GUIDE, HEADSETHOOK, INFO, MENU, MUTE, NOTIFICATION, NUM, PICTSYMBOLS, POWER, SEARCH, SETTINGS, SOFT_LEFT, SOFT_RIGHT, STAR, STB_INPUT, STB_POWER, SWITCH_CHARSET, SYM, SYSRQ, TV, TV_INPUT, TV_POWER, VOLUME_DOWN, VOLUME_MUTE, VOLUME_UP, WINDOW, ZOOM_IN, ZOOM_OUT, UNKNOWN_1]);
}

function Key_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_23(){
  $clinit_Key();
  return $VALUES_22;
}

defineSeed(509, 39, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$Key]), Key_0);
var $VALUES_22, A_0, ALT, AMPERSAND, APP_SWITCH, ASTERISK, AT, AVR_INPUT, AVR_POWER, B_0, BACK, BACKQUOTE, BACKSLASH, BACKSPACE, BANG, BLUE, BOOKMARK, BREAK, BUTTON_1, BUTTON_10, BUTTON_11, BUTTON_12, BUTTON_13, BUTTON_14, BUTTON_15, BUTTON_16, BUTTON_2, BUTTON_3, BUTTON_4, BUTTON_5, BUTTON_6, BUTTON_7, BUTTON_8, BUTTON_9, BUTTON_A, BUTTON_B, BUTTON_C, BUTTON_L1, BUTTON_L2, BUTTON_MODE, BUTTON_R1, BUTTON_R2, BUTTON_SELECT, BUTTON_START, BUTTON_THUMBL, BUTTON_THUMBR, BUTTON_X, BUTTON_Y, BUTTON_Z, C_0, CALL, CAMERA, CAPS_LOCK, CAPTIONS, CHANNEL_DOWN, CHANNEL_UP, CIRCUMFLEX, CLEAR, COLON, COMMA, CONTROL, D_0, DELETE, DOLLAR, DOUBLE_QUOTE, DOWN_0, DPAD_CENTER, DPAD_DOWN, DPAD_LEFT, DPAD_RIGHT, DPAD_UP, DVR, E, END, ENDCALL, ENTER, ENVELOPE, EQUALS, ESCAPE, EXPLORER, F, F1, F10, F11, F12, F2, F3, F4, F5, F6, F7, F8, F9, FOCUS, FORWARD, FORWARD_DEL, FUNCTION, G, GREATER, GREEN, GUIDE, H, HASH, HEADSETHOOK, HOME, I_0, INFO, INSERT, J, K_0, K0, K1, K2, K3, K4, K5, K6, K7, K8, K9, L, LEFT_0, LEFT_BRACE, LEFT_BRACKET, LEFT_PAREN, LESS, M, MEDIA_CLOSE, MEDIA_EJECT, MEDIA_FAST_FORWARD, MEDIA_NEXT, MEDIA_PAUSE, MEDIA_PLAY, MEDIA_PLAY_PAUSE, MEDIA_PREVIOUS, MEDIA_RECORD, MEDIA_REWIND, MEDIA_STOP, MENU, META, MINUS, MULTIPLY, MUTE, N, NOTIFICATION, NP0, NP1, NP2, NP3, NP4, NP5, NP6, NP7, NP8, NP9, NP_ADD, NP_DECIMAL, NP_DELETE, NP_DIVIDE, NP_DOWN, NP_LEFT, NP_MULTIPLY, NP_NUM_LOCK, NP_RIGHT, NP_SUBTRACT, NP_UP, NUM, O, P, PAGE_DOWN, PAGE_UP, PAUSE, PERCENT, PERIOD, PICTSYMBOLS, PLUS, POWER, PRINT_SCREEN, Q, QUESTION_MARK, QUOTE, R_0, RED, RIGHT_0, RIGHT_BRACE, RIGHT_BRACKET, RIGHT_PAREN, S, SCROLL_LOCK, SEARCH, SEMICOLON, SETTINGS, SHIFT, SLASH, SOFT_LEFT, SOFT_RIGHT, SPACE, STAR, STB_INPUT, STB_POWER, SWITCH_CHARSET, SYM, SYSRQ, T_0, TAB, TILDE, TV, TV_INPUT, TV_POWER, U, UNDERSCORE, UNKNOWN_1, UP_0, V, VERTICAL_BAR, VOLUME_DOWN, VOLUME_MUTE, VOLUME_UP, W, WINDOW, WINDOWS, X, Y, YELLOW, Z, ZOOM_IN, ZOOM_OUT;
function Keyboard$Event$Impl_0(flags, time, key){
  Events$Input$Impl_0.call(this, flags, time);
  this.key_0 = key;
}

defineSeed(510, 505, makeCastMap([Q$Events$Input, Q$Events$Input$Impl]), Keyboard$Event$Impl_0);
_.addFields = function addFields_1(builder){
  $append_11($append_12($append_8((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_11((builder.impl.string += ', key=' , builder), this.key_0);
}
;
_.name_2 = function name_3(){
  return 'Keyboard.Event';
}
;
_.key_0 = null;
function Keyboard$TypedEvent$Impl_0(flags, time, typedChar){
  Events$Input$Impl_0.call(this, flags, time);
  this.typedChar = typedChar;
}

defineSeed(511, 505, makeCastMap([Q$Events$Input, Q$Events$Input$Impl]), Keyboard$TypedEvent$Impl_0);
_.addFields = function addFields_2(builder){
  $append_11($append_12($append_8((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_7((builder.impl.string += ', typedChar=' , builder), this.typedChar);
}
;
_.name_2 = function name_4(){
  return 'Keyboard.TypedEvent';
}
;
_.typedChar = 0;
function screenToLayer(layer, point, into){
  var cur, parent_0;
  parent_0 = layer.parent_1();
  cur = !parent_0?point:screenToLayer(parent_0, point, into);
  return layer.transform_1().inverseTransform(cur, into) , into.x += layer.originX_0() , into.y += layer.originY_0() , into;
}

defineSeed(513, 1, {});
function Mouse$ButtonEvent$Impl_0(flags, time, x, y, button){
  Events$Position$Impl_0.call(this, null, flags, time, x, y);
  this.button_0 = button;
}

function Mouse$ButtonEvent$Impl_1(hit, flags, time, x, y, button){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.button_0 = button;
}

defineSeed(514, 506, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]), Mouse$ButtonEvent$Impl_0, Mouse$ButtonEvent$Impl_1);
_.addFields = function addFields_3(builder){
  $append_11($append_12($append_8((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_11($append_12($append_9($append_12($append_9((builder.impl.string += ', x=' , builder), this.x), ', y='), this.y), ', hit='), this.hit);
  $append_10((builder.impl.string += ', button=' , builder), this.button_0);
}
;
_.localize = function localize(hit){
  return new Mouse$ButtonEvent$Impl_1(hit, this.flags, this.time, this.x, this.y, this.button_0);
}
;
_.name_2 = function name_5(){
  return 'ButtonEvent';
}
;
_.button_0 = 0;
function Mouse$MotionEvent$Impl_0(flags, time, x, y, dx, dy){
  Events$Position$Impl_0.call(this, null, flags, time, x, y);
  this.dx = dx;
  this.dy = dy;
}

function Mouse$MotionEvent$Impl_1(hit, flags, time, x, y, dx, dy){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.dx = dx;
  this.dy = dy;
}

defineSeed(515, 506, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]), Mouse$MotionEvent$Impl_0, Mouse$MotionEvent$Impl_1);
_.localize = function localize_0(hit){
  return new Mouse$MotionEvent$Impl_1(hit, this.flags, this.time, this.x, this.y, this.dx, this.dy);
}
;
_.name_2 = function name_6(){
  return 'MotionEvent';
}
;
_.dx = 0;
_.dy = 0;
function Mouse$WheelEvent$Impl_0(flags, time, x, y, velocity){
  Events$Position$Impl_0.call(this, null, flags, time, x, y);
  this.velocity = velocity;
}

function Mouse$WheelEvent$Impl_1(hit, flags, time, x, y, velocity){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.velocity = velocity;
}

defineSeed(516, 506, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]), Mouse$WheelEvent$Impl_0, Mouse$WheelEvent$Impl_1);
_.addFields = function addFields_4(builder){
  $append_11($append_12($append_8((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_11($append_12($append_9($append_12($append_9((builder.impl.string += ', x=' , builder), this.x), ', y='), this.y), ', hit='), this.hit);
  $append_9((builder.impl.string += ', velocity=' , builder), this.velocity);
}
;
_.localize = function localize_1(hit){
  return new Mouse$WheelEvent$Impl_1(hit, this.flags, this.time, this.x, this.y, this.velocity);
}
;
_.name_2 = function name_7(){
  return 'WheelEvent';
}
;
_.velocity = 0;
function $onMouseDown(this$static, event_0){
  var p, root;
  event_0.flags.preventDefault_0 = false;
  root = platform_1.graphics.rootLayer_0();
  if (root.interactive()) {
    p = new Point_1(event_0.x, event_0.y);
    root.transform_1().inverseTransform(p, p);
    p.x += root.originX_0();
    p.y += root.originY_0();
    this$static.activeLayer = root.hitTest(p);
    !!this$static.activeLayer && $dispatch_0(this$static.activeLayer, Lplayn_core_Mouse$LayerListener_2_classLit, event_0, this$static.DOWN);
  }
  return event_0.flags.preventDefault_0;
}

function $onMouseMove(this$static, event_0){
  var lastHoverLayer, p, root;
  event_0.flags.preventDefault_0 = false;
  root = platform_1.graphics.rootLayer_0();
  if (root.interactive()) {
    p = new Point_1(event_0.x, event_0.y);
    root.transform_1().inverseTransform(p, p);
    p.x += root.originX_0();
    p.y += root.originY_0();
    lastHoverLayer = this$static.hoverLayer;
    this$static.hoverLayer = root.hitTest(p);
    this$static.activeLayer?$dispatch_0(this$static.activeLayer, Lplayn_core_Mouse$LayerListener_2_classLit, event_0, this$static.DRAG):!!this$static.hoverLayer && $dispatch_0(this$static.hoverLayer, Lplayn_core_Mouse$LayerListener_2_classLit, event_0, this$static.MOVE);
    lastHoverLayer != this$static.hoverLayer && !!lastHoverLayer && $dispatch_0(lastHoverLayer, Lplayn_core_Mouse$LayerListener_2_classLit, event_0, this$static.OUT);
    this$static.hoverLayer != lastHoverLayer && !!this$static.hoverLayer && $dispatch_0(this$static.hoverLayer, Lplayn_core_Mouse$LayerListener_2_classLit, event_0, this$static.OVER);
  }
  return event_0.flags.preventDefault_0;
}

function $onMouseUp(this$static, event_0){
  event_0.flags.preventDefault_0 = false;
  if (this$static.activeLayer) {
    $dispatch_0(this$static.activeLayer, Lplayn_core_Mouse$LayerListener_2_classLit, event_0, this$static.UP);
    this$static.activeLayer = null;
  }
  return event_0.flags.preventDefault_0;
}

function $onMouseWheelScroll(this$static, event_0){
  var target;
  target = this$static.activeLayer?this$static.activeLayer:this$static.hoverLayer;
  !!target && $dispatch_0(target, Lplayn_core_Mouse$LayerListener_2_classLit, event_0, this$static.WHEEL_SCROLL);
  return event_0.flags.preventDefault_0;
}

defineSeed(517, 1, {});
_.activeLayer = null;
_.hoverLayer = null;
function MouseImpl$1_0(){
}

defineSeed(518, 1, {}, MouseImpl$1_0);
_.interact = function interact(l_0, ev){
  null.nullMethod();
}
;
function MouseImpl$2_0(){
}

defineSeed(519, 1, {}, MouseImpl$2_0);
_.interact = function interact_0(l_0, ev){
  null.nullMethod();
}
;
function MouseImpl$3_0(){
}

defineSeed(520, 1, {}, MouseImpl$3_0);
_.interact = function interact_1(l_0, ev){
  null.nullMethod();
}
;
function MouseImpl$4_0(){
}

defineSeed(521, 1, {}, MouseImpl$4_0);
_.interact = function interact_2(l_0, ev){
  null.nullMethod();
}
;
function MouseImpl$5_0(){
}

defineSeed(522, 1, {}, MouseImpl$5_0);
_.interact = function interact_3(l_0, ev){
  null.nullMethod();
}
;
function MouseImpl$6_0(){
}

defineSeed(523, 1, {}, MouseImpl$6_0);
_.interact = function interact_4(l_0, ev){
  null.nullMethod();
}
;
function MouseImpl$7_0(){
}

defineSeed(524, 1, {}, MouseImpl$7_0);
_.interact = function interact_5(l_0, ev){
  null.nullMethod();
}
;
function run_2(game){
  $run(platform_1, game);
}

var platform_1 = null;
function Pointer$Event$Impl_0(flags, time, x, y, isTouch){
  Pointer$Event$Impl_1.call(this, null, flags, time, x, y, isTouch);
}

function Pointer$Event$Impl_1(hit, flags, time, x, y, isTouch){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.isTouch = isTouch;
}

defineSeed(526, 506, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl]), Pointer$Event$Impl_0, Pointer$Event$Impl_1);
_.localize = function localize_2(hit){
  var impl;
  return impl = new Pointer$Event$Impl_1(hit, this.flags, this.time, this.x, this.y, this.isTouch) , impl.captureState = this.captureState , impl;
}
;
_.name_2 = function name_8(){
  return 'Pointer.Event';
}
;
_.isTouch = false;
function $onPointerDrag_0(this$static, event_0, preventDefault){
  $setPreventDefault(event_0.flags, preventDefault);
  !!this$static.listener && $onPointerDrag(this$static.listener, event_0);
  if (this$static.active.layer) {
    event_0.captureState = this$static.active;
    $dispatch(Lplayn_core_Pointer$Listener_2_classLit, event_0, this$static.DRAG);
  }
  return event_0.flags.preventDefault_0;
}

function $onPointerEnd_0(this$static, event_0, preventDefault){
  $setPreventDefault(event_0.flags, preventDefault);
  !!this$static.listener && $onPointerEnd(this$static.listener, event_0);
  if (this$static.active.layer) {
    event_0.captureState = this$static.active;
    $dispatch(Lplayn_core_Pointer$Listener_2_classLit, event_0, this$static.END);
    this$static.active.layer = null;
  }
  return event_0.flags.preventDefault_0;
}

function $onPointerStart_1(this$static, event_0){
  var p, root;
  event_0.flags.preventDefault_0 = true;
  !!this$static.listener && $onPointerStart(this$static.listener, event_0);
  root = platform_1.graphics.rootLayer_0();
  if (root.interactive()) {
    p = new Point_1(event_0.x, event_0.y);
    root.transform_1().inverseTransform(p, p);
    p.x += root.originX_0();
    p.y += root.originY_0();
    this$static.active.layer = root.hitTest(p);
    if (this$static.active.layer) {
      event_0.captureState = this$static.active;
      $dispatch(Lplayn_core_Pointer$Listener_2_classLit, event_0, this$static.START);
    }
  }
  return event_0.flags.preventDefault_0;
}

function $setListener(this$static, listener){
  this$static.listener = listener;
}

defineSeed(527, 1, {});
_.listener = null;
function PointerImpl$1_0(){
}

defineSeed(528, 1, {}, PointerImpl$1_0);
_.interact = function interact_6(l_0, ev){
  l_0.onPointerStart(ev);
}
;
function PointerImpl$2_0(){
}

defineSeed(529, 1, {}, PointerImpl$2_0);
_.interact = function interact_7(l_0, ev){
  l_0.onPointerDrag(ev);
}
;
function PointerImpl$3_0(){
}

defineSeed(530, 1, {}, PointerImpl$3_0);
_.interact = function interact_8(l_0, ev){
  l_0.onPointerEnd(ev);
}
;
function $scale_0(this$static, scaleX, scaleY){
  this$static.scaleX(scaleX);
  this$static.scaleY(scaleY);
  return this$static;
}

defineSeed(533, 1, {});
_.scale_2 = function scale_0(scaleX, scaleY){
  return $scale_0(this, scaleX, scaleY);
}
;
_.scaleX = function scaleX_0(scaleX){
  throw new UnsupportedOperationException_0;
}
;
_.scaleY = function scaleY_0(scaleY){
  throw new UnsupportedOperationException_0;
}
;
_.setTransform = function setTransform(m00, m01, m10, m11, tx, ty){
  throw new UnsupportedOperationException_0;
}
;
_.setTranslation_0 = function setTranslation_0(tx, ty){
  this.setTx(tx);
  this.setTy(ty);
  return this;
}
;
_.setTx = function setTx(tx){
  throw new UnsupportedOperationException_0;
}
;
_.setTy = function setTy(ty){
  throw new UnsupportedOperationException_0;
}
;
_.uniformScale = function uniformScale(scale){
  throw new UnsupportedOperationException_0;
}
;
function $setTransform_0(this$static, m00, m01, m10, m11, tx, ty){
  this$static.m00 = m00;
  this$static.m01 = m01;
  this$static.m10 = m10;
  this$static.m11 = m11;
  this$static.tx = tx;
  this$static.ty = ty;
  return this$static;
}

defineSeed(532, 533, {});
_.inverseTransform = function inverseTransform(p, into){
  var det, rdet, x, y;
  x = p.x - this.tx;
  y = p.y - this.ty;
  det = this.m00 * this.m11 - this.m01 * this.m10;
  if (abs(det) == 0) {
    throw new NoninvertibleTransformException_0('affine [' + toString_49(this.m00) + ' ' + toString_49(this.m01) + ' ' + toString_49(this.m10) + ' ' + toString_49(this.m11) + ' ' + new Vector_1(this.tx, this.ty) + ']');
  }
  rdet = 1 / det;
  return $set_15(into, (x * this.m11 - y * this.m10) * rdet, (y * this.m00 - x * this.m01) * rdet);
}
;
_.scale_2 = function scale_1(scaleX, scaleY){
  return multiply_0(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, scaleX, scaleY, this);
}
;
_.scaleX = function scaleX_1(scaleX){
  return multiply_0(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, scaleX, 1, this);
}
;
_.scaleY = function scaleY_1(scaleY){
  return multiply_0(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, 1, scaleY, this);
}
;
_.setTransform = function setTransform_0(m00, m01, m10, m11, tx, ty){
  return $setTransform_0(this, m00, m01, m10, m11, tx, ty);
}
;
_.setTranslation_0 = function setTranslation_1(tx, ty){
  this.tx = tx;
  this.ty = ty;
  return this;
}
;
_.setTx = function setTx_0(tx){
  this.tx = tx;
  return this;
}
;
_.setTy = function setTy_0(ty){
  this.ty = ty;
  return this;
}
;
_.toString$ = function toString_38(){
  return 'affine [' + toString_49(this.m00) + ' ' + toString_49(this.m01) + ' ' + toString_49(this.m10) + ' ' + toString_49(this.m11) + ' ' + new Vector_1(this.tx, this.ty) + ']';
}
;
_.tx_0 = function tx_0(){
  return this.tx;
}
;
_.ty_0 = function ty_0(){
  return this.ty;
}
;
_.uniformScale = function uniformScale_0(scale){
  return multiply_0(this.m00, this.m01, this.m10, this.m11, this.tx, this.ty, scale, scale, this);
}
;
_.m00 = 0;
_.m01 = 0;
_.m10 = 0;
_.m11 = 0;
_.tx = 0;
_.ty = 0;
function $clinit_StockInternalTransform(){
  $clinit_StockInternalTransform = nullMethod;
  new StockInternalTransform_0;
}

function StockInternalTransform_0(){
  $clinit_StockInternalTransform();
  this.m00 = 1;
  this.m01 = 0;
  this.m10 = 0;
  this.m11 = 1;
  this.tx = 0;
  this.ty = 0;
}

defineSeed(531, 532, {}, StockInternalTransform_0);
_.m00_0 = function m00_0(){
  return this.m00;
}
;
_.m01_0 = function m01_0(){
  return this.m01;
}
;
_.m10_0 = function m10_0(){
  return this.m10;
}
;
_.m11_0 = function m11_0(){
  return this.m11;
}
;
_.set_0 = function set_0(other){
  $setTransform_0(this, null.nullField, null.nullField, null.nullField, null.nullField, null.nullField, null.nullField);
  return this;
}
;
function $withAlignment(this$static, align){
  return new TextFormat_1(this$static.font_0, this$static.wrapWidth, align);
}

function $withFont(this$static, font){
  return new TextFormat_1(font, this$static.wrapWidth, this$static.align);
}

function TextFormat_0(){
  TextFormat_1.call(this, null, 3.4028234663852886E38, ($clinit_TextFormat$Alignment() , LEFT_1));
}

function TextFormat_1(font, wrapWidth, align){
  this.font_0 = font;
  this.wrapWidth = wrapWidth;
  this.align = align;
}

defineSeed(534, 1, makeCastMap([Q$TextFormat]), TextFormat_0, TextFormat_1);
_.equals$ = function equals_19(other){
  var ofmt;
  if (instanceOf(other, Q$TextFormat)) {
    ofmt = other;
    return (this.font_0 == ofmt.font_0 || !!this.font_0 && $equals_3(this.font_0, ofmt.font_0)) && this.wrapWidth == ofmt.wrapWidth && this.align == ofmt.align;
  }
   else {
    return false;
  }
}
;
_.hashCode$ = function hashCode_18(){
  var hash;
  hash = getHashCode(this.align) ^ round_int(this.wrapWidth);
  !!this.font_0 && (hash ^= $hashCode_1(this.font_0));
  return hash;
}
;
_.toString$ = function toString_39(){
  var wrapStr;
  wrapStr = this.wrapWidth != 3.4028234663852886E38?'' + this.wrapWidth:'n/a';
  return '[font=' + this.font_0 + ', wrapWidth=' + wrapStr + ', align=' + this.align + ']';
}
;
_.align = null;
_.font_0 = null;
_.wrapWidth = 0;
function $clinit_TextFormat$Alignment(){
  $clinit_TextFormat$Alignment = nullMethod;
  LEFT_1 = new TextFormat$Alignment$1_0;
  CENTER = new TextFormat$Alignment$2_0;
  RIGHT_1 = new TextFormat$Alignment$3_0;
  $VALUES_23 = initValues(_3Lplayn_core_TextFormat$Alignment_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$TextFormat$Alignment, [LEFT_1, CENTER, RIGHT_1]);
}

function values_24(){
  $clinit_TextFormat$Alignment();
  return $VALUES_23;
}

defineSeed(535, 39, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TextFormat$Alignment]));
var $VALUES_23, CENTER, LEFT_1, RIGHT_1;
function TextFormat$Alignment$1_0(){
  Enum_0.call(this, 'LEFT', 0);
}

defineSeed(536, 535, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TextFormat$Alignment]), TextFormat$Alignment$1_0);
_.getX = function getX(textWidth, lineWidth){
  return 0;
}
;
function TextFormat$Alignment$2_0(){
  Enum_0.call(this, 'CENTER', 1);
}

defineSeed(537, 535, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TextFormat$Alignment]), TextFormat$Alignment$2_0);
_.getX = function getX_0(textWidth, lineWidth){
  return (lineWidth - textWidth) / 2;
}
;
function TextFormat$Alignment$3_0(){
  Enum_0.call(this, 'RIGHT', 2);
}

defineSeed(538, 535, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$TextFormat$Alignment]), TextFormat$Alignment$3_0);
_.getX = function getX_1(textWidth, lineWidth){
  return lineWidth - textWidth;
}
;
--></script>
<script><!--
function combine(curTint, tint){
  var newA, newB, newG, newR;
  newA = ((~~curTint >> 24 & 255) * ((~~tint >> 24 & 255) + 1) & 65280) << 16;
  if ((tint & 16777215) == 16777215) {
    return newA | curTint & 16777215;
  }
  newR = ((~~curTint >> 16 & 255) * ((~~tint >> 16 & 255) + 1) & 65280) << 8;
  newG = (~~curTint >> 8 & 255) * ((~~tint >> 8 & 255) + 1) & 65280;
  newB = ~~((curTint & 255) * ((tint & 255) + 1)) >> 8 & 255;
  return newA | newR | newG | newB;
}

function Touch$Event$Impl_0(flags, time, x, y, id){
  Touch$Event$Impl_1.call(this, null, flags, time, x, y, id, -1, -1);
}

function Touch$Event$Impl_1(hit, flags, time, x, y, id, pressure, size){
  Events$Position$Impl_0.call(this, hit, flags, time, x, y);
  this.id_0 = id;
  this.pressure = pressure;
  this.size = size;
}

defineSeed(540, 506, makeCastMap([Q$Events$Input, Q$Events$Input$Impl, Q$Events$Position, Q$Events$Position$Impl, Q$Touch$Event, Q$Touch$Event$Impl]), Touch$Event$Impl_0, Touch$Event$Impl_1);
_.addFields = function addFields_5(builder){
  $append_11($append_12($append_8((builder.impl.string += 'time=' , builder), this.time), ', flags='), this.flags);
  $append_11($append_12($append_9($append_12($append_9((builder.impl.string += ', x=' , builder), this.x), ', y='), this.y), ', hit='), this.hit);
  $append_9($append_12($append_9($append_12($append_10((builder.impl.string += ', id=' , builder), this.id_0), ', pressure='), this.pressure), ', size='), this.size);
}
;
_.localize = function localize_3(hit){
  return new Touch$Event$Impl_1(hit, this.flags, this.time, this.x, this.y, this.id_0, this.pressure, this.size);
}
;
_.name_2 = function name_9(){
  return 'Touch.Event';
}
;
_.id_0 = 0;
_.pressure = 0;
_.size = 0;
function $clinit_TouchImpl(){
  $clinit_TouchImpl = nullMethod;
  START = new TouchImpl$1_0;
  MOVE = new TouchImpl$2_0;
  END_0 = new TouchImpl$3_0;
}

function $onTouchEnd_0(this$static, touches){
  var activeLayer, event_0, event$index, event$max;
  !!this$static.listener && $onTouchEnd(this$static.listener, touches);
  for (event$index = 0 , event$max = touches.length; event$index < event$max; ++event$index) {
    event_0 = touches[event$index];
    activeLayer = $get_4(this$static.activeLayers, valueOf(event_0.id_0));
    if (activeLayer) {
      $dispatch_0(activeLayer, Lplayn_core_Touch$LayerListener_2_classLit, event_0, END_0);
      $remove_9(this$static.activeLayers, valueOf(event_0.id_0));
    }
  }
}

function $onTouchMove_0(this$static, touches){
  var activeLayer, event_0, event$index, event$max;
  !!this$static.listener && $onTouchMove(this$static.listener, touches);
  for (event$index = 0 , event$max = touches.length; event$index < event$max; ++event$index) {
    event_0 = touches[event$index];
    activeLayer = $get_4(this$static.activeLayers, valueOf(event_0.id_0));
    !!activeLayer && $dispatch_0(activeLayer, Lplayn_core_Touch$LayerListener_2_classLit, event_0, MOVE);
  }
}

function $onTouchStart_0(this$static, touches){
  var event_0, event$index, event$max, hitLayer, p, root;
  !!this$static.listener && $onTouchStart(this$static.listener, touches);
  root = platform_1.graphics.rootLayer_0();
  if (root.interactive()) {
    for (event$index = 0 , event$max = touches.length; event$index < event$max; ++event$index) {
      event_0 = touches[event$index];
      p = new Point_1(event_0.x, event_0.y);
      root.transform_1().inverseTransform(p, p);
      p.x += root.originX_0();
      p.y += root.originY_0();
      hitLayer = root.hitTest(p);
      if (hitLayer) {
        $put_2(this$static.activeLayers, valueOf(event_0.id_0), hitLayer);
        $dispatch_0(hitLayer, Lplayn_core_Touch$LayerListener_2_classLit, event_0, START);
      }
    }
  }
}

function $setListener_0(this$static, listener){
  this$static.listener = listener;
}

defineSeed(541, 1, {});
_.listener = null;
var END_0, MOVE, START;
function TouchImpl$1_0(){
}

defineSeed(542, 1, {}, TouchImpl$1_0);
_.interact = function interact_9(l_0, ev){
  null.nullMethod();
}
;
function TouchImpl$2_0(){
}

defineSeed(543, 1, {}, TouchImpl$2_0);
_.interact = function interact_10(l_0, ev){
  null.nullMethod();
}
;
function TouchImpl$3_0(){
}

defineSeed(544, 1, {}, TouchImpl$3_0);
_.interact = function interact_11(l_0, ev){
  null.nullMethod();
}
;
function CanvasSurface_0(canvas){
  this.canvas = canvas;
}

defineSeed(545, 1, {}, CanvasSurface_0);
_.clear_2 = function clear_3(){
  this.canvas.clear_1();
  return this;
}
;
_.drawImage_2 = function drawImage(image, dx, dy, dw, dh){
  this.canvas.drawImage_0(image, dx, dy, dw, dh);
  return this;
}
;
_.drawImage_3 = function drawImage_0(image, dx, dy, dw, dh, sx, sy, sw, sh){
  this.canvas.drawImage_1(image, dx, dy, dw, dh, sx, sy, sw, sh);
  return this;
}
;
_.canvas = null;
function $transform_1(this$static, canvas){
  var transform;
  canvas.translate_0(this$static.originX, this$static.originY);
  transform = $transform_0(this$static);
  canvas.transform_2(transform.m00_0(), transform.m01_0(), transform.m10_0(), transform.m11_0(), transform.tx_0() - this$static.originX, transform.ty_0() - this$static.originY);
  canvas.translate_0(-this$static.originX, -this$static.originY);
}

function LayerCanvas_0(xform){
  AbstractLayer_0.call(this, xform);
}

defineSeed(547, 492, makeCastMap([Q$AbstractLayer, Q$Layer]));
function $paint_1(this$static, canvas, parentAlpha){
  if (!$isSet(this$static, ($clinit_AbstractLayer$Flag() , VISIBLE_1)))
    return;
  canvas.save_0();
  $transform_1(this$static, canvas);
  $paintChildren(this$static, canvas, parentAlpha * this$static.alpha_0);
  canvas.restore_0();
}

function $paintChildren(this$static, canvas, alpha){
  var child, child$iterator;
  for (child$iterator = new AbstractList$IteratorImpl_0(this$static.impl.children); child$iterator.i < child$iterator.this$0_0.size_0();) {
    child = $next_2(child$iterator);
    child.paint_0(canvas, alpha);
  }
}

function GroupLayerCanvas_0(xform){
  LayerCanvas_0.call(this, xform);
  this.impl = new GroupLayerImpl_0;
}

defineSeed(546, 547, makeCastMap([Q$AbstractLayer, Q$Layer]), GroupLayerCanvas_0);
_.add_1 = function add_10(layer){
  $add_15(this.impl, this, layer);
}
;
_.addAt = function addAt(layer, tx, ty){
  layer.setTranslation(tx, ty);
  $add_15(this.impl, this, layer);
}
;
_.clear_0 = function clear_4(){
  $removeAll_1(this.impl);
}
;
_.destroy = function destroy_13(){
  !!this.parent_0 && this.parent_0.remove_4(this);
  $setFlag(this, ($clinit_AbstractLayer$Flag() , DESTROYED), true);
  $destroyAll(this.impl, this);
}
;
_.hitTestDefault = function hitTestDefault_0(p){
  return $hitTest(this.impl, this, p);
}
;
_.onAdd = function onAdd_0(){
  $onAdd(this);
  $onAdd_0(this.impl);
}
;
_.onRemove = function onRemove_0(){
  $onRemove(this.impl);
}
;
_.paint_0 = function paint_16(canvas, parentAlpha){
  $paint_1(this, canvas, parentAlpha);
}
;
_.remove_4 = function remove_20(layer){
  $remove_16(this.impl, layer);
}
;
_.removeAll = function removeAll(){
  $removeAll_1(this.impl);
}
;
function $setImage(this$static, img){
  this$static.img = img;
  return this$static;
}

function ImageLayerCanvas_0(xform){
  LayerCanvas_0.call(this, xform);
}

defineSeed(548, 547, makeCastMap([Q$AbstractLayer, Q$Layer]), ImageLayerCanvas_0);
_.height_1 = function height_2(){
  return this.heightSet?this.height_0:this.img.height_1();
}
;
_.paint_0 = function paint_17(canvas, parentAlpha){
  var height, repX, repY, width, xScale, yScale;
  if (!$isSet(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1)) || !this.img || !this.img.isReady())
    return;
  canvas.save_0();
  canvas.setAlpha_0(parentAlpha * this.alpha_0);
  $transform_1(this, canvas);
  width = this.widthSet?this.width_0:this.img.width_1();
  height = this.heightSet?this.height_0:this.img.height_1();
  repX = this.img.repeatX_0();
  repY = this.img.repeatY_0();
  if (repX || repY) {
    if (!this.pattern || repX != this.patternRepeatX || repY != this.patternRepeatY) {
      this.patternRepeatX = repX;
      this.patternRepeatY = repY;
      this.pattern = this.img.toPattern();
    }
    canvas.setFillPattern(this.pattern);
    xScale = repX?1:width / this.img.width_1();
    yScale = repY?1:height / this.img.height_1();
    canvas.scale_1(xScale, yScale);
    canvas.fillRect_0(0, 0, width / xScale, height / yScale);
  }
   else {
    canvas.drawImage_0(this.img, 0, 0, width, height);
  }
  canvas.restore_0();
}
;
_.width_1 = function width_2(){
  return this.widthSet?this.width_0:this.img.width_1();
}
;
_.height_0 = 0;
_.heightSet = false;
_.img = null;
_.pattern = null;
_.patternRepeatX = false;
_.patternRepeatY = false;
_.width_0 = 0;
_.widthSet = false;
function ImmediateLayerCanvas_0(xform, renderer){
  LayerCanvas_0.call(this, xform);
  this.surf = new CanvasSurface_0(null);
  this.renderer = renderer;
}

defineSeed(549, 547, makeCastMap([Q$AbstractLayer, Q$Layer]), ImmediateLayerCanvas_0);
_.paint_0 = function paint_18(canvas, parentAlpha){
  if (!$isSet(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1)))
    return;
  canvas.save_0();
  $transform_1(this, canvas);
  canvas.setAlpha_0(parentAlpha * this.alpha_0);
  this.surf.canvas = canvas;
  $render(this.renderer, this.surf);
  this.surf.canvas = null;
  canvas.restore_0();
}
;
_.renderer = null;
function $drawImage_1(this$static, img, dx, dy, dw, dh, sx, sy, sw, sh){
  var d;
  d = img;
  d.draw_0(this$static.gc(), dx, dy, dw, dh, sx, sy, sw, sh);
  this$static.isDirty = true;
  return this$static;
}

defineSeed(550, 490, {});
_.drawImage_0 = function drawImage_1(img, x, y, w, h_0){
  var d;
  d = img;
  d.draw(this.gc(), x, y, w, h_0);
  this.isDirty = true;
  return this;
}
;
_.drawImage_1 = function drawImage_2(img, dx, dy, dw, dh, sx, sy, sw, sh){
  return $drawImage_1(this, img, dx, dy, dw, dh, sx, sy, sw, sh);
}
;
_.isDirty = false;
function $draw_2(this$static, shader, xform, tint, dx, dy, dw, dh){
  $draw_3(this$static, shader, xform, tint, dx, dy, dw, dh, 0, 0, this$static.repeatX?dw:this$static.width_1(), this$static.repeatY?dh:this$static.height_1());
}

function $draw_3(this$static, shader, xform, tint, dx, dy, dw, dh, sx, sy, sw, sh){
  var texHeight, texWidth;
  texWidth = this$static.width_1();
  texHeight = this$static.height_1();
  this$static.drawImpl(shader, xform, this$static.ensureTexture(), tint, dx, dy, dw, dh, sx / texWidth, sy / texHeight, (sx + sw) / texWidth, (sy + sh) / texHeight);
}

function $release(this$static){
  --this$static.refs == 0 && this$static.clearTexture();
}

defineSeed(551, 1, {});
_.drawImpl = function drawImpl(shader, xform, tex, tint, dx, dy, dw, dh, sl, st, sr, sb){
  tex > 0 && $addQuad($prepareTexture($quadShader(this.ctx, shader), tex, tint), xform, dx, dy, dx + dw, dy + dh, sl, st, sr, sb);
}
;
_.repeatX_0 = function repeatX_0(){
  return this.repeatX;
}
;
_.repeatY_0 = function repeatY_0(){
  return this.repeatY;
}
;
_.toPattern = function toPattern(){
  return new AbstractImageGL$1_0;
}
;
_.ctx = null;
_.mipmapped = false;
_.refs = 0;
_.repeatX = false;
_.repeatY = false;
function AbstractImageGL$1_0(){
}

defineSeed(552, 1, {}, AbstractImageGL$1_0);
function $scale_1(this$static, sx, sy){
  $get(this$static.transformStack, this$static.transformStack.size - 1).scale_2(sx, sy);
  return this$static;
}

function $setShader(this$static, shader){
  this$static.shader = shader;
  return this$static;
}

function $setTint(this$static, tint){
  this$static.tint = tint;
  return this$static;
}

function $topTransform(this$static){
  return $get(this$static.transformStack, this$static.transformStack.size - 1);
}

function AbstractSurfaceGL_0(ctx){
  this.transformStack = new ArrayList_0;
  this.ctx = ctx;
  $add_4(this.transformStack, new HtmlInternalTransform_0);
}

defineSeed(553, 1, {});
_.clear_2 = function clear_5(){
  this.bindFramebuffer_0();
  $clear_4(this.ctx);
  return this;
}
;
_.drawImage_2 = function drawImage_3(image, x, y, dw, dh){
  this.bindFramebuffer_0();
  $draw_2(image, this.shader, $get(this.transformStack, this.transformStack.size - 1), this.tint, x, y, dw, dh);
  return this;
}
;
_.drawImage_3 = function drawImage_4(image, dx, dy, dw, dh, sx, sy, sw, sh){
  this.bindFramebuffer_0();
  $draw_3(image, this.shader, $get(this.transformStack, this.transformStack.size - 1), this.tint, dx, dy, dw, dh, sx, sy, sw, sh);
  return this;
}
;
_.ctx = null;
_.shader = null;
_.tint = -1;
function $bind(this$static, target){
  $glBindBuffer(this$static.gl, target, this$static.bufferId);
}

function $destroy_2(this$static){
  $deleteObjects(this$static.gl, initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [this$static.bufferId]), ($clinit_HtmlGL20$WebGLObjectType() , BUFFER));
}

function $send(this$static, target, usage){
  var buffer, byteSize, count;
  count = this$static.position_1();
  byteSize = this$static.position_1() * this$static.bytesPerElement();
  this$static.flush();
  buffer = this$static.buffer_1();
  $position(buffer);
  $glBufferData(this$static.gl, target, byteSize, buffer, usage);
  return count;
}

function GL20Buffer_0(gl){
  var ids;
  this.gl = gl;
  this.bufferId = (ids = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1) , $genObjects(gl, ids, ($clinit_HtmlGL20$WebGLObjectType() , BUFFER)) , ids[0]);
}

defineSeed(554, 1, {});
_.bufferId = 0;
_.gl = null;
function $expand(this$static, capacity){
  var raw;
  raw = $order(allocateDirect(capacity * 4), ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER));
  this$static.buffer_0 = new FloatBuffer_0($slice(raw));
  this$static.staging = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, capacity, 1);
}

function $flush(this$static){
  $position(this$static.buffer_0);
  $put_0(this$static.buffer_0, this$static.staging, this$static.stagingPos);
  this$static.stagingPos = 0;
}

function $skip(this$static, count){
  this$static.stagingPos += count;
}

function GL20Buffer$FloatImpl_0(gl, capacity){
  GL20Buffer_0.call(this, gl);
  $expand(this, capacity);
}

defineSeed(555, 554, {}, GL20Buffer$FloatImpl_0);
_.buffer_1 = function buffer_0(){
  return this.buffer_0;
}
;
_.bytesPerElement = function bytesPerElement(){
  return 4;
}
;
_.flush = function flush_0(){
  $flush(this);
}
;
_.position_1 = function position_0(){
  return this.stagingPos;
}
;
_.toString$ = function toString_40(){
  return 'floatbuf:' + this.bufferId;
}
;
_.buffer_0 = null;
_.staging = null;
_.stagingPos = 0;
function $add_16(this$static, value){
  this$static.staging[this$static.stagingPos++] = ~~(value << 16) >> 16;
  return this$static;
}

function $add_17(this$static, x, y){
  this$static.staging[this$static.stagingPos++] = ~~(x << 16) >> 16;
  this$static.staging[this$static.stagingPos++] = ~~(y << 16) >> 16;
  return this$static;
}

function $drawElements_0(this$static, count){
  $glDrawElements(this$static.gl, count);
}

function $expand_0(this$static, capacity){
  this$static.buffer_0 = $asShortBuffer($order(allocateDirect(capacity * 2), ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER)));
  this$static.staging = initDim(_3S_classLit, makeCastMap([Q$Serializable]), -1, capacity, 1);
}

function $skip_0(this$static, count){
  this$static.stagingPos += count;
}

function GL20Buffer$ShortImpl_0(gl, capacity){
  GL20Buffer_0.call(this, gl);
  this.buffer_0 = $asShortBuffer($order(allocateDirect(capacity * 2), ($clinit_ByteOrder() , $clinit_ByteOrder() , NATIVE_ORDER)));
  this.staging = initDim(_3S_classLit, makeCastMap([Q$Serializable]), -1, capacity, 1);
}

defineSeed(556, 554, {}, GL20Buffer$ShortImpl_0);
_.buffer_1 = function buffer_1(){
  return this.buffer_0;
}
;
_.bytesPerElement = function bytesPerElement_0(){
  return 2;
}
;
_.flush = function flush_1(){
  $position(this.buffer_0);
  $put_1(this.buffer_0, this.staging, this.stagingPos);
  this.stagingPos = 0;
}
;
_.position_1 = function position_1(){
  return this.stagingPos;
}
;
_.toString$ = function toString_41(){
  return 'shortbuf:' + this.bufferId;
}
;
_.buffer_0 = null;
_.staging = null;
_.stagingPos = 0;
function $bindFramebuffer_0(this$static, fbuf, width, height){
  if (fbuf != this$static.lastFramebuffer) {
    $checkGLError(this$static, 'bindFramebuffer');
    $flush_0(this$static, false);
    $bindFramebufferImpl(this$static, this$static.lastFramebuffer = fbuf, this$static.curFbufWidth = width, this$static.curFbufHeight = height);
  }
}

function $createFramebuffer(this$static, tex){
  $flush_0(this$static, false);
  return $createFramebufferImpl(this$static, tex);
}

function $createQuadShader(this$static){
  var $e0, quadShader, t, maxVecs;
  if (maxVecs = this$static.gl.gl.getParameter(36347) - 3 , maxVecs >= 48) {
    try {
      quadShader = new QuadShader_0(this$static);
      quadShader.texCore = new QuadShader$QuadCore_0(quadShader, $replace_1($replace_1('uniform vec2 u_ScreenSize;\nuniform vec4 u_Data[_VEC4S_PER_QUAD_*_MAX_QUADS_];\nattribute vec3 a_Vertex;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\nint index = _VEC4S_PER_QUAD_*int(a_Vertex.z);\nvec4 mat = u_Data[index+0];\nvec4 txc = u_Data[index+1];\nvec4 tcs = u_Data[index+2];\nmat3 transform = mat3(\n  mat.x, mat.y, 0,\n  mat.z, mat.w, 0,\n  txc.x, txc.y, 1);\ngl_Position = vec4(transform * vec3(a_Vertex.xy, 1.0), 1.0);\ngl_Position.xy /= u_ScreenSize.xy;\ngl_Position.x -= 1.0;\ngl_Position.y = 1.0 - gl_Position.y;\nv_TexCoord = a_Vertex.xy * tcs.xy + txc.zw;\nfloat red = mod(tcs.z, 256.0);\nfloat alpha = (tcs.z - red) / 256.0;\nfloat blue = mod(tcs.w, 256.0);\nfloat green = (tcs.w - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}', '_MAX_QUADS_', '' + quadShader.maxQuads), '_VEC4S_PER_QUAD_', '3'), $textureFragmentShader());
      quadShader.texExtras = new GLShader$TextureExtras_0(quadShader, quadShader.texCore.prog);
      quadShader.colorCore = new QuadShader$QuadCore_0(quadShader, $replace_1($replace_1('uniform vec2 u_ScreenSize;\nuniform vec4 u_Data[_VEC4S_PER_QUAD_*_MAX_QUADS_];\nattribute vec3 a_Vertex;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\nint index = _VEC4S_PER_QUAD_*int(a_Vertex.z);\nvec4 mat = u_Data[index+0];\nvec4 txc = u_Data[index+1];\nvec4 tcs = u_Data[index+2];\nmat3 transform = mat3(\n  mat.x, mat.y, 0,\n  mat.z, mat.w, 0,\n  txc.x, txc.y, 1);\ngl_Position = vec4(transform * vec3(a_Vertex.xy, 1.0), 1.0);\ngl_Position.xy /= u_ScreenSize.xy;\ngl_Position.x -= 1.0;\ngl_Position.y = 1.0 - gl_Position.y;\nv_TexCoord = a_Vertex.xy * tcs.xy + txc.zw;\nfloat red = mod(tcs.z, 256.0);\nfloat alpha = (tcs.z - red) / 256.0;\nfloat blue = mod(tcs.w, 256.0);\nfloat green = (tcs.w - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}', '_MAX_QUADS_', '' + quadShader.maxQuads), '_VEC4S_PER_QUAD_', '3'), '#ifdef GL_ES\nprecision lowp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\nvarying lowp vec4 v_Color;\nvoid main(void) {\n  gl_FragColor = vec4(v_Color.rgb, 1) * v_Color.a;\n}');
      return quadShader;
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (instanceOf($e0, Q$Throwable)) {
        t = $e0;
        $logImpl((this$static.platform.log_0 , 2), 'Failed to create QuadShader: ' + t, null);
      }
       else 
        throw $e0;
    }
  }
  return new IndexedTrisShader_0(this$static);
}

function $flush_0(this$static, deactivate){
  if (this$static.curShader) {
    $checkGLError(this$static, 'flush()');
    $flush_1(this$static.curShader);
    deactivate && this$static.curShader.curCore.deactivate();
    this$static.curShader = null;
  }
}

function $quadShader(this$static, custom){
  return !custom?this$static.quadShader:custom;
}

function $setSize(this$static, width, height){
  this$static.viewWidth = width;
  this$static.viewHeight = height;
  this$static.curFbufWidth = this$static.defaultFbufWidth = $scaledCeil(this$static.scale_0, width);
  this$static.curFbufHeight = this$static.defaultFbufHeight = $scaledCeil(this$static.scale_0, height);
  $bindFramebufferImpl(this$static, 0, this$static.defaultFbufWidth, this$static.defaultFbufHeight);
}

function $useShader(this$static, shader, forceFlush){
  if (this$static.curShader == shader && !forceFlush)
    return false;
  $checkGLError(this$static, 'useShader');
  $flush_0(this$static, true);
  this$static.curShader = shader;
  return true;
}

defineSeed(558, 1, {});
_.createTransform = function createTransform(){
  return new StockInternalTransform_0;
}
;
_.curFbufHeight = 0;
_.curFbufWidth = 0;
_.curShader = null;
_.defaultFbufHeight = 0;
_.defaultFbufWidth = 0;
_.epoch = 0;
_.lastFramebuffer = 0;
_.platform = null;
_.pushedFramebuffer = -1;
_.pushedHeight = 0;
_.pushedWidth = 0;
_.scale_0 = null;
_.viewHeight = 0;
_.viewWidth = 0;
function $bindFramebufferImpl(this$static, fbuf, width, height){
  $glBindFramebuffer(this$static.gl, fbuf);
  $glViewport(this$static.gl, width, height);
  ++this$static.stats.frameBufferBinds;
}

function $bindTexture_0(this$static, tex){
  $glBindTexture(this$static.gl, tex);
  ++this$static.stats.texBinds;
}

function $checkGLError(this$static, op){
  var error;
  if (this$static.checkErrors) {
    while ((error = this$static.gl.gl.getError()) != 0) {
      $logImpl((platform_1.log_0 , 3), Lplayn_html_HtmlGLContext_2_classLit.typeName + ' -- ' + op + ': glError ' + error, null);
    }
  }
}

function $clear_4(this$static){
  $glClearColor(this$static.gl, 0, 0, 0, 0);
  $glClear(this$static.gl, 16384);
}

function $createFloatBuffer(this$static, capacity){
  return new GL20Buffer$FloatImpl_0(this$static.gl, capacity);
}

function $createFramebufferImpl(this$static, tex){
  var fbuf;
  fbuf = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1);
  $genObjects(this$static.gl, fbuf, ($clinit_HtmlGL20$WebGLObjectType() , FRAME_BUFFER));
  $glBindFramebuffer(this$static.gl, fbuf[0]);
  $glFramebufferTexture2D(this$static.gl, tex);
  ++this$static.stats.frameBufferCreates;
  return fbuf[0];
}

function $createProgram(this$static, vertShader, fragShader){
  ++this$static.stats.shaderCreates;
  return new GL20Program_0(this$static, this$static.gl, vertShader, fragShader);
}

function $createShortBuffer(this$static, capacity){
  return new GL20Buffer$ShortImpl_0(this$static.gl, capacity);
}

function $createTexture(this$static, width, height, repeatX, repeatY, mm){
  var tex;
  tex = $createTexture_0(this$static, repeatX, repeatY, mm);
  $glTexImage2D(this$static.gl, width, height);
  return tex;
}

function $createTexture_0(this$static, repeatX, repeatY, mipmaps){
  var tex;
  tex = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1);
  $genObjects(this$static.gl, tex, ($clinit_HtmlGL20$WebGLObjectType() , TEXTURE));
  $glBindTexture(this$static.gl, tex[0]);
  $glTexParameteri(this$static.gl, 10240, 9729);
  $glTexParameteri(this$static.gl, 10241, mipmapify(mipmaps));
  $glTexParameteri(this$static.gl, 10242, repeatX?10497:33071);
  $glTexParameteri(this$static.gl, 10243, repeatY?10497:33071);
  ++this$static.stats.texCreates;
  return tex[0];
}

function $destroyTexture(this$static, tex){
  $flush_0(this$static, false);
  $deleteObjects(this$static.gl, initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [tex]), ($clinit_HtmlGL20$WebGLObjectType() , TEXTURE));
}

function $generateMipmap(this$static, tex){
  $glBindTexture(this$static.gl, tex);
  this$static.gl.gl.generateMipmap(3553);
}

function $paint_2(this$static, rootLayer){
  if (rootLayer.impl.children.size > 0) {
    $checkGLError(this$static, 'paint');
    $bindFramebuffer_0(this$static, 0, this$static.defaultFbufWidth, this$static.defaultFbufHeight);
    $glClear(this$static.gl, 16640);
    $paint_3(rootLayer, this$static.rootXform, -1, null);
    $useShader(this$static, null, false);
  }
  ++this$static.stats.frames_0;
}

function GL20Context_0(platform, gl, checkErrors){
  this.stats = new GLContext$Stats_0;
  new ArrayList_0;
  this.scale_0 = new Scale_0(1);
  this.platform = platform;
  this.gl = gl;
  this.checkErrors = checkErrors;
  this.rootXform = this.createTransform();
  this.rootXform.uniformScale(1);
}

function mipmapify(mipmaps){
  if (!mipmaps)
    return 9729;
  switch (9729) {
    case 9728:
    case 9729:
      return 9985;
  }
}

defineSeed(557, 558, {});
_.checkErrors = false;
_.gl = null;
_.quadShader = null;
_.rootXform = null;
_.trisShader = null;
function $bind_0(this$static){
  $glUseProgram(this$static.gl, this$static.program);
}

function $compileShader_0(this$static, type, shaderSource){
  var compiled, log, shader;
  shader = $glCreateShader(this$static.gl, type);
  if (shader == 0)
    throw new RuntimeException_0('Failed to create shader (' + type + '): ' + this$static.gl.gl.getError());
  $glShaderSource(this$static.gl, shader, shaderSource);
  $glCompileShader(this$static.gl, shader);
  compiled = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1);
  $glGetShaderiv(this$static.gl, shader, compiled);
  if (compiled[0] == 0) {
    log = $glGetShaderInfoLog(this$static.gl, shader);
    $deleteObject(this$static.gl, shader, ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
    throw new RuntimeException_0('Failed to compile shader (' + type + '): ' + log);
  }
  return shader;
}

function $destroy_3(this$static){
  $deleteObject(this$static.gl, this$static.vertexShader, ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
  $deleteObject(this$static.gl, this$static.fragmentShader, SHADER);
  $deleteObject(this$static.gl, this$static.program, PROGRAM);
}

function $getAttrib(this$static, name_0, size, type){
  var loc;
  loc = $glGetAttribLocation(this$static.gl, this$static.program, name_0);
  return loc < 0?null:new GL20Program$10_0(this$static, loc, size, type);
}

function $getUniform2f(this$static){
  var loc;
  loc = $glGetUniformLocation(this$static.gl, this$static.program, 'u_ScreenSize');
  return loc < 0?null:new GL20Program$2_0(this$static, loc);
}

function $getUniform4fv(this$static){
  var loc;
  loc = $glGetUniformLocation(this$static.gl, this$static.program, 'u_Data');
  return loc < 0?null:new GL20Program$8_0(this$static, loc);
}

function GL20Program_0(ctx, gl, vertexSource, fragmentSource){
  var fragmentShader, linkStatus, log, program, vertexShader;
  this.gl = gl;
  program = 0;
  vertexShader = 0;
  fragmentShader = 0;
  try {
    program = $createObject(gl, gl.gl.createProgram(), ($clinit_HtmlGL20$WebGLObjectType() , PROGRAM));
    if (program == 0) {
      throw new RuntimeException_0('Failed to create program: ' + gl.gl.getError());
    }
    vertexShader = $compileShader_0(this, 35633, vertexSource);
    $attachShader(gl.gl, gl.webGLObjects[program], gl.webGLObjects[vertexShader]);
    $checkGLError(ctx, 'Attached vertex shader');
    fragmentShader = $compileShader_0(this, 35632, fragmentSource);
    $attachShader(gl.gl, gl.webGLObjects[program], gl.webGLObjects[fragmentShader]);
    $checkGLError(ctx, 'Attached fragment shader');
    $linkProgram(gl.gl, gl.webGLObjects[program]);
    linkStatus = initDim(_3I_classLit, makeCastMap([Q$Serializable]), -1, 1, 1);
    linkStatus[0] = $getProgramParameterb(gl.gl, gl.webGLObjects[program], 35714)?1:0;
    if (linkStatus[0] == 0) {
      log = $getProgramInfoLog(gl.gl, gl.webGLObjects[program]);
      $deleteObject(gl, program, PROGRAM);
      throw new RuntimeException_0('Failed to link program: ' + log);
    }
    this.program = program;
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    program = vertexShader = fragmentShader = 0;
  }
   finally {
    program != 0 && $deleteObject(gl, program, ($clinit_HtmlGL20$WebGLObjectType() , PROGRAM));
    vertexShader != 0 && $deleteObject(gl, vertexShader, ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
    fragmentShader != 0 && $deleteObject(gl, fragmentShader, ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
  }
}

defineSeed(559, 1, {}, GL20Program_0);
_.fragmentShader = 0;
_.gl = null;
_.program = 0;
_.vertexShader = 0;
function $bind_1(this$static, stride, offset){
  $glEnableVertexAttribArray(this$static.this$0.gl, this$static.val$loc);
  $glVertexAttribPointer(this$static.this$0.gl, this$static.val$loc, this$static.val$size, this$static.val$type, stride, offset);
}

function $unbind(this$static){
  $glDisableVertexAttribArray(this$static.this$0.gl, this$static.val$loc);
}

function GL20Program$10_0(this$0, val$loc, val$size, val$type){
  this.this$0 = this$0;
  this.val$loc = val$loc;
  this.val$size = val$size;
  this.val$type = val$type;
}

defineSeed(560, 1, {}, GL20Program$10_0);
_.this$0 = null;
_.val$loc = 0;
_.val$size = 0;
_.val$type = 0;
function $bind_2(this$static, a, b){
  $glUniform2f(this$static.this$0.gl, this$static.val$loc, a, b);
}

function GL20Program$2_0(this$0, val$loc){
  this.this$0 = this$0;
  this.val$loc = val$loc;
}

defineSeed(561, 1, {}, GL20Program$2_0);
_.this$0 = null;
_.val$loc = 0;
function $bind_3(this$static){
  $glUniform1i(this$static.this$0.gl, this$static.val$loc);
}

function GL20Program$5_0(this$0, val$loc){
  this.this$0 = this$0;
  this.val$loc = val$loc;
}

defineSeed(562, 1, {}, GL20Program$5_0);
_.this$0 = null;
_.val$loc = 0;
function $bind_4(this$static, data, count){
  var buffer;
  $flush(data);
  buffer = data.buffer_0;
  $position(buffer);
  $glUniform4fv(this$static.this$0.gl, this$static.val$loc, count, buffer);
}

function GL20Program$8_0(this$0, val$loc){
  this.this$0 = this$0;
  this.val$loc = val$loc;
}

defineSeed(563, 1, {}, GL20Program$8_0);
_.this$0 = null;
_.val$loc = 0;
function GLContext$Stats_0(){
}

defineSeed(564, 1, {}, GLContext$Stats_0);
_.frameBufferBinds = 0;
_.frameBufferCreates = 0;
_.frames_0 = 0;
_.quadsRendered = 0;
_.shaderBinds = 0;
_.shaderCreates = 0;
_.shaderFlushes = 0;
_.texBinds = 0;
_.texCreates = 0;
--></script>
<script><!--
function $addQuad(this$static, local, left, top_0, right, bottom, sl, st, sr, sb){
  this$static.curCore.addQuad(local.m00_0(), local.m01_0(), local.m10_0(), local.m11_0(), local.tx_0(), local.ty_0(), left, top_0, sl, st, right, top_0, sr, st, left, bottom, sl, sb, right, bottom, sr, sb);
  ++this$static.ctx.stats.quadsRendered;
}

function $clearProgram(this$static){
  if (this$static.texCore) {
    this$static.texCore.destroy();
    this$static.texCore = null;
    this$static.texExtras = null;
  }
  if (this$static.colorCore) {
    $destroy_4(this$static.colorCore);
    this$static.colorCore = null;
  }
  this$static.curCore = null;
  this$static.curExtras = null;
}

function $flush_1(this$static){
  $willFlush(this$static.curExtras);
  this$static.curCore.flush();
  ++this$static.ctx.stats.shaderFlushes;
}

function $prepareTexture(this$static, tex, tint){
  var justActivated;
  if (this$static.texEpoch != this$static.ctx.epoch) {
    this$static.texCore = null;
    this$static.texExtras = null;
  }
  if (!this$static.texCore) {
    this$static.texEpoch = this$static.ctx.epoch;
    this$static.texCore = this$static.createTextureCore();
    this$static.texExtras = new GLShader$TextureExtras_0(this$static, this$static.texCore.prog);
  }
  justActivated = $useShader(this$static.ctx, this$static, this$static.curCore != this$static.texCore);
  if (justActivated) {
    this$static.curCore = this$static.texCore;
    this$static.curExtras = this$static.texExtras;
    this$static.texCore.activate(this$static.ctx.curFbufWidth, this$static.ctx.curFbufHeight);
    ++this$static.ctx.stats.shaderBinds;
  }
  this$static.texCore.prepare(tint, justActivated);
  $prepare(this$static.texExtras, tex, justActivated);
  return this$static;
}

function $textureFragmentShader(){
  var str;
  str = new StringBuilder_1('#ifdef GL_ES\nprecision lowp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n');
  str.impl.string += 'uniform lowp sampler2D u_Texture;\n';
  str.impl.string += 'varying mediump vec2 v_TexCoord;\nvarying lowp vec4 v_Color;\n';
  str.impl.string += 'void main(void) {\n';
  str.impl.string += '  vec4 textureColor = texture2D(u_Texture, v_TexCoord);\n';
  str.impl.string += '  textureColor.rgb *= v_Color.rgb;\n';
  str.impl.string += '  textureColor *= v_Color.a;\n';
  str.impl.string += '  gl_FragColor = textureColor;\n}';
  return str.impl.string;
}

defineSeed(565, 1, {});
_.colorCore = null;
_.ctx = null;
_.curCore = null;
_.curExtras = null;
_.texCore = null;
_.texEpoch = 0;
_.texExtras = null;
function GLShader$Core_0(this$0, vertShader, fragShader){
  this.prog = $createProgram(this$0.ctx, vertShader, fragShader);
}

defineSeed(566, 1, {});
_.destroy = function destroy_14(){
  $destroy_3(this.prog);
}
;
_.prog = null;
defineSeed(567, 1, {});
function $prepare(this$static, tex, justActivated){
  var stateChanged;
  $checkGLError(this$static.this$0.ctx, 'textureShader.prepare start');
  stateChanged = tex != this$static.lastTex;
  if (!justActivated && stateChanged) {
    $flush_1(this$static.this$0);
    $checkGLError(this$static.this$0.ctx, 'textureShader.prepare flush');
  }
  if (stateChanged) {
    this$static.lastTex = tex;
    $checkGLError(this$static.this$0.ctx, 'textureShader.prepare end');
  }
  if (justActivated) {
    this$static.this$0.ctx.gl.gl.activeTexture(33984);
    $bind_3(this$static.uTexture);
  }
}

function $willFlush(this$static){
  $bindTexture_0(this$static.this$0.ctx, this$static.lastTex);
}

function GLShader$TextureExtras_0(this$0, prog){
  var loc;
  this.this$0 = this$0;
  this.uTexture = (loc = $glGetUniformLocation(prog.gl, prog.program, 'u_Texture') , loc < 0?null:new GL20Program$5_0(prog, loc));
}

defineSeed(568, 567, {}, GLShader$TextureExtras_0);
_.lastTex = 0;
_.this$0 = null;
_.uTexture = null;
function nextPowerOfTwo(x){
  var bit, count, highest, i;
  bit = 32768;
  highest = -1;
  count = 0;
  for (i = 15; i >= 0; --i , bit >>= 1) {
    if ((x & bit) != 0) {
      ++count;
      highest == -1 && (highest = i);
    }
  }
  if (count <= 1) {
    return 0;
  }
  return 1 << highest + 1;
}

function LayerGL_0(){
  AbstractLayer_0.call(this, new HtmlInternalTransform_0);
  this.savedLocal = new HtmlInternalTransform_0;
}

defineSeed(571, 492, makeCastMap([Q$AbstractLayer, Q$Layer]));
_.destroy = function destroy_15(){
  !!this.parent_0 && this.parent_0.remove_4(this);
  $setFlag(this, ($clinit_AbstractLayer$Flag() , DESTROYED), true);
}
;
_.savedLocal = null;
function $paint_3(this$static, curTransform, curTint, curShader){
  if (!$isSet(this$static, ($clinit_AbstractLayer$Flag() , VISIBLE_1)))
    return;
  this$static.tint != -1 && (curTint = combine(curTint, this$static.tint));
  $render_0(this$static, ($set_14(this$static.savedLocal, curTransform) , $concatenate_0(this$static.savedLocal, $transform_0(this$static), this$static.originX, this$static.originY)), curTint, curShader);
}

function $render_0(this$static, xform, curTint, shader){
  var children, ii, ll;
  children = this$static.impl.children;
  for (ii = 0 , ll = children.size; ii < ll; ++ii) {
    (checkIndex(ii, children.size) , children.array[ii]).paint_1(xform, curTint, shader);
  }
}

function GroupLayerGL_0(){
  LayerGL_0.call(this);
  this.impl = new GroupLayerImpl_0;
}

defineSeed(570, 571, makeCastMap([Q$AbstractLayer, Q$Layer]), GroupLayerGL_0);
_.add_1 = function add_11(layer){
  $add_15(this.impl, this, layer);
}
;
_.addAt = function addAt_0(layer, tx, ty){
  layer.setTranslation(tx, ty);
  $add_15(this.impl, this, layer);
}
;
_.clear_0 = function clear_6(){
  $removeAll_1(this.impl);
}
;
_.destroy = function destroy_16(){
  !!this.parent_0 && this.parent_0.remove_4(this);
  $setFlag(this, ($clinit_AbstractLayer$Flag() , DESTROYED), true);
  $destroyAll(this.impl, this);
}
;
_.hitTestDefault = function hitTestDefault_1(p){
  return $hitTest(this.impl, this, p);
}
;
_.onAdd = function onAdd_1(){
  $onAdd(this);
  $onAdd_0(this.impl);
}
;
_.onRemove = function onRemove_1(){
  $onRemove(this.impl);
}
;
_.paint_1 = function paint_19(curTransform, curTint, curShader){
  $paint_3(this, curTransform, curTint, curShader);
}
;
_.remove_4 = function remove_21(layer){
  $remove_16(this.impl, layer);
}
;
_.removeAll = function removeAll_0(){
  $removeAll_1(this.impl);
}
;
function $clearTexture(this$static){
  if (this$static.tex > 0) {
    $destroyTexture(this$static.ctx, this$static.tex);
    this$static.tex = 0;
  }
}

function $createMainTex(this$static){
  var tex;
  tex = $createTexture_0(this$static.ctx, false, false, false);
  this$static.updateTexture(tex);
  return tex;
}

function $createPow2RepTex(this$static, width, height, repeatX, repeatY, mipmapped){
  var powtex;
  powtex = $createTexture(this$static.ctx, width, height, repeatX, repeatY, mipmapped);
  this$static.updateTexture(powtex);
  return powtex;
}

function $scaleTexture(this$static){
  var height, reptex, scaledHeight, scaledWidth, tex, width;
  scaledWidth = $scaledCeil(this$static.scale_0, this$static.width_1());
  scaledHeight = $scaledCeil(this$static.scale_0, this$static.height_1());
  width = nextPowerOfTwo(scaledWidth);
  height = nextPowerOfTwo(scaledHeight);
  if (width == 0 && height == 0) {
    reptex = $createPow2RepTex(this$static, scaledWidth, scaledHeight, this$static.repeatX, this$static.repeatY, this$static.mipmapped);
    this$static.mipmapped && $generateMipmap(this$static.ctx, reptex);
    return reptex;
  }
  tex = $createMainTex(this$static);
  width == 0 && (width = scaledWidth);
  height == 0 && (height = scaledHeight);
  try {
    return convertToRepTex(this$static.ctx, tex, width, height, this$static.repeatX, this$static.repeatY, this$static.mipmapped);
  }
   finally {
    $destroyTexture(this$static.ctx, tex);
  }
}

function ImageGL_0(ctx, scale){
  this.ctx = ctx;
  this.scale_0 = scale;
}

function convertToRepTex(ctx, tex, width, height, repeatX, repeatY, mipmapped){
  var fbuf, reptex, shader;
  reptex = $createTexture(ctx, width, height, repeatX, repeatY, mipmapped);
  fbuf = ($flush_0(ctx, false) , $createFramebufferImpl(ctx, reptex));
  ctx.pushedFramebuffer = ctx.lastFramebuffer;
  ctx.pushedWidth = ctx.curFbufWidth;
  ctx.pushedHeight = ctx.curFbufHeight;
  $bindFramebuffer_0(ctx, fbuf, width, height);
  try {
    $glClearColor(ctx.gl, 0, 0, 0, 0);
    $glClear(ctx.gl, 16384);
    shader = $prepareTexture(ctx.quadShader, tex, -1);
    $addQuad(shader, new HtmlInternalTransform_0, 0, height, width, 0, 0, 0, 1, 1);
    $flush_1(shader);
    mipmapped && ($glBindTexture(ctx.gl, reptex) , ctx.gl.gl.generateMipmap(3553) , undefined);
    return reptex;
  }
   finally {
    $bindFramebuffer_0(ctx, ctx.pushedFramebuffer, ctx.pushedWidth, ctx.pushedHeight);
    ctx.pushedFramebuffer = -1;
    $deleteObjects(ctx.gl, initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [fbuf]), ($clinit_HtmlGL20$WebGLObjectType() , FRAME_BUFFER));
  }
}

defineSeed(572, 551, {});
_.clearTexture = function clearTexture(){
  $clearTexture(this);
}
;
_.ensureTexture = function ensureTexture(){
  return this.tex != 0?this.tex:this.isReady()?this.repeatX || this.repeatY || this.mipmapped?(this.tex = $scaleTexture(this)):(this.tex = $createMainTex(this)):0;
}
;
_.scale_0 = null;
_.tex = 0;
function $setImage_0(this$static, img){
  if (this$static.img != img) {
    !!this$static.img && $release(this$static.img);
    this$static.img = img;
    !!this$static.img && ++this$static.img.refs;
  }
  return this$static;
}

function ImageLayerGL_0(){
  LayerGL_0.call(this);
}

defineSeed(573, 571, makeCastMap([Q$AbstractLayer, Q$Layer]), ImageLayerGL_0);
_.destroy = function destroy_17(){
  !!this.parent_0 && this.parent_0.remove_4(this);
  $setFlag(this, ($clinit_AbstractLayer$Flag() , DESTROYED), true);
  $setImage_0(this, null);
}
;
_.height_1 = function height_3(){
  return this.heightSet?this.height_0:this.img.height_1();
}
;
_.paint_1 = function paint_20(curTransform, curTint, curShader){
  if ($isSet(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1)) && !!this.img) {
    this.tint != -1 && (curTint = combine(curTint, this.tint));
    $draw_2(this.img, curShader, ($set_14(this.savedLocal, curTransform) , $concatenate_0(this.savedLocal, $transform_0(this), this.originX, this.originY)), curTint, 0, 0, this.widthSet?this.width_0:this.img.width_1(), this.heightSet?this.height_0:this.img.height_1());
  }
}
;
_.width_1 = function width_3(){
  return this.widthSet?this.width_0:this.img.width_1();
}
;
_.height_0 = 0;
_.heightSet = false;
_.img = null;
_.width_0 = 0;
_.widthSet = false;
function ImmediateLayerGL_0(ctx, renderer){
  ImmediateLayerGL_1.call(this, renderer, new ImmediateLayerGL$1_0(ctx));
}

function ImmediateLayerGL_1(renderer, surface){
  LayerGL_0.call(this);
  this.surface = surface;
  this.renderer = renderer;
}

defineSeed(574, 571, makeCastMap([Q$AbstractLayer, Q$Layer]), ImmediateLayerGL_0);
_.paint_1 = function paint_21(curTransform, curTint, curShader){
  var xform;
  if (!$isSet(this, ($clinit_AbstractLayer$Flag() , VISIBLE_1)))
    return;
  xform = ($set_14(this.savedLocal, curTransform) , $concatenate_0(this.savedLocal, $transform_0(this), this.originX, this.originY));
  $topTransform(this.surface).set_0(xform);
  this.tint != -1 && (curTint = combine(curTint, this.tint));
  $setTint(this.surface, curTint);
  $setShader(this.surface, curShader);
  $render(this.renderer, this.surface);
  $setShader(this.surface, null);
}
;
_.renderer = null;
_.surface = null;
defineSeed(576, 553, {});
_.bindFramebuffer_0 = function bindFramebuffer(){
}
;
function ImmediateLayerGL$1_0($anonymous0){
  AbstractSurfaceGL_0.call(this, $anonymous0);
}

defineSeed(575, 576, {}, ImmediateLayerGL$1_0);
function $clinit_IndexedTrisShader(){
  $clinit_IndexedTrisShader = nullMethod;
  QUAD_INDICES = initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [0, 1, 2, 1, 3, 2]);
}

function IndexedTrisShader_0(ctx){
  $clinit_IndexedTrisShader();
  this.ctx = ctx;
  this.delayedBinding = false;
}

function addVert(data, offset, prefix, x, y, sx, sy){
  $clinit_IndexedTrisShader();
  arraycopy(prefix, 0, data, offset, prefix.length);
  offset += prefix.length;
  data[offset++] = x;
  data[offset++] = y;
  data[offset++] = sx;
  data[offset++] = sy;
  return offset;
}

defineSeed(577, 565, {}, IndexedTrisShader_0);
_.createTextureCore = function createTextureCore(){
  return new IndexedTrisShader$ITCore_0(this, $textureFragmentShader());
}
;
_.toString$ = function toString_42(){
  return 'itris/' + this.texCore + '/' + this.colorCore;
}
;
_.delayedBinding = false;
var QUAD_INDICES;
function $addElems(this$static, vertIdx, indices){
  var data, ii, ll, offset;
  data = this$static.elements.staging;
  offset = this$static.elements.stagingPos;
  for (ii = 0 , ll = indices.length; ii < ll; ++ii) {
    data[offset++] = ~~(vertIdx + indices[ii] << 16) >> 16;
  }
  $skip_0(this$static.elements, offset - this$static.elements.stagingPos);
}

function $addExtraStableAttrs(this$static, buf, sidx){
  buf[sidx++] = this$static.arTint;
  buf[sidx++] = this$static.gbTint;
  return sidx;
}

function $beginPrimitive(this$static){
  var availElems, availVerts, elems, vertIdx, verts;
  vertIdx = ~~(this$static.vertices.stagingPos / 12);
  verts = vertIdx + 4;
  elems = this$static.elements.stagingPos + 6;
  availVerts = ~~(this$static.vertices.staging.length / 12);
  availElems = this$static.elements.staging.length;
  if (verts > availVerts || elems > availElems) {
    $flush_1(this$static.this$0);
    verts > availVerts && $expandVerts(this$static, verts);
    elems > availElems && $expandElems(this$static, elems);
    return 0;
  }
  return vertIdx;
}

function $bindAttribsBufs(this$static){
  $bind(this$static.vertices, 34962);
  $bind_1(this$static.aMatrix, 48, 0);
  $bind_1(this$static.aTranslation, 48, 16);
  $bind_1(this$static.aColor, 48, 24);
  $bind_1(this$static.aPosition, 48, 32);
  !!this$static.aTexCoord && $bind_1(this$static.aTexCoord, 48, 40);
  $bind(this$static.elements, 34963);
}

function $expandElems(this$static, elemCount){
  var newElems;
  newElems = this$static.elements.staging.length;
  while (newElems < elemCount)
    newElems += 96;
  $expand_0(this$static.elements, newElems);
}

function $expandVerts(this$static, vertCount){
  var newVerts;
  newVerts = ~~(this$static.vertices.staging.length / 12);
  while (newVerts < vertCount)
    newVerts += 64;
  $expand(this$static.vertices, newVerts * 12);
}

function IndexedTrisShader$ITCore_0(this$0, fragShader){
  this.this$0 = this$0;
  GLShader$Core_0.call(this, this$0, 'uniform vec2 u_ScreenSize;\nattribute vec4 a_Matrix;\nattribute vec2 a_Translation;\nattribute vec2 a_Color;\nattribute vec2 a_Position;\nattribute vec2 a_TexCoord;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\nmat3 transform = mat3(\n  a_Matrix[0], a_Matrix[1], 0,\n  a_Matrix[2], a_Matrix[3], 0,\n  a_Translation[0], a_Translation[1], 1);\ngl_Position = vec4(transform * vec3(a_Position, 1.0), 1);\ngl_Position.xy /= (u_ScreenSize.xy / 2.0);\ngl_Position.x -= 1.0;\ngl_Position.y = 1.0 - gl_Position.y;\nv_TexCoord = a_TexCoord;\nfloat red = mod(a_Color.x, 256.0);\nfloat alpha = (a_Color.x - red) / 256.0;\nfloat blue = mod(a_Color.y, 256.0);\nfloat green = (a_Color.y - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}', fragShader);
  this.uScreenSize = $getUniform2f(this.prog);
  this.aMatrix = $getAttrib(this.prog, 'a_Matrix', 4, 5126);
  this.aTranslation = $getAttrib(this.prog, 'a_Translation', 2, 5126);
  this.aColor = $getAttrib(this.prog, 'a_Color', 2, 5126);
  this.aPosition = $getAttrib(this.prog, 'a_Position', 2, 5126);
  this.aTexCoord = $getAttrib(this.prog, 'a_TexCoord', 2, 5126);
  this.stableAttrs = initDim(_3F_classLit, makeCastMap([Q$Serializable]), -1, 8, 1);
  this.vertices = $createFloatBuffer(this$0.ctx, 768);
  this.elements = $createShortBuffer(this$0.ctx, 96);
}

defineSeed(578, 566, {}, IndexedTrisShader$ITCore_0);
_.activate = function activate(fbufWidth, fbufHeight){
  $bind_0(this.prog);
  $bind_2(this.uScreenSize, fbufWidth, fbufHeight);
  this.this$0.delayedBinding || $bindAttribsBufs(this);
  $checkGLError(this.this$0.ctx, 'Shader.activate bind');
}
;
_.addQuad = function addQuad(m00, m01, m10, m11, tx, ty, x1, y1, sx1, sy1, x2, y2, sx2, sy2, x3, y3, sx3, sy3, x4, y4, sx4, sy4){
  var offset, vertData, vertIdx;
  this.stableAttrs[0] = m00;
  this.stableAttrs[1] = m01;
  this.stableAttrs[2] = m10;
  this.stableAttrs[3] = m11;
  this.stableAttrs[4] = tx;
  this.stableAttrs[5] = ty;
  $addExtraStableAttrs(this, this.stableAttrs, 6);
  vertIdx = $beginPrimitive(this);
  offset = this.vertices.stagingPos;
  vertData = this.vertices.staging;
  offset = addVert(vertData, offset, this.stableAttrs, x1, y1, sx1, sy1);
  offset = addVert(vertData, offset, this.stableAttrs, x2, y2, sx2, sy2);
  offset = addVert(vertData, offset, this.stableAttrs, x3, y3, sx3, sy3);
  offset = addVert(vertData, offset, this.stableAttrs, x4, y4, sx4, sy4);
  $skip(this.vertices, offset - this.vertices.stagingPos);
  $addElems(this, vertIdx, ($clinit_IndexedTrisShader() , QUAD_INDICES));
}
;
_.deactivate = function deactivate_0(){
  $unbind(this.aMatrix);
  $unbind(this.aTranslation);
  $unbind(this.aColor);
  $unbind(this.aPosition);
  !!this.aTexCoord && $unbind(this.aTexCoord);
}
;
_.destroy = function destroy_18(){
  $destroy_3(this.prog);
  $destroy_2(this.vertices);
  $destroy_2(this.elements);
}
;
_.flush = function flush_2(){
  var elems;
  if (this.vertices.stagingPos == 0)
    return;
  $checkGLError(this.this$0.ctx, 'Shader.flush');
  if (this.this$0.delayedBinding) {
    $bindAttribsBufs(this);
    $checkGLError(this.this$0.ctx, 'Shader.flush bind');
  }
  $send(this.vertices, 34962, 35040);
  elems = $send(this.elements, 34963, 35040);
  $checkGLError(this.this$0.ctx, 'Shader.flush BufferData');
  $drawElements_0(this.elements, elems);
  $checkGLError(this.this$0.ctx, 'Shader.flush DrawElements');
}
;
_.prepare = function prepare(tint, justActivated){
  this.arTint = ~~tint >> 16 & 65535;
  this.gbTint = tint & 65535;
}
;
_.toString$ = function toString_43(){
  return 'cq=' + ~~(this.elements.staging.length / 6);
}
;
_.aColor = null;
_.aMatrix = null;
_.aPosition = null;
_.aTexCoord = null;
_.aTranslation = null;
_.arTint = 0;
_.elements = null;
_.gbTint = 0;
_.stableAttrs = null;
_.this$0 = null;
_.uScreenSize = null;
_.vertices = null;
function QuadShader_0(ctx){
  var maxVecs;
  this.ctx = ctx;
  maxVecs = ctx.gl.gl.getParameter(36347) - 3;
  if (maxVecs < 3)
    throw new RuntimeException_0('GL_MAX_VERTEX_UNIFORM_VECTORS too low: have ' + maxVecs + ', need at least 3');
  this.maxQuads = ~~(maxVecs / 3);
}

defineSeed(579, 565, {}, QuadShader_0);
_.createTextureCore = function createTextureCore_0(){
  return new QuadShader$QuadCore_0(this, $replace_1($replace_1('uniform vec2 u_ScreenSize;\nuniform vec4 u_Data[_VEC4S_PER_QUAD_*_MAX_QUADS_];\nattribute vec3 a_Vertex;\nvarying vec2 v_TexCoord;\nvarying vec4 v_Color;\nvoid main(void) {\nint index = _VEC4S_PER_QUAD_*int(a_Vertex.z);\nvec4 mat = u_Data[index+0];\nvec4 txc = u_Data[index+1];\nvec4 tcs = u_Data[index+2];\nmat3 transform = mat3(\n  mat.x, mat.y, 0,\n  mat.z, mat.w, 0,\n  txc.x, txc.y, 1);\ngl_Position = vec4(transform * vec3(a_Vertex.xy, 1.0), 1.0);\ngl_Position.xy /= u_ScreenSize.xy;\ngl_Position.x -= 1.0;\ngl_Position.y = 1.0 - gl_Position.y;\nv_TexCoord = a_Vertex.xy * tcs.xy + txc.zw;\nfloat red = mod(tcs.z, 256.0);\nfloat alpha = (tcs.z - red) / 256.0;\nfloat blue = mod(tcs.w, 256.0);\nfloat green = (tcs.w - blue) / 256.0;\nv_Color = vec4(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);\n}', '_MAX_QUADS_', '' + this.maxQuads), '_VEC4S_PER_QUAD_', '3'), $textureFragmentShader());
}
;
_.toString$ = function toString_44(){
  return 'quad/' + this.maxQuads;
}
;
_.maxQuads = 0;
function $addExtraData(this$static, quadData, pos){
  quadData[pos++] = this$static.arTint;
  quadData[pos++] = this$static.gbTint;
  return pos;
}

function $destroy_4(this$static){
  $destroy_3(this$static.prog);
  $destroy_2(this$static.vertices);
  $destroy_2(this$static.elements);
  $destroy_2(this$static.data);
}

function QuadShader$QuadCore_0(this$0, vertShader, fragShader){
  var base, ii;
  this.this$0 = this$0;
  GLShader$Core_0.call(this, this$0, vertShader, fragShader);
  this.uScreenSize = $getUniform2f(this.prog);
  this.uData = $getUniform4fv(this.prog);
  this.aVertex = $getAttrib(this.prog, 'a_Vertex', 3, 5122);
  this.vertices = $createShortBuffer(this$0.ctx, this$0.maxQuads * 4 * 3);
  this.elements = $createShortBuffer(this$0.ctx, this$0.maxQuads * 6);
  for (ii = 0; ii < this$0.maxQuads; ++ii) {
    $add_16($add_17(this.vertices, 0, 0), ii);
    $add_16($add_17(this.vertices, 1, 0), ii);
    $add_16($add_17(this.vertices, 0, 1), ii);
    $add_16($add_17(this.vertices, 1, 1), ii);
    base = ii * 4;
    $add_16($add_16($add_16(this.elements, base), base + 1), base + 2);
    $add_16($add_16($add_16(this.elements, base + 1), base + 3), base + 2);
  }
  this.data = $createFloatBuffer(this$0.ctx, this$0.maxQuads * 3 * 4);
  $bind(this.vertices, 34962);
  $send(this.vertices, 34962, 35044);
  $bind(this.elements, 34963);
  $send(this.elements, 34963, 35044);
}

defineSeed(580, 566, {}, QuadShader$QuadCore_0);
_.activate = function activate_0(fbufWidth, fbufHeight){
  $bind_0(this.prog);
  $bind_2(this.uScreenSize, fbufWidth / 2, fbufHeight / 2);
  $bind(this.vertices, 34962);
  $bind_1(this.aVertex, 0, 0);
  $bind(this.elements, 34963);
}
;
_.addQuad = function addQuad_0(m00, m01, m10, m11, tx, ty, x1, y1, sx1, sy1, x2, y2, sx2, sy2, x3, y3, sx3, sy3, x4, y4, sx4, sy4){
  var dh, dw, opos, pos, quadData;
  dw = x2 - x1;
  dh = y3 - y1;
  quadData = this.data.staging;
  opos = this.data.stagingPos;
  pos = opos;
  quadData[pos++] = m00 * dw;
  quadData[pos++] = m01 * dw;
  quadData[pos++] = m10 * dh;
  quadData[pos++] = m11 * dh;
  quadData[pos++] = tx + m00 * x1 + m10 * y1;
  quadData[pos++] = ty + m01 * x1 + m11 * y1;
  quadData[pos++] = sx1;
  quadData[pos++] = sy1;
  quadData[pos++] = sx2 - sx1;
  quadData[pos++] = sy3 - sy1;
  pos = $addExtraData(this, quadData, pos);
  $skip(this.data, pos - opos);
  ++this.quadCounter;
  this.quadCounter >= this.this$0.maxQuads && $flush_1(this.this$0);
}
;
_.deactivate = function deactivate_1(){
  $unbind(this.aVertex);
}
;
_.destroy = function destroy_19(){
  $destroy_4(this);
}
;
_.flush = function flush_3(){
  if (this.quadCounter == 0)
    return;
  $bind_4(this.uData, this.data, this.quadCounter * 3);
  $drawElements_0(this.elements, 6 * this.quadCounter);
  this.quadCounter = 0;
}
;
_.prepare = function prepare_0(tint, justActivated){
  this.arTint = ~~tint >> 16 & 65535;
  this.gbTint = tint & 65535;
}
;
_.aVertex = null;
_.arTint = 0;
_.data = null;
_.elements = null;
_.gbTint = 0;
_.quadCounter = 0;
_.this$0 = null;
_.uData = null;
_.uScreenSize = null;
_.vertices = null;
function $clinit_Scale(){
  $clinit_Scale = nullMethod;
  ONE_0 = new Scale_0(1);
}

function $invScaled(this$static, length_0){
  return length_0 / this$static.factor;
}

function $scaledCeil(this$static, length_0){
  return iceil(this$static.factor * length_0);
}

function Scale_0(factor){
  $clinit_Scale();
  this.factor = factor;
}

defineSeed(581, 1, {}, Scale_0);
_.toString$ = function toString_45(){
  return 'x' + this.factor;
}
;
_.factor = 0;
var ONE_0;
function SurfaceGL_0(ctx, width, height){
  AbstractSurfaceGL_0.call(this, ctx);
  this.width_0 = width;
  this.height_0 = height;
  this.texWidth = $scaledCeil(ctx.scale_0, width);
  this.texHeight = $scaledCeil(ctx.scale_0, height);
  this.tex = $createTexture(this.ctx, this.texWidth, this.texHeight, false, false, false);
  this.fbuf = $createFramebuffer(this.ctx, this.tex);
  $clear_4(this.ctx);
  $scale_1(this, ctx.scale_0.factor, ctx.scale_0.factor);
}

defineSeed(582, 553, {}, SurfaceGL_0);
_.bindFramebuffer_0 = function bindFramebuffer_0(){
  $bindFramebuffer_0(this.ctx, this.fbuf, this.texWidth, this.texHeight);
}
;
_.fbuf = 0;
_.height_0 = 0;
_.tex = 0;
_.texHeight = 0;
_.texWidth = 0;
_.width_0 = 0;
function $draw_4(){
  throw new UnsupportedOperationException_1('SurfaceImage cannot currently be drawn into a Canvas.');
}

function SurfaceImageGL_0(ctx, surface){
  this.ctx = ctx;
  this.surface = surface;
}

defineSeed(583, 551, {}, SurfaceImageGL_0);
_.clearTexture = function clearTexture_0(){
}
;
_.draw = function draw(gc, dx, dy, dw, dh){
  $draw_4((this.surface.width_0 , this.surface.height_0));
}
;
_.draw_0 = function draw_0(gc, sx, sy, sw, sh, dx, dy, dw, dh){
  $draw_4();
}
;
_.drawImpl = function drawImpl_0(shader, xform, tex, tint, dx, dy, dw, dh, sl, st, sr, sb){
  tex > 0 && $addQuad($prepareTexture($quadShader(this.ctx, shader), tex, tint), xform, dx, dy, dx + dw, dy + dh, sl, 1 - st, sr, 1 - sb);
}
;
_.ensureTexture = function ensureTexture_0(){
  return this.surface.tex;
}
;
_.height_1 = function height_4(){
  return this.surface.height_0;
}
;
_.isReady = function isReady(){
  return true;
}
;
_.surface_0 = function surface_0(){
  return this.surface;
}
;
_.width_1 = function width_4(){
  return this.surface.width_0;
}
;
_.surface = null;
function getElementSize_2(){
  throw new RuntimeException_0('Unrecognized buffer type: ' + null.nullMethod());
}

function createAdd(list, callback){
  !list && (list = new ArrayList_0);
  list.add(callback);
  return list;
}

function dispatchFailureClear(list, cause){
  var ii, ll;
  if (list) {
    for (ii = 0 , ll = list.size_0(); ii < ll; ++ii)
      list.get(ii).onFailure(cause);
  }
  return null;
}

function dispatchSuccessClear(list, result){
  var ii, ll;
  if (list) {
    for (ii = 0 , ll = list.size_0(); ii < ll; ++ii)
      list.get(ii).onSuccess(result);
  }
  return null;
}

function RunQueue_0(){
}

defineSeed(586, 1, {}, RunQueue_0);
_.head = null;
function $addRoundRectPath(this$static, x, y, width, height){
  var maxx, maxy, midx, midy;
  midx = x + width / 2;
  midy = y + height / 2;
  maxx = x + width;
  maxy = y + height;
  this$static.ctx.beginPath();
  $moveTo(this$static.ctx, x, midy);
  $arcTo(this$static.ctx, x, y, midx, y, 10);
  $arcTo(this$static.ctx, maxx, y, maxx, midy, 10);
  $arcTo(this$static.ctx, maxx, maxy, midx, maxy, 10);
  $arcTo(this$static.ctx, x, maxy, x, midy, 10);
  this$static.ctx.closePath();
}

function $clear_5(this$static){
  return $clearRect_0(this$static, this$static.width_1(), this$static.height_1());
}

function $clearRect_0(this$static, width, height){
  $clearRect(this$static.ctx, 0, 0, width, height);
  this$static.isDirty = true;
  return this$static;
}

function $convertLineCap(){
  switch (1) {
    case 0:
    case 1:
      return $clinit_Context2d$LineCap() , ROUND;
  }
}

function $convertLineJoin(){
  switch (2) {
    case 0:
    case 1:
    case 2:
      return $clinit_Context2d$LineJoin() , ROUND_0;
  }
}

function $fillRect_0(this$static, x, y, w, h_0){
  $fillRect(this$static.ctx, x, y, w, h_0);
  this$static.isDirty = true;
  return this$static;
}

function $fillRoundRect(this$static, x, y, w, h_0){
  $addRoundRectPath(this$static, x, y, w, h_0);
  this$static.ctx.fill();
  this$static.isDirty = true;
  return this$static;
}

function $fillText_0(this$static, layout, x, y){
  $fill(layout, this$static.ctx, x, y);
  this$static.isDirty = true;
  return this$static;
}

function $scale_2(this$static, x, y){
  $scale(this$static.ctx, x, y);
  return this$static;
}

function $setAlpha(this$static, alpha){
  $setGlobalAlpha(this$static.ctx, alpha);
  return this$static;
}

function $setFillColor(this$static, color){
  $setFillStyleWeb(this$static.ctx, cssColorString(color));
  return this$static;
}

function $setStrokeColor(this$static, color){
  $setStrokeStyleWeb(this$static.ctx, cssColorString(color));
  return this$static;
}

function $strokeText_0(this$static, layout){
  $stroke(layout, this$static.ctx);
  this$static.isDirty = true;
  return this$static;
}

function AbstractHtmlCanvas_0(ctx, width, height){
  this.width_0 = width;
  this.height_0 = height;
  this.ctx = ctx;
}

defineSeed(587, 550, {});
_.clear_1 = function clear_7(){
  return $clear_5(this);
}
;
_.fillRect_0 = function fillRect(x, y, w, h_0){
  return $fillRect_0(this, x, y, w, h_0);
}
;
_.gc = function gc_0(){
  return this.ctx;
}
;
_.restore_0 = function restore_0(){
  this.ctx.restore();
  return this;
}
;
_.save_0 = function save(){
  this.ctx.save();
  return this;
}
;
_.scale_1 = function scale_2(x, y){
  return $scale(this.ctx, x, y) , this;
}
;
_.setAlpha_0 = function setAlpha_0(alpha){
  return $setAlpha(this, alpha);
}
;
_.setFillPattern = function setFillPattern(pattern){
  $setFillStyleWeb(this.ctx, $pattern(pattern, this.ctx));
  return this;
}
;
_.transform_2 = function transform_1(m11, m12, m21, m22, dx, dy){
  $transform(this.ctx, m11, m12, m21, m22, dx, dy);
  return this;
}
;
_.translate_0 = function translate(x, y){
  $translate(this.ctx, x, y);
  return this;
}
;
_.ctx = null;
function $init_3(this$static){
  this$static.random_0 = getRandom();
  $logImpl(($clinit_HtmlPlatform() , 0), 'Analytics random = ' + this$static.random_0, null);
}

function HtmlAnalytics_0(){
}

defineSeed(588, 1, {}, HtmlAnalytics_0);
_.random_0 = 0;
function $getBundle(this$static, collection){
  var clientBundle, entry, entry$iterator, regExp;
  clientBundle = null;
  for (entry$iterator = new AbstractHashMap$EntrySetIterator_0((new AbstractHashMap$EntrySet_0(this$static.clientBundles)).this$0); $hasNext(entry$iterator.iter);) {
    entry = entry$iterator.last = $next_2(entry$iterator.iter);
    regExp = entry.getKey();
    !!$exec(new RegExp(regExp), collection) && (clientBundle = entry.getValue());
  }
  return clientBundle;
}

--></script>
<script><!--
function $getImage(this$static, path, scale){
  var url, img;
  url = this$static.pathPrefix + path;
  $getBundle(this$static, path);
  return img = $doc.createElement('img') , 'crossOrigin' in img && img.setAttribute('crossOrigin', 'anonymous') , img.src = url , new HtmlImage_1(this$static.platform.graphics.ctx_0(), scale, img);
}

function $getSound(this$static, path){
  var url, audio, sound;
  url = this$static.pathPrefix + path;
  $getBundle(this$static, path);
  url += '.mp3';
  return audio = platform_1.audio , sound = $createSound(audio.soundController, url) , new HtmlSound_0(sound);
}

function $getText(this$static, callback){
  var $e0, e, fullPath, xhr, xdr;
  fullPath = this$static.pathPrefix + 'texts/game.properties';
  try {
    xhr = create_8();
    $setOnReadyStateChange(xhr, new HtmlAssets$2_0(fullPath, callback));
    xhr.open('GET', fullPath, true);
    xhr.send(null);
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$JavaScriptException)) {
      e = $e0;
      if ($wnd.navigator.userAgent.indexOf('MSIE') != -1) {
        xdr = new $wnd.XDomainRequest;
        $setHandler(xdr, new HtmlAssets$1_0(fullPath, callback));
        xdr.open('GET', fullPath, true);
        xdr.send();
      }
       else {
        throw e;
      }
    }
     else 
      throw $e0;
  }
}

function HtmlAssets_0(platform){
  this.clientBundles = new HashMap_0;
  this.platform = platform;
}

defineSeed(589, 489, {}, HtmlAssets_0);
_.pathPrefix = '';
_.platform = null;
function HtmlAssets$1_0(val$fullPath, val$callback){
  this.val$fullPath = val$fullPath;
  this.val$callback = val$callback;
}

defineSeed(590, 1, {}, HtmlAssets$1_0);
_.onError = function onError(xdr){
  $logImpl((platform_1.log_0 , 3), 'xdr::onError[' + this.val$fullPath + ']()', null);
  $onFailure(new RuntimeException_0('Error getting ' + this.val$fullPath + ' : ' + xdr.contentType));
}
;
_.onLoad = function onLoad(xdr){
  $onSuccess_0(this.val$callback, xdr.responseText);
}
;
_.onProgress = function onProgress(xdr){
}
;
_.onTimeout = function onTimeout(xdr){
  $logImpl((platform_1.log_0 , 3), 'xdr::onTimeout[' + this.val$fullPath + ']()', null);
  $onFailure(new RuntimeException_0('Error getting ' + this.val$fullPath + ' : ' + xdr.contentType));
}
;
_.val$callback = null;
_.val$fullPath = null;
function HtmlAssets$2_0(val$fullPath, val$callback){
  this.val$fullPath = val$fullPath;
  this.val$callback = val$callback;
}

defineSeed(591, 1, {}, HtmlAssets$2_0);
_.onReadyStateChange = function onReadyStateChange(xhr){
  var $e0, e, readyState, status_0, status_1;
  readyState = xhr.readyState;
  if (readyState == 4) {
    status_0 = xhr.status;
    if (status_0 != 0 && (status_0 < 200 || status_0 >= 400)) {
      $logImpl((platform_1.log_0 , 3), 'xhr::onReadyStateChange[' + this.val$fullPath + '](readyState = 4; status = ' + status_0 + ')', null);
      $onFailure(new RuntimeException_0('Error getting ' + this.val$fullPath + ' : ' + xhr.statusText));
    }
     else {
      try {
        $onSuccess_0(this.val$callback, xhr.responseText);
      }
       catch ($e0) {
        $e0 = caught_0($e0);
        if (instanceOf($e0, Q$JavaScriptException)) {
          e = $e0;
          throw e;
        }
         else 
          throw $e0;
      }
    }
  }
}
;
_.val$callback = null;
_.val$fullPath = null;
function $init_4(this$static){
  $logImpl(($clinit_HtmlPlatform() , 0), 'Preferred sound type(s): ' + this$static.soundController.preferredSoundTypes, null);
  maybeCreateAudioContext();
}

function HtmlAudio_0(){
  this.soundController = new SoundController_0;
}

function maybeCreateAudioContext(){
  try {
    return new AudioContext;
  }
   catch (ignore) {
  }
  try {
    return new webkitAudioContext;
  }
   catch (ignore) {
  }
  return null;
}

defineSeed(592, 1, {}, HtmlAudio_0);
function HtmlCanvas_0(width, height){
  HtmlCanvas_2.call(this, $doc.createElement('canvas'), width, height);
}

function HtmlCanvas_1(ctx, canvas, width, height){
  AbstractHtmlCanvas_0.call(this, ctx, width, height);
  this.canvas = canvas;
}

function HtmlCanvas_2(canvas, width, height){
  HtmlCanvas_1.call(this, canvas.getContext('2d'), canvas, width, height);
  $setWidth(canvas, iceil(width));
  $setHeight(canvas, iceil(height));
}

function create_9(scale, width, height){
  var canvas, sh, sw;
  sw = iceil(scale.factor * width);
  sh = iceil(scale.factor * height);
  canvas = new HtmlCanvas_0(sw, sh);
  $scale_2(canvas, scale.factor, scale.factor);
  return canvas;
}

defineSeed(593, 587, {}, HtmlCanvas_0);
_.canvas = null;
function $addCallback_0(this$static, callback){
  if (this$static.img.complete) {
    callback.onSuccess(this$static);
  }
   else {
    addEventListener_0(this$static.img, 'load', new HtmlImage$1_0(this$static, callback), false);
    addEventListener_0(this$static.img, 'error', new HtmlImage$2_0(this$static, callback), false);
  }
}

function $draw_5(this$static, ctx, dx, dy, dw, dh, sx, sy, sw, sh){
  sx *= this$static.scale_0.factor;
  sy *= this$static.scale_0.factor;
  sw *= this$static.scale_0.factor;
  sh *= this$static.scale_0.factor;
  $drawImage_0(ctx, this$static.img, sx, sy, sw, sh, dx, dy, dw, dh);
}

function HtmlImage_0(ctx, scale, img){
  ImageGL_0.call(this, ctx, scale);
  img.complete = true;
  this.img = img;
}

function HtmlImage_1(ctx, scale, img){
  ImageGL_0.call(this, ctx, scale);
  this.img = img;
}

defineSeed(595, 572, {}, HtmlImage_1);
_.clearTexture = function clearTexture_1(){
  !!this.ctx && $clearTexture(this);
}
;
_.draw = function draw_1(ctx, x, y, width, height){
  $drawImage(ctx, this.img, x, y, width, height);
}
;
_.draw_0 = function draw_2(ctx, dx, dy, dw, dh, sx, sy, sw, sh){
  $draw_5(this, ctx, dx, dy, dw, dh, sx, sy, sw, sh);
}
;
_.height_1 = function height_5(){
  return !this.img?0:$invScaled(this.scale_0, this.img.height);
}
;
_.isReady = function isReady_0(){
  return this.img.complete;
}
;
_.toPattern = function toPattern_0(){
  this.img.complete;
  return new HtmlPattern_1(this, this.repeatX, this.repeatY);
}
;
_.updateTexture = function updateTexture(tex){
  $updateTexture(this.ctx, tex, this.img);
}
;
_.width_1 = function width_5(){
  return !this.img?0:$invScaled(this.scale_0, this.img.width);
}
;
_.img = null;
function HtmlCanvasImage_0(ctx, scale, canvas){
  HtmlImage_0.call(this, ctx, scale, canvas.canvas);
  this.canvas = canvas;
}

defineSeed(594, 595, {}, HtmlCanvasImage_0);
_.ensureTexture = function ensureTexture_1(){
  if (this.canvas.isDirty) {
    this.canvas.isDirty = false;
    !!this.ctx && $clearTexture(this);
  }
  return this.tex != 0?this.tex:this.img.complete?this.repeatX || this.repeatY || this.mipmapped?(this.tex = $scaleTexture(this)):(this.tex = $createMainTex(this)):0;
}
;
_.canvas = null;
function $clinit_HtmlFont(){
  $clinit_HtmlFont = nullMethod;
  DEFAULT = new HtmlFont_0('sans-serif', ($clinit_Font$Style() , PLAIN), 12);
}

function HtmlFont_0(name_0, style, size){
  $clinit_HtmlFont();
  AbstractFont_0.call(this, name_0.indexOf('"') != 0 && name_0.indexOf(' ') != -1?'"' + name_0 + '"':name_0, style, size);
}

defineSeed(596, 491, makeCastMap([Q$AbstractFont]), HtmlFont_0);
var DEFAULT;
function HtmlFontMetrics_0(height, emwidth){
  this.height_0 = height;
  this.emwidth = emwidth;
}

defineSeed(597, 1, {}, HtmlFontMetrics_0);
_.emwidth = 0;
_.height_0 = 0;
function $createObject(this$static, object, type){
  $push(this$static.webGLObjects, object);
  $push_0(this$static.webGLObjectTypes, type.ordinal);
  return this$static.webGLObjects.length - 1;
}

function $deleteObject(this$static, index, type){
  var object;
  object = this$static.webGLObjects[index];
  this$static.webGLObjects[index] = null;
  this$static.webGLObjectTypes[index] = ($clinit_HtmlGL20$WebGLObjectType() , NULL_0).ordinal;
  switch (type.ordinal) {
    case 1:
      $deleteBuffer(this$static.gl, object);
      break;
    case 2:
      $deleteFramebuffer(this$static.gl, object);
      break;
    case 3:
      $deleteProgram(this$static.gl, object);
      break;
    case 4:
      $deleteRenderbuffer(this$static.gl, object);
      break;
    case 5:
      $deleteShader(this$static.gl, object);
      break;
    case 6:
      $deleteTexture(this$static.gl, object);
  }
}

function $deleteObjects(this$static, indices, type){
  var i;
  for (i = 0; i < 1; ++i) {
    $deleteObject(this$static, indices[i], type);
  }
}

function $genObject(this$static, type){
  switch (type.ordinal) {
    case 1:
      return this$static.gl.createBuffer();
    case 2:
      return this$static.gl.createFramebuffer();
    case 3:
      return this$static.gl.createProgram();
    case 4:
      return this$static.gl.createRenderbuffer();
    case 6:
      return this$static.gl.createTexture();
    default:throw new RuntimeException_0('genObject(s) not supported for type ' + type);
  }
}

function $genObjects(this$static, names, type){
  var i, object;
  for (i = 0; i < 1; ++i) {
    object = $genObject(this$static, type);
    names[i] = $createObject(this$static, object, type);
  }
}

function $getTypedArray(buffer, type, byteSize){
  var arrayHolder, bufferElementSize, byteOffset, webGLArray;
  if (!instanceOf(buffer, Q$HasArrayBufferView)) {
    throw new RuntimeException_0('Native buffer required ' + buffer);
  }
  arrayHolder = buffer;
  bufferElementSize = arrayHolder.getElementSize();
  webGLArray = arrayHolder.getTypedArray();
  byteSize == -1 && (byteSize = (buffer.limit - buffer.position_0) * bufferElementSize);
  if (byteSize == buffer.capacity * bufferElementSize && type == arrayHolder.getElementType()) {
    return webGLArray;
  }
  byteOffset = webGLArray.byteOffset + buffer.position_0 * bufferElementSize;
  switch (type) {
    case 5126:
      return create_2(webGLArray.buffer, byteOffset, ~~(byteSize / 4));
    case 5121:
      return create_7(webGLArray.buffer, byteOffset, byteSize);
    case 5123:
      return create_6(webGLArray.buffer, byteOffset, ~~(byteSize / 2));
    case 5124:
      return create_4(webGLArray.buffer, byteOffset, ~~(byteSize / 4));
    case 5122:
      return create_3(webGLArray.buffer, byteOffset, ~~(byteSize / 2));
    case 5120:
      return create_5(webGLArray.buffer, byteOffset, byteSize);
    default:throw new IllegalArgumentException_1('Type: ' + type);
  }
}

function $glBindBuffer(this$static, target, buffer){
  var webGlBuf;
  webGlBuf = this$static.webGLObjects[buffer];
  target == 34962?(this$static.requestedArrayBuffer = webGlBuf):target == 34963?(this$static.requestedElementArrayBuffer = webGlBuf):$bindBuffer(this$static.gl, target, webGlBuf);
}

function $glBindFramebuffer(this$static, framebuffer){
  $bindFramebuffer(this$static.gl, 36160, this$static.webGLObjects[framebuffer]);
}

function $glBindTexture(this$static, textureId){
  $bindTexture(this$static.gl, 3553, this$static.webGLObjects[textureId]);
}

function $glBufferData(this$static, target, byteSize, data, usage){
  if (target == 34962) {
    if (this$static.requestedArrayBuffer != this$static.boundArrayBuffer) {
      $bindBuffer(this$static.gl, 34962, this$static.requestedArrayBuffer);
      this$static.boundArrayBuffer = this$static.requestedArrayBuffer;
    }
  }
   else if (target == 34963) {
    if (this$static.requestedElementArrayBuffer != this$static.boundElementArrayBuffer) {
      $bindBuffer(this$static.gl, 34963, this$static.requestedElementArrayBuffer);
      this$static.boundElementArrayBuffer = this$static.requestedElementArrayBuffer;
    }
  }
  $bufferData(this$static.gl, target, $getTypedArray(data, 5120, byteSize), usage);
}

function $glClear(this$static, mask){
  $clear_0(this$static.gl, mask);
}

function $glClearColor(this$static, f, g, h_0, i){
  $clearColor(this$static.gl, f, g, h_0, i);
}

function $glCompileShader(this$static, shader){
  $compileShader(this$static.gl, this$static.webGLObjects[shader]);
}

function $glCreateShader(this$static, type){
  return $createObject(this$static, $createShader(this$static.gl, type), ($clinit_HtmlGL20$WebGLObjectType() , SHADER));
}

function $glDisableVertexAttribArray(this$static, index){
  this$static.enabledArrays &= ~(1 << index);
}

function $glDrawElements(this$static, count){
  $prepareDraw(this$static);
  if (this$static.requestedElementArrayBuffer != this$static.boundElementArrayBuffer) {
    $bindBuffer(this$static.gl, 34963, this$static.requestedElementArrayBuffer);
    this$static.boundElementArrayBuffer = this$static.requestedElementArrayBuffer;
  }
  $drawElements(this$static.gl, 4, count, 5123, 0);
}

function $glEnableVertexAttribArray(this$static, index){
  this$static.enabledArrays |= 1 << index;
}

function $glFramebufferTexture2D(this$static, texture){
  $framebufferTexture2D(this$static.gl, 36160, 36064, 3553, this$static.webGLObjects[texture], 0);
}

function $glGetAttribLocation(this$static, program, name_0){
  return $getAttribLocation(this$static.gl, this$static.webGLObjects[program], name_0);
}

function $glGetShaderInfoLog(this$static, shader){
  return $getShaderInfoLog(this$static.gl, this$static.webGLObjects[shader]);
}

function $glGetShaderiv(this$static, shader, params){
  params[0] = $getShaderParameterb(this$static.gl, this$static.webGLObjects[shader], 35713)?1:0;
}

function $glGetUniformLocation(this$static, program, name_0){
  return $createObject(this$static, $getUniformLocation(this$static.gl, this$static.webGLObjects[program], name_0), ($clinit_HtmlGL20$WebGLObjectType() , UNIFORM_LOCATION));
}

function $glShaderSource(this$static, shader, string){
  $shaderSource(this$static.gl, this$static.webGLObjects[shader], string);
}

function $glTexImage2D(this$static, width, height){
  $texImage2D(this$static.gl, 3553, 0, 6408, width, height, 0, 6408, 5121, null);
}

function $glTexParameteri(this$static, glTextureMinFilter, glFilterMin){
  $texParameteri(this$static.gl, 3553, glTextureMinFilter, glFilterMin);
}

function $glUniform1i(this$static, location_0){
  $uniform1i(this$static.gl, this$static.webGLObjects[location_0], 0);
}

function $glUniform2f(this$static, location_0, x, y){
  $uniform2f(this$static.gl, this$static.webGLObjects[location_0], x, y);
}

function $glUniform4fv(this$static, location_0, count, v){
  $uniform4fv(this$static.gl, this$static.webGLObjects[location_0], $getTypedArray(v, 5126, 16 * count));
}

function $glUseProgram(this$static, program){
  $useProgram(this$static.gl, this$static.webGLObjects[program]);
}

function $glVertexAttribPointer(this$static, indx, size, type, stride, ptr){
  this$static.useNioBuffer &= ~(1 << indx);
  if (this$static.boundArrayBuffer != this$static.requestedArrayBuffer) {
    $bindBuffer(this$static.gl, 34962, this$static.requestedArrayBuffer);
    this$static.boundArrayBuffer = this$static.requestedArrayBuffer;
  }
  $vertexAttribPointer(this$static.gl, indx, size, type, false, stride, ptr);
}

function $glViewport(this$static, w, h_0){
  $viewport(this$static.gl, 0, 0, w, h_0);
}

function $prepareDraw(this$static){
  var data, elementSize, enabled, i, mask, previousElementSize, previousNio;
  previousNio = null;
  previousElementSize = 0;
  if (this$static.useNioBuffer == 0 && this$static.enabledArrays == this$static.previouslyEnabledArrays) {
    return;
  }
  for (i = 0; i < 5; ++i) {
    mask = 1 << i;
    enabled = this$static.enabledArrays & mask;
    enabled != (this$static.previouslyEnabledArrays & mask) && (enabled != 0?$enableVertexAttribArray(this$static.gl, i):$disableVertexAttribArray(this$static.gl, i));
    if (enabled != 0 && (this$static.useNioBuffer & mask) != 0) {
      data = this$static.vertexAttribArrayState[i];
      if (!!previousNio && previousNio.nioBufferLimit >= data.nioBufferLimit) {
        if (this$static.boundArrayBuffer != previousNio.webGlBuffer) {
          $bindBuffer(this$static.gl, 34962, previousNio.webGlBuffer);
          this$static.boundArrayBuffer = data.webGlBuffer;
        }
        $vertexAttribPointer(this$static.gl, i, data.size, data.type_0, data.normalize, data.stride, data.nioBufferPosition * previousElementSize);
      }
       else {
        if (this$static.boundArrayBuffer != data.webGlBuffer) {
          $bindBuffer(this$static.gl, 34962, data.webGlBuffer);
          this$static.boundArrayBuffer = data.webGlBuffer;
        }
        elementSize = getElementSize_2();
        null.nullMethod();
        if (data.nioBufferPosition * elementSize < data.stride) {
          null.nullMethod();
          $bufferData(this$static.gl, 34962, $getTypedArray(data.nioBuffer, data.type_0, data.nioBufferLimit * elementSize), 35040);
          $vertexAttribPointer(this$static.gl, i, data.size, data.type_0, data.normalize, data.stride, data.nioBufferPosition * elementSize);
          previousNio = data;
          previousElementSize = elementSize;
        }
         else {
          null.nullMethod();
          $bufferData(this$static.gl, 34962, $getTypedArray(data.nioBuffer, data.type_0, (data.nioBufferLimit - data.nioBufferPosition) * elementSize), 35040);
          $vertexAttribPointer(this$static.gl, i, data.size, data.type_0, data.normalize, data.stride, 0);
        }
        null.nullMethod();
      }
    }
  }
  this$static.previouslyEnabledArrays = this$static.enabledArrays;
}

function HtmlGL20_0(gl){
  var data, i;
  this.vertexAttribArrayState = initDim(_3Lplayn_html_HtmlGL20$VertexAttribArrayState_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$HtmlGL20$VertexAttribArrayState, 5, 0);
  this.webGLObjects = [];
  this.webGLObjectTypes = [];
  this.gl = gl;
  $push(this.webGLObjects, null);
  $push_0(this.webGLObjectTypes, ($clinit_HtmlGL20$WebGLObjectType() , NULL_0).ordinal);
  gl.createBuffer();
  for (i = 0; i < 5; ++i) {
    data = new HtmlGL20$VertexAttribArrayState_0;
    data.webGlBuffer = gl.createBuffer();
    this.vertexAttribArrayState[i] = data;
  }
}

defineSeed(598, 1, {}, HtmlGL20_0);
_.boundArrayBuffer = null;
_.boundElementArrayBuffer = null;
_.enabledArrays = 0;
_.gl = null;
_.previouslyEnabledArrays = 0;
_.requestedArrayBuffer = null;
_.requestedElementArrayBuffer = null;
_.useNioBuffer = 0;
function HtmlGL20$VertexAttribArrayState_0(){
}

defineSeed(599, 1, makeCastMap([Q$HtmlGL20$VertexAttribArrayState]), HtmlGL20$VertexAttribArrayState_0);
_.nioBuffer = null;
_.nioBufferLimit = 0;
_.nioBufferPosition = 0;
_.normalize = false;
_.size = 0;
_.stride = 0;
_.type_0 = 0;
_.webGlBuffer = null;
function $clinit_HtmlGL20$WebGLObjectType(){
  $clinit_HtmlGL20$WebGLObjectType = nullMethod;
  NULL_0 = new HtmlGL20$WebGLObjectType_0('NULL', 0);
  BUFFER = new HtmlGL20$WebGLObjectType_0('BUFFER', 1);
  FRAME_BUFFER = new HtmlGL20$WebGLObjectType_0('FRAME_BUFFER', 2);
  PROGRAM = new HtmlGL20$WebGLObjectType_0('PROGRAM', 3);
  RENDER_BUFFER = new HtmlGL20$WebGLObjectType_0('RENDER_BUFFER', 4);
  SHADER = new HtmlGL20$WebGLObjectType_0('SHADER', 5);
  TEXTURE = new HtmlGL20$WebGLObjectType_0('TEXTURE', 6);
  UNIFORM_LOCATION = new HtmlGL20$WebGLObjectType_0('UNIFORM_LOCATION', 7);
  $VALUES_24 = initValues(_3Lplayn_html_HtmlGL20$WebGLObjectType_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$HtmlGL20$WebGLObjectType, [NULL_0, BUFFER, FRAME_BUFFER, PROGRAM, RENDER_BUFFER, SHADER, TEXTURE, UNIFORM_LOCATION]);
}

function HtmlGL20$WebGLObjectType_0(enum$name, enum$ordinal){
  Enum_0.call(this, enum$name, enum$ordinal);
}

function values_25(){
  $clinit_HtmlGL20$WebGLObjectType();
  return $VALUES_24;
}

defineSeed(600, 39, makeCastMap([Q$Serializable, Q$Comparable, Q$Enum, Q$HtmlGL20$WebGLObjectType]), HtmlGL20$WebGLObjectType_0);
var $VALUES_24, BUFFER, FRAME_BUFFER, NULL_0, PROGRAM, RENDER_BUFFER, SHADER, TEXTURE, UNIFORM_LOCATION;
function $tryBasicGLCalls(this$static){
  var err, pixelData, testFloat32Array, testInt32Array, testUint16Array, testUint8Array;
  testFloat32Array = createFloat32Array(toJsArray(initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [0, 1, 2])));
  if (testFloat32Array[0] != 0 || testFloat32Array[1] != 1 || testFloat32Array[2] != 2) {
    throw new RuntimeException_0('Typed Float32Array check failed');
  }
  testInt32Array = createInt32Array(toJsArray_0(initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [0, 1, 2])));
  if (testInt32Array[0] != 0 || testInt32Array[1] != 1 || testInt32Array[2] != 2) {
    throw new RuntimeException_0('Typed Int32Array check failed');
  }
  testUint16Array = createUint16Array(toJsArray_0(initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [0, 1, 2])));
  if (testUint16Array[0] != 0 || testUint16Array[1] != 1 || testUint16Array[2] != 2) {
    throw new RuntimeException_0('Typed Uint16Array check failed');
  }
  testUint8Array = createUint8Array(toJsArray_0(initValues(_3I_classLit, makeCastMap([Q$Serializable]), -1, [0, 1, 2])));
  if (testUint8Array[0] != 0 || testUint8Array[1] != 1 || testUint8Array[2] != 2) {
    throw new RuntimeException_0('Typed Uint8Array check failed');
  }
  $bindFramebuffer_0(this$static, 0, this$static.defaultFbufWidth, this$static.defaultFbufHeight);
  $glClearColor(this$static.gl, 1, 1, 1, 1);
  $glClear(this$static.gl, 16384);
  err = this$static.glc.getError();
  if (err != 0) {
    throw new RuntimeException_0('Read back GL test failed to clear color (error ' + err + ')');
  }
  pixelData = new Uint8Array(4);
  $readPixels(this$static.glc, 0, 0, 1, 1, 6408, 5121, pixelData);
  if (pixelData[0] != 255 || pixelData[1] != 255 || pixelData[2] != 255) {
    throw new RuntimeException_0('Read back GL test failed to read back correct color');
  }
}

function $updateTexture(this$static, tex, img){
  $glBindTexture(this$static.gl, tex);
  $texImage2D_0(this$static.glc, 3553, 0, 6408, 6408, 5121, img);
}

function HtmlGLContext_0(platform, gl, canvas){
  GL20Context_0.call(this, platform, new HtmlGL20_0(gl), ($clinit_HtmlUrlParameters() , checkGLErrors));
  this.glc = gl;
  $tryBasicGLCalls(this);
  $setSize(this, iceil(canvas.width), iceil(canvas.height));
  this.gl.gl.disable(2884);
  this.gl.gl.enable(3042);
  this.gl.gl.blendFunc(1, 771);
  $glClearColor(this.gl, 0, 0, 0, 1);
  !!this.quadShader && $clearProgram(this.quadShader);
  !!this.trisShader && $clearProgram(this.trisShader);
  this.quadShader = $createQuadShader(this);
  this.trisShader = new IndexedTrisShader_0(this);
  $checkGLError(this, 'initGL');
  this.glc.pixelStorei(37441, 1);
}

defineSeed(601, 557, {}, HtmlGLContext_0);
_.createTransform = function createTransform_0(){
  return new HtmlInternalTransform_0;
}
;
_.glc = null;
function HtmlGame$1_0(){
}

defineSeed(602, 1, {}, HtmlGame$1_0);
_.onUncaughtException = function onUncaughtException_0(e){
  $logImpl(3, 'Uncaught Exception: ', ($clinit_HtmlPlatform() , e));
}
;
function HtmlGame$2_0(){
}

defineSeed(603, 1, {}, HtmlGame$2_0);
_.execute = function execute_11(){
  var config, platform, platform_0;
  config = new HtmlPlatform$Config_0;
  platform = ($clinit_HtmlPlatform() , platform_0 = new HtmlPlatform_0(config) , platform_1 = platform_0 , $init_3(platform_0.analytics) , $init_4(platform_0.audio) , $init_5(platform_0.keyboard) , platform_0);
  platform.assets.pathPrefix = 'bomberman/';
  run_2(new BomberMan_0);
}
;
function $createImage(this$static, width, height){
  return new HtmlCanvasImage_0(this$static.ctx_0(), this$static.scale_3(), create_9(this$static.scale_3(), width, height));
}

function $getFontMetrics(this$static, font){
  var emwidth, height, metrics;
  metrics = $get_4(this$static.fontMetrics, font);
  if (!metrics) {
    this$static.measureElement.style['fontSize'] = font.size + ($clinit_Style$Unit() , 'px');
    this$static.measureElement.style['fontWeight'] = ($clinit_Style$FontWeight() , 'normal');
    this$static.measureElement.style['fontStyle'] = ($clinit_Style$FontStyle() , 'normal');
    $setInnerText(this$static.measureElement, 'THEQUICKBROWNFOXJUMPEDOVERTHELAZYDOGthequickbrownfoxjumpedoverthelazydog');
    switch (font.style_0.ordinal) {
      case 1:
        this$static.measureElement.style['fontWeight'] = 'bold';
        break;
      case 2:
        this$static.measureElement.style['fontStyle'] = 'italic';
    }
    height = this$static.measureElement.offsetHeight || 0;
    $setInnerText(this$static.measureElement, 'm');
    emwidth = this$static.measureElement.offsetWidth || 0;
    metrics = new HtmlFontMetrics_0(height, emwidth);
    $put_2(this$static.fontMetrics, font, metrics);
  }
  return metrics;
}

function $layoutText(this$static, text, format){
  return new HtmlTextLayout_0(this$static.dummyCtx, text, format);
}

function $transformMouse(this$static, x, y){
  return $set_15(this$static.mousePoint, x / this$static.scale_3().factor, y / this$static.scale_3().factor);
}

function HtmlGraphics_0(){
  var doc;
  this.mousePoint = new Point_0;
  this.fontMetrics = new HashMap_0;
  doc = $doc;
  this.dummyCanvas = doc.createElement('canvas');
  this.dummyCtx = this.dummyCanvas.getContext('2d');
  this.rootElement = doc.getElementById('playn-root');
  if (!this.rootElement) {
    this.rootElement = doc.createElement('div');
    this.rootElement.setAttribute('style', 'width: 640px; height: 480px');
    $appendChild(doc.body, this.rootElement);
  }
   else {
    this.rootElement.innerHTML = '';
  }
  this.measureElement = doc.createElement('div');
  this.measureElement.style['visibility'] = ($clinit_Style$Visibility() , 'hidden');
  this.measureElement.style['position'] = ($clinit_Style$Position() , 'absolute');
  this.measureElement.style['top'] = -500 + ($clinit_Style$Unit() , 'px');
  this.measureElement.style['overflow'] = ($clinit_Style$Overflow() , 'visible');
  $appendChild(this.rootElement, this.measureElement);
}

function cssColorString(color){
  var a, b, g, r;
  a = (~~color >> 24 & 255) / 255;
  r = ~~color >> 16 & 255;
  g = ~~color >> 8 & 255;
  b = color & 255;
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}

defineSeed(604, 1, {});
_.ctx_0 = function ctx_0(){
  return null;
}
;
_.dummyCanvas = null;
_.dummyCtx = null;
_.measureElement = null;
_.rootElement = null;
function $height(this$static){
  return round_int($invScaled(this$static.scale_0, this$static.elem.offsetHeight || 0));
}

function $width(this$static){
  return round_int($invScaled(this$static.scale_0, this$static.elem.offsetWidth || 0));
}

function HtmlGraphicsCanvas_0(){
  HtmlGraphics_0.call(this);
  this.scale_0 = new Scale_0(1);
  this.rootLayer = new GroupLayerCanvas_0(($clinit_HtmlPlatform() , hasTypedArraySupport)?new HtmlInternalTransform_0:new StockInternalTransform_0);
  this.elem = $doc.createElement('canvas');
  $setWidth(this.elem, this.rootElement.offsetWidth || 0);
  $setHeight(this.elem, this.rootElement.offsetHeight || 0);
  $appendChild(this.rootElement, this.elem);
  this.ctx = this.elem.getContext('2d');
  this.ctx.scale(1, 1);
  this.canvas = new HtmlGraphicsCanvas$1_0(this, this.ctx);
}

defineSeed(605, 604, {}, HtmlGraphicsCanvas_0);
_.createGroupLayer = function createGroupLayer(){
  return new GroupLayerCanvas_0(($clinit_HtmlPlatform() , hasTypedArraySupport)?new HtmlInternalTransform_0:new StockInternalTransform_0);
}
;
_.createImageLayer = function createImageLayer(img){
  return $setImage(new ImageLayerCanvas_0(($clinit_HtmlPlatform() , hasTypedArraySupport)?new HtmlInternalTransform_0:new StockInternalTransform_0), img);
}
;
_.createImmediateLayer = function createImmediateLayer(renderer){
  return new ImmediateLayerCanvas_0(($clinit_HtmlPlatform() , hasTypedArraySupport)?new HtmlInternalTransform_0:new StockInternalTransform_0, renderer);
}
;
_.createSurface = function createSurface(width, height){
  return new HtmlSurfaceImageCanvas_0(this.scale_0, create_9(this.scale_0, width, height));
}
;
_.height_2 = function height_6(){
  return $height(this);
}
;
_.paint_2 = function paint_22(){
  $clear_5(this.canvas);
  $paint_1(this.rootLayer, this.canvas, 1);
  $setAlpha(this.canvas, 1);
}
;
_.rootElement_0 = function rootElement_0(){
  return this.elem;
}
;
_.rootLayer_0 = function rootLayer_0(){
  return this.rootLayer;
}
;
_.scale_3 = function scale_3(){
  return this.scale_0;
}
;
_.width_2 = function width_6(){
  return $width(this);
}
;
_.canvas = null;
_.ctx = null;
_.elem = null;
_.rootLayer = null;
_.scale_0 = null;
function HtmlGraphicsCanvas$1_0(this$0, $anonymous0){
  this.this$0 = this$0;
  AbstractHtmlCanvas_0.call(this, $anonymous0, 0, 0);
}

defineSeed(606, 587, {}, HtmlGraphicsCanvas$1_0);
_.height_1 = function height_7(){
  return $height(this.this$0);
}
;
_.width_1 = function width_7(){
  return $width(this.this$0);
}
;
_.this$0 = null;
function HtmlGraphicsGL_0(platform){
  var $e0, attrs, error, gl, re;
  HtmlGraphics_0.call(this);
  this.canvas = $doc.createElement('canvas');
  $setWidth(this.canvas, this.rootElement.offsetWidth || 0);
  $setHeight(this.canvas, this.rootElement.offsetHeight || 0);
  $appendChild(this.rootElement, this.canvas);
  try {
    attrs = {premultipliedAlpha:false};
    attrs.alpha = false;
    attrs.antialias = true;
    gl = getContext(this.canvas, attrs);
    if (!gl)
      throw new RuntimeException_0('Unable to create GL context');
    error = gl.getError();
    if (error != 0)
      throw new RuntimeException_0('GL context started with errors [err=' + error + ']');
    this.ctx = new HtmlGLContext_0(platform, gl, this.canvas);
    this.rootLayer = new GroupLayerGL_0;
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$RuntimeException)) {
      re = $e0;
      $removeChild(this.rootElement, this.canvas);
      throw re;
    }
     else 
      throw $e0;
  }
}

defineSeed(607, 604, {}, HtmlGraphicsGL_0);
_.createGroupLayer = function createGroupLayer_0(){
  return new GroupLayerGL_0;
}
;
_.createImageLayer = function createImageLayer_0(img){
  return $setImage_0(new ImageLayerGL_0, img);
}
;
_.createImmediateLayer = function createImmediateLayer_0(renderer){
  return new ImmediateLayerGL_0(this.ctx, renderer);
}
;
--></script>
<script><!--
_.createSurface = function createSurface_0(width, height){
  return new SurfaceImageGL_0(this.ctx, new SurfaceGL_0(this.ctx, width, height));
}
;
_.ctx_0 = function ctx_1(){
  return this.ctx;
}
;
_.height_2 = function height_8(){
  return this.ctx.viewHeight;
}
;
_.paint_2 = function paint_23(){
  $paint_2(this.ctx, this.rootLayer);
}
;
_.rootElement_0 = function rootElement_1(){
  return this.canvas;
}
;
_.rootLayer_0 = function rootLayer_1(){
  return this.rootLayer;
}
;
_.scale_3 = function scale_4(){
  return this.ctx.scale_0;
}
;
_.width_2 = function width_8(){
  return this.ctx.viewWidth;
}
;
_.canvas = null;
_.ctx = null;
_.rootLayer = null;
function HtmlImage$1_0(this$0, val$callback){
  this.this$0 = this$0;
  this.val$callback = val$callback;
}

defineSeed(608, 1, {}, HtmlImage$1_0);
_.handleEvent = function handleEvent(evt){
  this.val$callback.onSuccess(this.this$0);
}
;
_.this$0 = null;
_.val$callback = null;
function HtmlImage$2_0(this$0, val$callback){
  this.this$0 = this$0;
  this.val$callback = val$callback;
}

defineSeed(609, 1, {}, HtmlImage$2_0);
_.handleEvent = function handleEvent_0(evt){
  this.val$callback.onFailure(new RuntimeException_0('Error loading image ' + this.this$0.img.src));
}
;
_.this$0 = null;
_.val$callback = null;
function getRelativeX(e, target){
  return (e.clientX || 0) - $getAbsoluteLeft(target) + $getScrollLeft(target) + $getScrollLeft(target.ownerDocument.body);
}

function getRelativeY(e, target){
  return (e.clientY || 0) - $getAbsoluteTop(target) + (target.scrollTop || 0) + (target.ownerDocument.body.scrollTop || 0);
}

function HtmlInput$1_0(val$handler){
  this.val$handler = val$handler;
}

defineSeed(611, 1, {}, HtmlInput$1_0);
_.handleEvent = function handleEvent_1(evt){
  this.val$handler.handleEvent(evt);
}
;
_.val$handler = null;
function $clinit_HtmlInternalTransform(){
  $clinit_HtmlInternalTransform = nullMethod;
  new HtmlInternalTransform_0;
}

function $concatenate(this$static, m00, m01, m10, m11, tx, ty, originX, originY){
  multiply(this$static.matrix[0], this$static.matrix[1], this$static.matrix[2], this$static.matrix[3], this$static.matrix[4], this$static.matrix[5], 1, 0, 0, 1, originX, originY, this$static);
  multiply(this$static.matrix[0], this$static.matrix[1], this$static.matrix[2], this$static.matrix[3], this$static.matrix[4], this$static.matrix[5], m00, m01, m10, m11, tx - originX, ty - originY, this$static);
  multiply(this$static.matrix[0], this$static.matrix[1], this$static.matrix[2], this$static.matrix[3], this$static.matrix[4], this$static.matrix[5], 1, 0, 0, 1, -originX, -originY, this$static);
  return this$static;
}

function $concatenate_0(this$static, other, originX, originY){
  var ot;
  ot = other;
  return $concatenate(this$static, ot.matrix[0], ot.matrix[1], ot.matrix[2], ot.matrix[3], ot.matrix[4], ot.matrix[5], originX, originY);
}

function $set_14(this$static, other){
  $set_0(this$static.matrix, other.matrix);
  return this$static;
}

function $setM00(this$static, value){
  this$static.matrix[0] = value;
}

function $setM01(this$static, value){
  this$static.matrix[1] = value;
}

function $setM10(this$static, value){
  this$static.matrix[2] = value;
}

function $setM11(this$static, value){
  this$static.matrix[3] = value;
}

function $setTx(this$static, tx){
  this$static.matrix[4] = tx;
  return this$static;
}

function $setTy(this$static, ty){
  this$static.matrix[5] = ty;
  return this$static;
}

function HtmlInternalTransform_0(){
  $clinit_HtmlInternalTransform();
  HtmlInternalTransform_2.call(this, initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [1, 0, 0, 1, 0, 0]));
}

function HtmlInternalTransform_1(matrix){
  this.matrix = matrix;
}

function HtmlInternalTransform_2(matrix){
  HtmlInternalTransform_1.call(this, createFloat32Array(toJsArray(matrix)));
}

function multiply(am00, am01, am10, am11, atx, aty, bm00, bm01, bm10, bm11, btx, bty, into){
  $set(into.matrix, initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [am00 * bm00 + am10 * bm01, am01 * bm00 + am11 * bm01, am00 * bm10 + am10 * bm11, am01 * bm10 + am11 * bm11, am00 * btx + am10 * bty + atx, am01 * btx + am11 * bty + aty]), 0);
  return into;
}

defineSeed(612, 533, {}, HtmlInternalTransform_0);
_.inverseTransform = function inverseTransform_0(p, into){
  var det, m00, m01, m10, m11, rdet, x, y;
  m00 = this.matrix[0];
  m01 = this.matrix[1];
  m10 = this.matrix[2];
  m11 = this.matrix[3];
  x = p.x - this.matrix[4];
  y = p.y - this.matrix[5];
  det = m00 * m11 - m01 * m10;
  if (abs(det) == 0) {
    throw new NoninvertibleTransformException_0('affine [' + toString_49(this.matrix[0]) + ' ' + toString_49(this.matrix[1]) + ' ' + toString_49(this.matrix[2]) + ' ' + toString_49(this.matrix[3]) + ' ' + new Vector_1(this.matrix[4], this.matrix[5]) + ']');
  }
  rdet = 1 / det;
  return into.x = (x * m11 - y * m10) * rdet , into.y = (y * m00 - x * m01) * rdet , into;
}
;
_.m00_0 = function m00_1(){
  return this.matrix[0];
}
;
_.m01_0 = function m01_1(){
  return this.matrix[1];
}
;
_.m10_0 = function m10_1(){
  return this.matrix[2];
}
;
_.m11_0 = function m11_1(){
  return this.matrix[3];
}
;
_.scaleX = function scaleX_2(scaleX){
  $setM00(this, this.matrix[0] * scaleX);
  $setM01(this, this.matrix[1] * scaleX);
  $setTx(this, this.matrix[4] * scaleX);
  return this;
}
;
_.scaleY = function scaleY_2(scaleY){
  $setM10(this, this.matrix[2] * scaleY);
  $setM11(this, this.matrix[3] * scaleY);
  $setTy(this, this.matrix[5] * scaleY);
  return this;
}
;
_.set_0 = function set_1(other){
  return $set_14(this, other);
}
;
_.setTransform = function setTransform_1(m00, m01, m10, m11, tx, ty){
  return $set(this.matrix, initValues(_3F_classLit, makeCastMap([Q$Serializable]), -1, [m00, m01, m10, m11, tx, ty]), 0) , this;
}
;
_.setTranslation_0 = function setTranslation_2(tx, ty){
  this.matrix[4] = tx;
  this.matrix[5] = ty;
  return this;
}
;
_.setTx = function setTx_1(tx){
  return $setTx(this, tx);
}
;
_.setTy = function setTy_1(ty){
  return $setTy(this, ty);
}
;
_.toString$ = function toString_46(){
  return 'affine [' + toString_49(this.matrix[0]) + ' ' + toString_49(this.matrix[1]) + ' ' + toString_49(this.matrix[2]) + ' ' + toString_49(this.matrix[3]) + ' ' + new Vector_1(this.matrix[4], this.matrix[5]) + ']';
}
;
_.tx_0 = function tx_1(){
  return this.matrix[4];
}
;
_.ty_0 = function ty_1(){
  return this.matrix[5];
}
;
_.uniformScale = function uniformScale_1(scale){
  return $scale_0(this, scale, scale);
}
;
_.matrix = null;
function $init_5(this$static){
  captureEvent_0('keydown', new HtmlKeyboard$1_0(this$static));
  captureEvent_0('keypress', new HtmlKeyboard$2_0(this$static));
  captureEvent_0('keyup', new HtmlKeyboard$3_0(this$static));
}

function $setListener_1(this$static, listener){
  this$static.listener = listener;
}

function HtmlKeyboard_0(){
}

function keyForCode(keyCode){
  switch (keyCode) {
    case 18:
      return $clinit_Key() , ALT;
    case 8:
      return $clinit_Key() , BACKSPACE;
    case 17:
      return $clinit_Key() , CONTROL;
    case 46:
      return $clinit_Key() , DELETE;
    case 40:
      return $clinit_Key() , DOWN_0;
    case 35:
      return $clinit_Key() , END;
    case 13:
      return $clinit_Key() , ENTER;
    case 27:
      return $clinit_Key() , ESCAPE;
    case 36:
      return $clinit_Key() , HOME;
    case 37:
      return $clinit_Key() , LEFT_0;
    case 34:
      return $clinit_Key() , PAGE_DOWN;
    case 33:
      return $clinit_Key() , PAGE_UP;
    case 39:
      return $clinit_Key() , RIGHT_0;
    case 16:
      return $clinit_Key() , SHIFT;
    case 9:
      return $clinit_Key() , TAB;
    case 38:
      return $clinit_Key() , UP_0;
    case 19:
      return $clinit_Key() , PAUSE;
    case 20:
      return $clinit_Key() , CAPS_LOCK;
    case 32:
      return $clinit_Key() , SPACE;
    case 45:
      return $clinit_Key() , INSERT;
    case 48:
      return $clinit_Key() , K0;
    case 49:
      return $clinit_Key() , K1;
    case 50:
      return $clinit_Key() , K2;
    case 51:
      return $clinit_Key() , K3;
    case 52:
      return $clinit_Key() , K4;
    case 53:
      return $clinit_Key() , K5;
    case 54:
      return $clinit_Key() , K6;
    case 55:
      return $clinit_Key() , K7;
    case 56:
      return $clinit_Key() , K8;
    case 57:
      return $clinit_Key() , K9;
    case 65:
      return $clinit_Key() , A_0;
    case 66:
      return $clinit_Key() , B_0;
    case 67:
      return $clinit_Key() , C_0;
    case 68:
      return $clinit_Key() , D_0;
    case 69:
      return $clinit_Key() , E;
    case 70:
      return $clinit_Key() , F;
    case 71:
      return $clinit_Key() , G;
    case 72:
      return $clinit_Key() , H;
    case 73:
      return $clinit_Key() , I_0;
    case 74:
      return $clinit_Key() , J;
    case 75:
      return $clinit_Key() , K_0;
    case 76:
      return $clinit_Key() , L;
    case 77:
      return $clinit_Key() , M;
    case 78:
      return $clinit_Key() , N;
    case 79:
      return $clinit_Key() , O;
    case 80:
      return $clinit_Key() , P;
    case 81:
      return $clinit_Key() , Q;
    case 82:
      return $clinit_Key() , R_0;
    case 83:
      return $clinit_Key() , S;
    case 84:
      return $clinit_Key() , T_0;
    case 85:
      return $clinit_Key() , U;
    case 86:
      return $clinit_Key() , V;
    case 87:
      return $clinit_Key() , W;
    case 88:
      return $clinit_Key() , X;
    case 89:
      return $clinit_Key() , Y;
    case 90:
      return $clinit_Key() , Z;
    case 92:
    case 91:
      return $clinit_Key() , WINDOWS;
    case 96:
      return $clinit_Key() , NP0;
    case 97:
      return $clinit_Key() , NP1;
    case 98:
      return $clinit_Key() , NP2;
    case 99:
      return $clinit_Key() , NP3;
    case 100:
      return $clinit_Key() , NP4;
    case 101:
      return $clinit_Key() , NP5;
    case 102:
      return $clinit_Key() , NP6;
    case 103:
      return $clinit_Key() , NP7;
    case 104:
      return $clinit_Key() , NP8;
    case 105:
      return $clinit_Key() , NP9;
    case 106:
      return $clinit_Key() , NP_MULTIPLY;
    case 107:
      return $clinit_Key() , NP_ADD;
    case 109:
      return $clinit_Key() , NP_SUBTRACT;
    case 110:
      return $clinit_Key() , NP_DECIMAL;
    case 111:
      return $clinit_Key() , NP_DIVIDE;
    case 112:
      return $clinit_Key() , F1;
    case 113:
      return $clinit_Key() , F2;
    case 114:
      return $clinit_Key() , F3;
    case 115:
      return $clinit_Key() , F4;
    case 116:
      return $clinit_Key() , F5;
    case 117:
      return $clinit_Key() , F6;
    case 118:
      return $clinit_Key() , F7;
    case 119:
      return $clinit_Key() , F8;
    case 120:
      return $clinit_Key() , F9;
    case 121:
      return $clinit_Key() , F10;
    case 122:
      return $clinit_Key() , F11;
    case 123:
      return $clinit_Key() , F12;
    case 144:
      return $clinit_Key() , NP_NUM_LOCK;
    case 145:
      return $clinit_Key() , SCROLL_LOCK;
    case 186:
      return $clinit_Key() , SEMICOLON;
    case 187:
      return $clinit_Key() , EQUALS;
    case 188:
      return $clinit_Key() , COMMA;
    case 189:
      return $clinit_Key() , MINUS;
    case 190:
      return $clinit_Key() , PERIOD;
    case 191:
      return $clinit_Key() , SLASH;
    case 192:
      return $clinit_Key() , BACKQUOTE;
    case 219:
      return $clinit_Key() , LEFT_BRACKET;
    case 220:
      return $clinit_Key() , BACKSLASH;
    case 221:
      return $clinit_Key() , RIGHT_BRACKET;
    case 222:
      return $clinit_Key() , QUOTE;
    default:return $clinit_Key() , UNKNOWN_1;
  }
}

defineSeed(613, 1, {}, HtmlKeyboard_0);
_.listener = null;
function HtmlKeyboard$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(614, 1, {}, HtmlKeyboard$1_0);
_.handleEvent = function handleEvent_2(nativeEvent){
  var event_0;
  if (this.this$0.listener) {
    event_0 = new Keyboard$Event$Impl_0(new Events$Flags$Impl_0, now_0(), keyForCode(nativeEvent.keyCode || 0));
    $onKeyDown(this.this$0.listener, event_0);
    event_0.flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
function HtmlKeyboard$2_0(this$0){
  this.this$0 = this$0;
}

defineSeed(615, 1, {}, HtmlKeyboard$2_0);
_.handleEvent = function handleEvent_3(nativeEvent){
  var event_0;
  if (this.this$0.listener) {
    event_0 = new Keyboard$TypedEvent$Impl_0(new Events$Flags$Impl_0, now_0(), (nativeEvent.charCode || 0) & 65535);
    $onKeyTyped(this.this$0.listener, event_0);
    event_0.flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
function HtmlKeyboard$3_0(this$0){
  this.this$0 = this$0;
}

defineSeed(616, 1, {}, HtmlKeyboard$3_0);
_.handleEvent = function handleEvent_4(nativeEvent){
  var event_0;
  if (this.this$0.listener) {
    event_0 = new Keyboard$Event$Impl_0(new Events$Flags$Impl_0, now_0(), keyForCode(nativeEvent.keyCode || 0));
    $onKeyUp(this.this$0.listener, event_0);
    event_0.flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
defineSeed(617, 513, {});
function $handleRequestsInUserEventContext(this$static){
  this$static.isRequestingMouseLock && !$isLocked() && $requestMouseLockImpl(this$static.rootElement);
}

function $isLocked(){
  return !!($doc.pointerLockElement || $doc.webkitPointerLockElement || $doc.mozPointerLockElement);
}

function $requestMouseLockImpl(element){
  element.requestPointerLock = element.requestPointerLock || element.webkitRequestPointerLock || element.mozRequestPointerLock;
  element.requestPointerLock && element.requestPointerLock();
}

function HtmlMouse_0(platform, rootElement){
  this.DOWN = new MouseImpl$1_0;
  this.UP = new MouseImpl$2_0;
  this.DRAG = new MouseImpl$3_0;
  this.MOVE = new MouseImpl$4_0;
  this.OVER = new MouseImpl$5_0;
  this.OUT = new MouseImpl$6_0;
  this.WHEEL_SCROLL = new MouseImpl$7_0;
  this.lastMousePt = new Point_0;
  this.rootElement = rootElement;
  addEventListener_0($doc, 'contextmenu', new HtmlMouse$1_0, false);
  captureEvent(rootElement, 'mousedown', new HtmlMouse$2_0(this, platform, rootElement));
  captureEvent_0('mouseup', new HtmlInput$1_0(new HtmlMouse$3_0(this, platform, rootElement)));
  captureEvent_0('mousemove', new HtmlInput$1_0(new HtmlMouse$4_0(this, platform, rootElement)));
  captureEvent(rootElement, 'mousemove', new HtmlMouse$5_0(this, platform, rootElement));
  captureEvent(rootElement, getMouseWheelEvent(), new HtmlMouse$6_0(this));
}

function getMouseButton(evt){
  switch ($eventGetButton(evt)) {
    case 1:
      return 0;
    case 4:
      return 1;
    case 2:
      return 2;
    default:return $eventGetButton(evt);
  }
}

function getMouseWheelEvent(){
  if (navigator.userAgent.toLowerCase().indexOf('firefox') != -1) {
    return 'DOMMouseScroll';
  }
   else {
    return 'mousewheel';
  }
}

function getMouseWheelVelocity(evt){
  var delta = 0;
  var agentInfo = ($clinit_HtmlPlatform() , agentInfo_0);
  if (agentInfo.isFirefox) {
    agentInfo.isMacOS?(delta = 1 * evt.detail):(delta = 1 * evt.detail / 3);
  }
   else if (agentInfo.isOpera) {
    agentInfo.isLinux?(delta = -1 * evt.wheelDelta / 80):(delta = -1 * evt.wheelDelta / 40);
  }
   else if (agentInfo.isChrome || agentInfo.isSafari) {
    delta = -1 * evt.wheelDelta / 120;
    Math.abs(delta) < 1 && (agentInfo.isWindows?(delta = -1 * evt.wheelDelta):agentInfo.isMacOS && (delta = -1 * evt.wheelDelta / 3));
  }
  return delta;
}

defineSeed(618, 517, {}, HtmlMouse_0);
_.inDragSequence = false;
_.isRequestingMouseLock = false;
_.rootElement = null;
function HtmlMouse$1_0(){
}

defineSeed(619, 1, {}, HtmlMouse$1_0);
_.handleEvent = function handleEvent_5(evt){
  evt.preventDefault();
  evt.stopPropagation();
}
;
function HtmlMouse$1XYEventHandler_0(val$platform, val$rootElement){
  this.val$platform = val$platform;
  this.val$rootElement = val$rootElement;
}

defineSeed(621, 1, {});
_.handleEvent = function handleEvent_6(ev){
  var xy;
  xy = $transformMouse(this.val$platform.graphics, getRelativeX(ev, this.val$rootElement), getRelativeY(ev, this.val$rootElement));
  this.handleEvent_0(ev, xy.x, xy.y);
}
;
_.val$platform = null;
_.val$rootElement = null;
function HtmlMouse$1MoveEventHandler_0(this$0, val$platform, val$rootElement){
  this.this$0 = this$0;
  HtmlMouse$1XYEventHandler_0.call(this, val$platform, val$rootElement);
}

defineSeed(620, 621, {});
_.handleEvent_0 = function handleEvent_7(ev, x, y){
  var dx, dy;
  if (this.lastX == -1) {
    this.lastX = x;
    this.lastY = y;
  }
  if (this.this$0.inDragSequence == this.wantDragSequence()) {
    if ($isLocked()) {
      dx = ev.webkitMovementX;
      dy = ev.webkitMovementY;
    }
     else {
      dx = x - this.lastX;
      dy = y - this.lastY;
    }
    $onMouseMove(this.this$0, new Mouse$MotionEvent$Impl_0(new Events$Flags$Impl_0, now_0(), x, y, dx, dy)) && (ev.preventDefault() , undefined);
  }
  this.lastX = x;
  this.lastY = y;
  $set_15(this.this$0.lastMousePt, x, y);
}
;
_.lastX = -1;
_.lastY = -1;
_.this$0 = null;
function HtmlMouse$2_0(this$0, val$platform, val$rootElement){
  this.this$0 = this$0;
  HtmlMouse$1XYEventHandler_0.call(this, val$platform, val$rootElement);
}

defineSeed(622, 621, {}, HtmlMouse$2_0);
_.handleEvent_0 = function handleEvent_8(ev, x, y){
  this.this$0.inDragSequence = true;
  $onMouseDown(this.this$0, new Mouse$ButtonEvent$Impl_0(new Events$Flags$Impl_0, now_0(), x, y, getMouseButton(ev))) && (ev.preventDefault() , undefined);
}
;
_.this$0 = null;
function HtmlMouse$3_0(this$0, val$platform, val$rootElement){
  this.this$0 = this$0;
  HtmlMouse$1XYEventHandler_0.call(this, val$platform, val$rootElement);
}

defineSeed(623, 621, {}, HtmlMouse$3_0);
_.handleEvent_0 = function handleEvent_9(ev, x, y){
  if (this.this$0.inDragSequence) {
    this.this$0.inDragSequence = false;
    $onMouseUp(this.this$0, new Mouse$ButtonEvent$Impl_0(new Events$Flags$Impl_0, now_0(), x, y, getMouseButton(ev))) && (ev.preventDefault() , undefined);
  }
  $handleRequestsInUserEventContext(this.this$0);
}
;
_.this$0 = null;
function HtmlMouse$4_0(this$0, val$platform, val$rootElement){
  HtmlMouse$1MoveEventHandler_0.call(this, this$0, val$platform, val$rootElement);
}

defineSeed(624, 620, {}, HtmlMouse$4_0);
_.wantDragSequence = function wantDragSequence(){
  return true;
}
;
function HtmlMouse$5_0(this$0, val$platform, val$rootElement){
  HtmlMouse$1MoveEventHandler_0.call(this, this$0, val$platform, val$rootElement);
}

defineSeed(625, 620, {}, HtmlMouse$5_0);
_.wantDragSequence = function wantDragSequence_0(){
  return false;
}
;
function HtmlMouse$6_0(this$0){
  this.this$0 = this$0;
}

defineSeed(626, 1, {}, HtmlMouse$6_0);
_.handleEvent = function handleEvent_10(ev){
  $onMouseWheelScroll(this.this$0, new Mouse$WheelEvent$Impl_0(new Events$Flags$Impl_0, now_0(), this.this$0.lastMousePt.x, this.this$0.lastMousePt.y, getMouseWheelVelocity(ev))) && (ev.preventDefault() , undefined);
}
;
_.this$0 = null;
function $pattern(this$static, ctx){
  var repeat;
  if (this$static.repeatX) {
    this$static.repeatY?(repeat = ($clinit_Context2d$Repetition() , REPEAT)):(repeat = ($clinit_Context2d$Repetition() , REPEAT_X));
  }
   else if (this$static.repeatY) {
    repeat = ($clinit_Context2d$Repetition() , REPEAT_Y);
  }
   else {
    return null;
  }
  return $createPattern(ctx, this$static.patimg, repeat.value_0);
}

function HtmlPattern_0(patimg, repeatX, repeatY){
  this.patimg = patimg;
  this.repeatX = repeatX;
  this.repeatY = repeatY;
}

function HtmlPattern_1(image, repeatX, repeatY){
  HtmlPattern_0.call(this, image.img, repeatX, repeatY);
}

defineSeed(627, 1, {}, HtmlPattern_1);
_.patimg = null;
_.repeatX = false;
_.repeatY = false;
function $clinit_HtmlPlatform(){
  var userAgent;
  $clinit_HtmlPlatform = nullMethod;
  hasTypedArraySupport = typeof Float32Array != 'undefined';
  log_3 = new HtmlLogEnhanced_0;
  agentInfo_0 = (userAgent = navigator.userAgent.toLowerCase() , {isFirefox:userAgent.indexOf('firefox') != -1, isChrome:userAgent.indexOf('chrome') != -1, isSafari:userAgent.indexOf('safari') != -1, isOpera:userAgent.indexOf('opera') != -1, isIE:userAgent.indexOf('msie') != -1, isMacOS:userAgent.indexOf('mac') != -1, isLinux:userAgent.indexOf('linux') != -1, isWindows:userAgent.indexOf('win') != -1});
}

function $createGraphics(this$static, config){
  var $e0, e, t;
  try {
    switch (config.mode) {
      case 1:
        return new HtmlGraphicsCanvas_0;
      case 0:
        return new HtmlGraphicsGL_0(this$static);
      default:case 2:
        return !!$wnd.WebGLRenderingContext && (!/Chrome/.test(navigator.userAgent) || !/OS X 10_5/.test(navigator.userAgent))?new HtmlGraphicsGL_0(this$static):new HtmlGraphicsCanvas_0;
    }
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$RuntimeException)) {
      e = $e0;
      $logImpl((this$static.log_0 , 1), 'Failed to create GL context (' + e.getMessage() + '). Falling back.', null);
    }
     else if (instanceOf($e0, Q$Throwable)) {
      t = $e0;
      $logImpl((this$static.log_0 , 1), 'GL context creation failed with an unknown error.' + t, null);
    }
     else 
      throw $e0;
  }
  return new HtmlGraphicsCanvas_0;
}

function $requestAnimationFrame(callback){
  var fn = function(){
    callback.fire_0();
  }
  ;
  $wnd.requestAnimationFrame?$wnd.requestAnimationFrame(fn):$wnd.mozRequestAnimationFrame?$wnd.mozRequestAnimationFrame(fn):$wnd.webkitRequestAnimationFrame?$wnd.webkitRequestAnimationFrame(fn):$wnd.setTimeout(fn, 20);
}

function $run(this$static, game){
  $setListener_1(platform_1.keyboard, game);
  $setListener(platform_1.pointer, game);
  $setListener_0(platform_1.touch, game);
  game.startScreen = new StartScreen_0(game);
  game.gameScreen = new GameScreen_0(game);
  game.pauseScreen = new PauseScreen_0(game);
  game.winScreen = new WinScreen_0(game);
  game.loseScreen = new LoseScreen_0(game);
  game.instructionScreen = new InstructionsScreen_0(game);
  game.loadScreen = new LoadScreen_0(game, initValues(_3Lbomberman_core_ui_UIScreen_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$UIScreen, [game.startScreen, game.pauseScreen, game.winScreen, game.loseScreen, game.gameScreen]));
  game.delegate = game.loadScreen;
  initialize(new BomberMan$1_0(game));
  game.immediateLayer = platform_1.graphics.createImmediateLayer(new BomberMan$2_0(game));
  (!instance_1 && (instance_1 = new LayerManager_0) , instance_1).immediateLayer.add_1(game.immediateLayer);
  this$static.paintCallback = new HtmlPlatform$1_0(this$static, game);
  $requestAnimationFrame(this$static.paintCallback);
}

function $tick_0(this$static){
  return round_int(now_0() - this$static.start);
}

function HtmlPlatform_0(config){
  var $e0, e;
  AbstractPlatform_0.call(this, log_3);
  this.assets = new HtmlAssets_0(this);
  this.audio = new HtmlAudio_0;
  this.keyboard = new HtmlKeyboard_0;
  new HtmlStorage_0;
  this.analytics = new HtmlAnalytics_0;
  this.start = initNow();
  try {
    this.graphics = $createGraphics(this, config);
    this.pointer = new HtmlPointer_0(this, this.graphics.rootElement_0());
    new HtmlMouse_0(this, this.graphics.rootElement_0());
    this.touch = new HtmlTouch_0(this, this.graphics.rootElement_0());
  }
   catch ($e0) {
    $e0 = caught_0($e0);
    if (instanceOf($e0, Q$Throwable)) {
      e = $e0;
      $logImpl(3, 'init()', e);
      alert_0('failed to init(): ' + e.getMessage());
      throw new RuntimeException_2(e);
    }
     else 
      throw $e0;
  }
}

function addEventListener_0(target, name_0, handler, capture){
  $clinit_HtmlPlatform();
  target.addEventListener(name_0, function(e){
    handler.handleEvent(e);
  }
  , capture);
}

function captureEvent(target, name_0, handler){
  $clinit_HtmlPlatform();
  addEventListener_0(!target?$doc:target, name_0, handler, true);
}

function captureEvent_0(name_0, handler){
  $clinit_HtmlPlatform();
  addEventListener_0($doc, name_0, handler, true);
}

function initNow(){
  function now(){
    return new Date;
  }

  !Date.now && (Date.now = now);
  return Date.now();
}

function now_0(){
  $clinit_HtmlPlatform();
  return Date.now();
}

defineSeed(628, 496, {}, HtmlPlatform_0);
_.graphics = null;
_.paintCallback = null;
_.pointer = null;
_.touch = null;
var agentInfo_0, hasTypedArraySupport, log_3;
function HtmlPlatform$1_0(this$0, val$game){
  this.this$0 = this$0;
  this.val$game = val$game;
}

defineSeed(629, 1, {}, HtmlPlatform$1_0);
_.fire_0 = function fire_0(){
  $requestAnimationFrame(this.this$0.paintCallback);
  this.this$0.runQueue.head = null;
  $tick(this.val$game, $tick_0(this.this$0));
  this.this$0.graphics.paint_2();
}
;
_.this$0 = null;
_.val$game = null;
function HtmlPlatform$Config_0(){
  this.mode = requestedMode();
}

defineSeed(631, 1, {}, HtmlPlatform$Config_0);
function $eventFromMouse(this$static, rootElement, nativeEvent){
  var x, xy, y;
  x = (nativeEvent.clientX || 0) - $getAbsoluteLeft(rootElement) + $getScrollLeft(rootElement) + $getScrollLeft(rootElement.ownerDocument.body);
  y = (nativeEvent.clientY || 0) - $getAbsoluteTop(rootElement) + (rootElement.scrollTop || 0) + (rootElement.ownerDocument.body.scrollTop || 0);
  xy = $transformMouse(this$static.platform.graphics, x, y);
  return new Pointer$Event$Impl_0(new Events$Flags$Impl_0, now_0(), xy.x, xy.y, false);
}

function $eventFromTouch(this$static, rootElement, touch){
  var x, xy, y;
  x = touch.clientX - $getAbsoluteLeft(rootElement) + $getScrollLeft(rootElement) + $getScrollLeft(rootElement.ownerDocument.body);
  y = touch.clientY - $getAbsoluteTop(rootElement) + (rootElement.scrollTop || 0) + (rootElement.ownerDocument.body.scrollTop || 0);
  xy = $transformMouse(this$static.platform.graphics, x, y);
  return new Pointer$Event$Impl_0(new Events$Flags$Impl_0, now_0(), xy.x, xy.y, true);
}

function HtmlPointer_0(platform, rootElement){
  this.active = new Dispatcher$CaptureState_0;
  this.START = new PointerImpl$1_0;
  this.DRAG = new PointerImpl$2_0;
  this.END = new PointerImpl$3_0;
  this.platform = platform;
  captureEvent(rootElement, 'touchstart', new HtmlPointer$1_0(this, rootElement));
  captureEvent_0('touchend', new HtmlInput$1_0(new HtmlPointer$2_0(this, rootElement)));
  captureEvent_0('touchmove', new HtmlInput$1_0(new HtmlPointer$3_0(this, rootElement)));
  captureEvent(rootElement, 'mousedown', new HtmlPointer$4_0(this, rootElement));
  captureEvent_0('mouseup', new HtmlInput$1_0(new HtmlPointer$5_0(this, rootElement)));
  captureEvent_0('mousemove', new HtmlInput$1_0(new HtmlPointer$6_0(this, rootElement)));
}

defineSeed(632, 527, {}, HtmlPointer_0);
_.inDragSequence = false;
_.platform = null;
function HtmlPointer$1_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(633, 1, {}, HtmlPointer$1_0);
_.handleEvent = function handleEvent_11(nativeEvent){
  var touches;
  touches = nativeEvent.changedTouches;
  if (touches.length > 0) {
    this.this$0.inDragSequence = true;
    $onPointerStart_1(this.this$0, $eventFromTouch(this.this$0, this.val$rootElement, touches[0])) && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$2_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(634, 1, {}, HtmlPointer$2_0);
_.handleEvent = function handleEvent_12(nativeEvent){
  var touches;
  touches = nativeEvent.changedTouches;
  if (this.this$0.inDragSequence && touches.length > 0) {
    this.this$0.inDragSequence = false;
    $onPointerEnd_0(this.this$0, $eventFromTouch(this.this$0, this.val$rootElement, touches[0]), true) && (nativeEvent.preventDefault() , undefined);
  }
   else {
    nativeEvent.preventDefault();
  }
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$3_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(635, 1, {}, HtmlPointer$3_0);
_.handleEvent = function handleEvent_13(nativeEvent){
  var touches;
  touches = nativeEvent.changedTouches;
  this.this$0.inDragSequence && touches.length > 0?$onPointerDrag_0(this.this$0, $eventFromTouch(this.this$0, this.val$rootElement, touches[0]), true) && (nativeEvent.preventDefault() , undefined):(nativeEvent.preventDefault() , undefined);
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$4_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(636, 1, {}, HtmlPointer$4_0);
_.handleEvent = function handleEvent_14(nativeEvent){
  this.this$0.inDragSequence = true;
  $onPointerStart_1(this.this$0, $eventFromMouse(this.this$0, this.val$rootElement, nativeEvent)) && (nativeEvent.preventDefault() , undefined);
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$5_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(637, 1, {}, HtmlPointer$5_0);
_.handleEvent = function handleEvent_15(nativeEvent){
  if (this.this$0.inDragSequence) {
    this.this$0.inDragSequence = false;
    $onPointerEnd_0(this.this$0, $eventFromMouse(this.this$0, this.val$rootElement, nativeEvent), false) && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
_.val$rootElement = null;
function HtmlPointer$6_0(this$0, val$rootElement){
  this.this$0 = this$0;
  this.val$rootElement = val$rootElement;
}

defineSeed(638, 1, {}, HtmlPointer$6_0);
_.handleEvent = function handleEvent_16(nativeEvent){
  this.this$0.inDragSequence && $onPointerDrag_0(this.this$0, $eventFromMouse(this.this$0, this.val$rootElement, nativeEvent), false) && (nativeEvent.preventDefault() , undefined);
}
;
_.this$0 = null;
_.val$rootElement = null;
function $setLoopingImpl(this$static, looping){
  this$static.impl.setLooping_0(looping);
}

--></script>
<script><!--
function HtmlSound_0(sound){
  $addEventHandler(sound, new HtmlSound$1_0(this, sound));
}

defineSeed(639, 497, {}, HtmlSound_0);
function $onSoundLoadStateChange(this$static, event_0){
  var loadState;
  loadState = event_0.loadState;
  switch (loadState.ordinal) {
    case 5:
    case 4:
      break;
    case 2:
    case 1:
    case 3:
      $onLoaded(this$static.this$0, this$static.val$sound);
      break;
    case 0:
      $onLoadError(this$static.this$0, new RuntimeException_0(loadState.name_1));
      break;
    default:throw new RuntimeException_0('Unrecognized sound load state ' + loadState.name_1);
  }
}

function HtmlSound$1_0(this$0, val$sound){
  this.this$0 = this$0;
  this.val$sound = val$sound;
}

defineSeed(640, 1, {}, HtmlSound$1_0);
_.this$0 = null;
_.val$sound = null;
function HtmlStorage_0(){
  var storage;
  storage = getLocalStorageIfSupported();
  storage?new StorageMap_0(storage):new HashMap_0;
}

defineSeed(641, 1, {}, HtmlStorage_0);
function HtmlSurfaceImageCanvas_0(scale, canvas){
  HtmlCanvasImage_0.call(this, null, scale, canvas);
  this.surface = new CanvasSurface_0(canvas);
}

defineSeed(642, 594, {}, HtmlSurfaceImageCanvas_0);
_.surface_0 = function surface_1(){
  return this.surface;
}
;
_.surface = null;
function $configContext(this$static, ctx){
  var font, style;
  font = $getFont(this$static.format);
  style = '';
  switch (font.style_0.ordinal) {
    case 1:
      style = 'bold';
      break;
    case 2:
      style = 'italic';
      break;
    case 3:
      style = 'bold italic';
  }
  $setFont(ctx, style + ' ' + font.size + 'px ' + font.name_0);
  $setTextBaseline(ctx, ($clinit_Context2d$TextBaseline() , TOP).value_0);
}

function $fill(this$static, ctx, x, y){
  var line, line$iterator, ypos;
  $configContext(this$static, ctx);
  ypos = 0;
  for (line$iterator = new AbstractList$IteratorImpl_0(this$static.lines); line$iterator.i < line$iterator.this$0_0.size_0();) {
    line = $next_2(line$iterator);
    $fillText(ctx, line.text, x + this$static.format.align.getX(line.width_0, this$static.width_0), y + ypos);
    ypos += this$static.metrics.height_0;
  }
}

function $getFont(format){
  return !format.font_0?($clinit_HtmlFont() , DEFAULT):format.font_0;
}

function $measureLine(this$static, ctx, words, idx){
  var lastIdx, line, lineWidth, nline, nlineWidth, remainder, startIdx;
  line = words[idx++];
  startIdx = idx;
  for (; idx < words.length; ++idx) {
    nline = line + ' ' + words[idx];
    if (nline.length * this$static.metrics.emwidth > this$static.format.wrapWidth)
      break;
    line = nline;
  }
  lineWidth = ctx.measureText(line).width;
  if (lineWidth < this$static.format.wrapWidth) {
    for (; idx < words.length; ++idx) {
      nline = line + ' ' + words[idx];
      nlineWidth = ctx.measureText(nline).width;
      if (nlineWidth > this$static.format.wrapWidth)
        break;
      line = nline;
      lineWidth = nlineWidth;
    }
  }
  while (lineWidth > this$static.format.wrapWidth && idx > startIdx + 1) {
    line = $substring_0(line, 0, line.length - words[--idx].length - 1);
    lineWidth = ctx.measureText(line).width;
  }
  if (lineWidth > this$static.format.wrapWidth) {
    remainder = new StringBuilder_0;
    while (lineWidth > this$static.format.wrapWidth && line.length > 1) {
      lastIdx = line.length - 1;
      $insert_0(remainder, valueOf_0(line.charCodeAt(lastIdx)));
      line = line.substr(0, lastIdx - 0);
      lineWidth = ctx.measureText(line).width;
    }
    words[--idx] = remainder.impl.string;
  }
  $add_4(this$static.lines, new HtmlTextLayout$Line_0(line, lineWidth));
  this$static.width_0 = max(this$static.width_0, lineWidth);
  return idx;
}

function $stroke(this$static, ctx){
  var line, line$iterator, ypos;
  $configContext(this$static, ctx);
  ypos = 0;
  for (line$iterator = new AbstractList$IteratorImpl_0(this$static.lines); line$iterator.i < line$iterator.this$0_0.size_0();) {
    line = $next_2(line$iterator);
    $strokeText(ctx, line.text, this$static.format.align.getX(line.width_0, this$static.width_0), ypos);
    ypos += this$static.metrics.height_0;
  }
}

function HtmlTextLayout_0(ctx, text, format){
  var font, idx, line, line$array, line$index, line$max, words;
  this.lines = new ArrayList_0;
  font = !format.font_0?($clinit_HtmlFont() , DEFAULT):format.font_0;
  this.format = format;
  this.metrics = $getFontMetrics(platform_1.graphics, font);
  $configContext(this, ctx);
  text = $replace_0($replace_1(text, '\r\n', '\n'), 13, 10);
  if (format.wrapWidth != 3.4028234663852886E38 || $indexOf_1(text, fromCodePoint(10)) != -1) {
    for (line$array = $split(text, '\\n', 0) , line$index = 0 , line$max = line$array.length; line$index < line$max; ++line$index) {
      line = line$array[line$index];
      words = $split(line, '\\s', 0);
      for (idx = 0; idx < words.length;) {
        idx = $measureLine(this, ctx, words, idx);
      }
    }
    this.height_0 = this.metrics.height_0 * this.lines.size;
  }
   else {
    this.width_0 = ctx.measureText(text).width;
    this.height_0 = this.metrics.height_0;
    $add_4(this.lines, new HtmlTextLayout$Line_0(text, this.width_0));
  }
  switch (font.style_0.ordinal) {
    case 2:
      this.width_0 += this.metrics.emwidth / 8;
      break;
    case 3:
      this.width_0 += this.metrics.emwidth / 6;
  }
}

defineSeed(643, 1, {}, HtmlTextLayout_0);
_.format = null;
_.height_0 = 0;
_.metrics = null;
_.width_0 = 0;
function HtmlTextLayout$Line_0(text, width){
  this.text = text;
  this.width_0 = width;
}

defineSeed(644, 1, {}, HtmlTextLayout$Line_0);
_.text = null;
_.width_0 = 0;
function $toEvents(this$static, nativeEvent, flags){
  var id, nativeTouches, nativeTouchesLen, t, touch, touches, x, xy, y;
  nativeTouches = nativeEvent.changedTouches;
  nativeTouchesLen = nativeTouches.length;
  touches = initDim(_3Lplayn_core_Touch$Event$Impl_2_classLit, makeCastMap([Q$Serializable, Q$Object_$1]), Q$Touch$Event$Impl, nativeTouchesLen, 0);
  for (t = 0; t < nativeTouchesLen; ++t) {
    touch = nativeTouches[t];
    x = $getRelativeX(touch, this$static.rootElement);
    y = $getRelativeY(touch, this$static.rootElement);
    xy = $transformMouse(this$static.platform.graphics, x, y);
    id = nativeEvent.changedTouches[t].identifier || 0;
    touches[t] = new Touch$Event$Impl_0(flags, now_0(), xy.x, xy.y, id);
  }
  return touches;
}

function HtmlTouch_0(platform, rootElement){
  $clinit_TouchImpl();
  this.activeLayers = new HashMap_0;
  this.platform = platform;
  this.rootElement = rootElement;
  captureEvent(rootElement, 'touchstart', new HtmlTouch$1_0(this));
  captureEvent_0('touchmove', new HtmlInput$1_0(new HtmlTouch$2_0(this)));
  captureEvent_0('touchend', new HtmlInput$1_0(new HtmlTouch$3_0(this)));
}

defineSeed(645, 541, {}, HtmlTouch_0);
_.inTouchSequence = false;
_.platform = null;
_.rootElement = null;
function HtmlTouch$1_0(this$0){
  this.this$0 = this$0;
}

defineSeed(646, 1, {}, HtmlTouch$1_0);
_.handleEvent = function handleEvent_17(nativeEvent){
  var flags;
  this.this$0.inTouchSequence = true;
  flags = new Events$Flags$Impl_0;
  $onTouchStart_0(this.this$0, $toEvents(this.this$0, nativeEvent, flags));
  flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
}
;
_.this$0 = null;
function HtmlTouch$2_0(this$0){
  this.this$0 = this$0;
}

defineSeed(647, 1, {}, HtmlTouch$2_0);
_.handleEvent = function handleEvent_18(nativeEvent){
  var flags;
  if (this.this$0.inTouchSequence) {
    flags = new Events$Flags$Impl_0;
    $onTouchMove_0(this.this$0, $toEvents(this.this$0, nativeEvent, flags));
    flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
  }
}
;
_.this$0 = null;
function HtmlTouch$3_0(this$0){
  this.this$0 = this$0;
}

defineSeed(648, 1, {}, HtmlTouch$3_0);
_.handleEvent = function handleEvent_19(nativeEvent){
  var flags;
  if (this.this$0.inTouchSequence) {
    flags = new Events$Flags$Impl_0;
    $onTouchEnd_0(this.this$0, $toEvents(this.this$0, nativeEvent, flags));
    flags.preventDefault_0 && (nativeEvent.preventDefault() , undefined);
    nativeEvent.touches.length == 0 && (this.this$0.inTouchSequence = false);
  }
}
;
_.this$0 = null;
function $clinit_HtmlUrlParameters(){
  $clinit_HtmlUrlParameters = nullMethod;
  checkGLErrors = $equals('check', (ensureParameterMap() , $get_4(paramMap, 'glerrors')));
  $equals('quad', (ensureParameterMap() , $get_4(paramMap, 'glshader')));
}

var checkGLErrors;
function getRandom(){
  var $e0, random, val;
  random = Math.random();
  val = (ensureParameterMap() , $get_4(paramMap, 'analytics'));
  if (val != null) {
    try {
      random = parseFloat_0(val);
    }
     catch ($e0) {
      $e0 = caught_0($e0);
      if (!instanceOf($e0, Q$Exception))
        throw $e0;
    }
  }
  return random;
}

function requestedMode(){
  var renderer;
  renderer = (ensureParameterMap() , $get_4(paramMap, 'renderer'));
  if ($equals('canvas', renderer)) {
    return 1;
  }
   else if ($equals('gl', renderer)) {
    return 0;
  }
  return 2;
}

function $setHandler(this$static, handler){
  var _this = this$static;
  this$static.onerror = $entry(function(){
    handler.onError(_this);
  }
  );
  this$static.onload = $entry(function(){
    handler.onLoad(_this);
  }
  );
  this$static.onprogress = $entry(function(){
    handler.onProgress(_this);
  }
  );
  this$static.ontimeout = $entry(function(){
    handler.onTimeout(_this);
  }
  );
}

function $logImpl(level, msg, e){
  switch (level) {
    case 0:
      $clinit_Log();
      $log(impl_0, 10000, msg, e);
      break;
    default:$clinit_Log();
      $log(impl_0, 20000, msg, e);
      break;
    case 2:
      $clinit_Log();
      $log(impl_0, 30000, msg, e);
      break;
    case 3:
      $clinit_Log();
      $log(impl_0, 40000, msg, e);
  }
}

function HtmlLogEnhanced_0(){
  $clinit_Log();
  setUncaughtExceptionHandler(new LogImplBase$1_0);
  $setErrorHandler();
}

defineSeed(652, 617, {}, HtmlLogEnhanced_0);
defineSeed(653, 1, makeCastMap([Q$AbstractPoint]));
_.equals$ = function equals_20(obj){
  var p;
  if (obj === this) {
    return true;
  }
  if (instanceOf(obj, Q$AbstractPoint)) {
    p = obj;
    return this.x_0() == p.x && this.y_0() == p.y;
  }
  return false;
}
;
_.hashCode$ = function hashCode_19(){
  return round_int(this.x_0()) ^ round_int(this.y_0());
}
;
_.toString$ = function toString_47(){
  return pointToString(this.x_0(), this.y_0());
}
;
defineSeed(654, 1, makeCastMap([Q$AbstractVector]));
_.equals$ = function equals_21(obj){
  var p;
  if (obj === this) {
    return true;
  }
  if (instanceOf(obj, Q$AbstractVector)) {
    p = obj;
    return this.x_0() == p.x && this.y_0() == p.y;
  }
  return false;
}
;
_.hashCode$ = function hashCode_20(){
  return round_int(this.x_0()) ^ round_int(this.y_0());
}
;
_.toString$ = function toString_48(){
  return vectorToString(this.x_0(), this.y_0());
}
;
function iceil(v){
  var iv;
  iv = round_int(v);
  return v <= 0 || iv == v || iv == 2147483647?iv:iv + 1;
}

function toString_49(value){
  var buf, ii, ivalue;
  buf = new StringBuilder_0;
  if (value >= 0) {
    buf.impl.string += '+';
  }
   else {
    buf.impl.string += '-';
    value = -value;
  }
  ivalue = round_int(value);
  $append_1(buf.impl, ivalue);
  buf.impl.string += '.';
  for (ii = 0; ii < 3; ++ii) {
    value = (value - ivalue) * 10;
    ivalue = round_int(value);
    $append_1(buf.impl, ivalue);
  }
  for (ii = 0; ii < 2; ++ii) {
    $charAt_0(buf, buf.impl.string.length - 1) == 48 && $setLength(buf, buf.impl.string.length - 1);
  }
  return buf.impl.string;
}

function $set_15(this$static, x, y){
  this$static.x = x;
  this$static.y = y;
  return this$static;
}

function Point_0(){
}

function Point_1(x, y){
  $set_15(this, x, y);
}

defineSeed(656, 653, makeCastMap([Q$Serializable, Q$AbstractPoint]), Point_0, Point_1);
_.x_0 = function x_0(){
  return this.x;
}
;
_.y_0 = function y_0(){
  return this.y;
}
;
_.x = 0;
_.y = 0;
function $clinit_Points(){
  $clinit_Points = nullMethod;
  new Point_1(0, 0);
}

function pointToString(x, y){
  $clinit_Points();
  return toString_49(x) + toString_49(y);
}

function multiply_0(am00, am01, am10, am11, atx, aty, bm00, bm11, into){
  $setTransform_0(into, am00 * bm00, am01 * bm00, am10 * bm11, am11 * bm11, atx, aty);
  return into;
}

function Vector_1(x, y){
  this.x = x;
  this.y = y;
}

defineSeed(659, 654, makeCastMap([Q$AbstractVector]), Vector_1);
_.x_0 = function x_1(){
  return this.x;
}
;
_.y_0 = function y_1(){
  return this.y;
}
;
_.x = 0;
_.y = 0;
function $clinit_Vectors(){
  $clinit_Vectors = nullMethod;
  new Vector_1(1, 0);
  new Vector_1(0, 1);
  new Vector_1(0, 0);
  new Vector_1(-3.4028234663852886E38, -3.4028234663852886E38);
  new Vector_1(3.4028234663852886E38, 3.4028234663852886E38);
}

function vectorToString(x, y){
  $clinit_Vectors();
  return toString_49(x) + toString_49(y);
}

function NoninvertibleTransformException_0(s){
  RuntimeException_0.call(this, s);
}

defineSeed(661, 144, makeCastMap([Q$Serializable, Q$Exception, Q$RuntimeException, Q$Throwable, Q$NoninvertibleTransformException]), NoninvertibleTransformException_0);
var $entry = entry_0;
function gwtOnLoad(errFn, modName, modBase, softPermutationId){
  $moduleName = modName;
  $moduleBase = modBase;
  if (errFn)
    try {
      $entry(init)();
    }
     catch (e) {
      errFn(modName);
    }
   else {
    $entry(init)();
  }
}

--></script>
<script><!--
var Ljava_lang_Object_2_classLit = createForClass(1), Lplayn_html_HtmlGame$1_2_classLit = createForClass(602), Lplayn_html_HtmlGame$2_2_classLit = createForClass(603), Lcom_google_gwt_core_client_Scheduler_2_classLit = createForClass(152), Lcom_google_gwt_core_client_JavaScriptObject_2_classLit = createForClass(133), Ljava_lang_Throwable_2_classLit = createForClass(97), Ljava_lang_Exception_2_classLit = createForClass(145), Ljava_lang_RuntimeException_2_classLit = createForClass(144), Ljava_lang_StackTraceElement_2_classLit = createForClass(347), _3Ljava_lang_StackTraceElement_2_classLit = createForArray(668, Ljava_lang_StackTraceElement_2_classLit), Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit = createForClass(257), _3Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit = createForArray(669, Lcom_google_gwt_lang_LongLibBase$LongEmul_2_classLit), I_classLit = createForPrimitive(' I'), _3I_classLit = createForArray(670, I_classLit), Lcom_google_gwt_lang_SeedUtil_2_classLit = createForClass(258), Ljava_lang_Enum_2_classLit = createForClass(39), Ljava_lang_Error_2_classLit = createForClass(335), Ljava_lang_Number_2_classLit = createForClass(334), C_classLit = createForPrimitive(' C'), _3C_classLit = createForArray(671, C_classLit), Ljava_lang_Class_2_classLit = createForClass(332), D_classLit = createForPrimitive(' D'), _3D_classLit = createForArray(672, D_classLit), F_classLit = createForPrimitive(' F'), Ljava_lang_Integer_2_classLit = createForClass(340), _3Ljava_lang_Integer_2_classLit = createForArray(673, Ljava_lang_Integer_2_classLit), S_classLit = createForPrimitive(' S'), Ljava_lang_String_2_classLit = createForClass(2), _3Ljava_lang_String_2_classLit = createForArray(666, Ljava_lang_String_2_classLit), Ljava_lang_StringBuilder_2_classLit = createForClass(350), Ljava_lang_ArrayStoreException_2_classLit = createForClass(330), Lcom_google_gwt_core_client_JavaScriptException_2_classLit = createForClass(143), Ljava_lang_ArithmeticException_2_classLit = createForClass(329), Lcom_google_gwt_core_client_impl_StringBufferImpl_2_classLit = createForClass(163), Lcom_google_gwt_core_client_impl_SchedulerImpl_2_classLit = createForClass(154), Lcom_google_gwt_core_client_impl_SchedulerImpl$Flusher_2_classLit = createForClass(155), Lcom_google_gwt_core_client_impl_SchedulerImpl$Rescuer_2_classLit = createForClass(156), Lcom_google_gwt_core_client_impl_StackTraceCreator$Collector_2_classLit = createForClass(159), Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorMoz_2_classLit = createForClass(161), Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorChrome_2_classLit = createForClass(160), Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorChromeNoSourceMap_2_classLit = createForClass(162), Lcom_google_gwt_core_client_impl_StringBufferImplAppend_2_classLit = createForClass(164), Lplayn_core_LogImpl_2_classLit = createForClass(513), Lplayn_core_AbstractPlatform_2_classLit = createForClass(496), Lplayn_html_HtmlPlatform_2_classLit = createForClass(628), Lplayn_html_HtmlPlatform$Config_2_classLit = createForClass(631), Lplayn_html_HtmlPlatform$1_2_classLit = createForClass(629), Lplayn_html_HtmlLog_2_classLit = createForClass(617), Ljava_lang_NullPointerException_2_classLit = createForClass(344), Ljava_lang_IllegalArgumentException_2_classLit = createForClass(337), Lplayn_logging_enhanced_HtmlLogEnhanced_2_classLit = createForClass(652), Lcom_allen_1sauer_gwt_log_client_impl_LogImpl_2_classLit = createForClass(91), Lcom_allen_1sauer_gwt_log_client_impl_LogImplBase_2_classLit = createForClass(92), Lcom_allen_1sauer_gwt_log_client_impl_LogImplDebug_2_classLit = createForClass(94), Lcom_allen_1sauer_gwt_log_client_DivLogger_2_classLit = createForClass(null), Lcom_allen_1sauer_gwt_log_client_WindowLogger_2_classLit = createForClass(null), Lcom_allen_1sauer_gwt_log_client_impl_LogImplBase$1_2_classLit = createForClass(93), Lplayn_core_AbstractAssets_2_classLit = createForClass(489), Lplayn_html_HtmlAssets_2_classLit = createForClass(589), Lplayn_html_HtmlAssets$1_2_classLit = createForClass(590), Lplayn_html_HtmlAssets$2_2_classLit = createForClass(591), Lplayn_core_Game$Default_2_classLit = createForClass(4), Lbomberman_core_BomberMan_2_classLit = createForClass(3), Lbomberman_core_ui_UIScreen_2_classLit = createForInterface(), _3Lbomberman_core_ui_UIScreen_2_classLit = createForArray(674, Lbomberman_core_ui_UIScreen_2_classLit), Lbomberman_core_BomberMan$1_2_classLit = createForClass(5), Lbomberman_core_BomberMan$2_2_classLit = createForClass(6), Lplayn_core_Events$Input$Impl_2_classLit = createForClass(505), Lplayn_core_Keyboard$Event$Impl_2_classLit = createForClass(510), Lplayn_core_Keyboard$TypedEvent$Impl_2_classLit = createForClass(511), Lplayn_core_Events$Flags$Impl_2_classLit = createForClass(504), Lplayn_core_Events$Position$Impl_2_classLit = createForClass(506), Lplayn_core_Pointer$Event$Impl_2_classLit = createForClass(526), Lplayn_core_Touch$Event$Impl_2_classLit = createForClass(540), Lcom_google_gwt_dom_client_StyleInjector$StyleInjectorImpl_2_classLit = createForClass(218), Lcom_google_gwt_dom_client_StyleInjector$1_2_classLit = createForClass(217), Lcom_allen_1sauer_gwt_log_client_NullLogger_2_classLit = createForClass(88), Lcom_allen_1sauer_gwt_log_client_SystemLogger_2_classLit = createForClass(90), Lcom_allen_1sauer_gwt_log_client_ConsoleLogger_2_classLit = createForClass(84), Lcom_google_web_bindery_event_shared_Event_2_classLit = createForClass(222), Lcom_google_gwt_event_shared_GwtEvent_2_classLit = createForClass(221), Lcom_google_gwt_user_client_Window$ClosingEvent_2_classLit = createForClass(294), Lcom_google_gwt_event_shared_HandlerManager_2_classLit = createForClass(230), Lcom_google_gwt_user_client_Window$WindowHandlers_2_classLit = createForClass(297), Lcom_google_web_bindery_event_shared_Event$Type_2_classLit = createForClass(225), Lcom_google_gwt_event_shared_GwtEvent$Type_2_classLit = createForClass(224), Lcom_google_web_bindery_event_shared_EventBus_2_classLit = createForClass(233), Lcom_google_web_bindery_event_shared_SimpleEventBus_2_classLit = createForClass(232), Lcom_google_gwt_event_shared_HandlerManager$Bus_2_classLit = createForClass(231), Lcom_google_web_bindery_event_shared_SimpleEventBus$1_2_classLit = createForClass(326), Lcom_google_web_bindery_event_shared_SimpleEventBus$2_2_classLit = createForClass(327), Lcom_google_web_bindery_event_shared_SimpleEventBus$3_2_classLit = createForClass(328), Lcom_google_gwt_user_client_ui_UIObject_2_classLit = createForClass(265), Lcom_google_gwt_user_client_ui_Widget_2_classLit = createForClass(264), Lcom_google_gwt_user_client_ui_Panel_2_classLit = createForClass(303), Lcom_google_gwt_user_client_ui_ComplexPanel_2_classLit = createForClass(302), Lcom_google_web_bindery_event_shared_UmbrellaException_2_classLit = createForClass(236), Lcom_google_gwt_event_shared_UmbrellaException_2_classLit = createForClass(235), Lcom_google_gwt_user_client_ui_AttachDetachException_2_classLit = createForClass(304), Lcom_google_gwt_user_client_ui_AttachDetachException$1_2_classLit = createForClass(305), Lcom_google_gwt_user_client_ui_AttachDetachException$2_2_classLit = createForClass(306), Lcom_allen_1sauer_gwt_log_client_RemoteLogger_2_classLit = createForClass(89), Ljava_lang_StringBuffer_2_classLit = createForClass(349), Lcom_allen_1sauer_gwt_log_shared_LogRecord_2_classLit = createForClass(95), Lplayn_html_HtmlGraphics_2_classLit = createForClass(604), Lplayn_core_PointerImpl_2_classLit = createForClass(527), Lplayn_html_HtmlPointer_2_classLit = createForClass(632), Lplayn_html_HtmlPointer$1_2_classLit = createForClass(633), Lplayn_html_HtmlPointer$2_2_classLit = createForClass(634), Lplayn_html_HtmlPointer$3_2_classLit = createForClass(635), Lplayn_html_HtmlPointer$4_2_classLit = createForClass(636), Lplayn_html_HtmlPointer$5_2_classLit = createForClass(637), Lplayn_html_HtmlPointer$6_2_classLit = createForClass(638), Lplayn_core_Pointer$Listener_2_classLit = createForInterface(), Lplayn_core_PointerImpl$1_2_classLit = createForClass(528), Lplayn_core_PointerImpl$2_2_classLit = createForClass(529), Lplayn_core_PointerImpl$3_2_classLit = createForClass(530), Lplayn_core_AbstractLayer_2_classLit = createForClass(492), Lplayn_core_AbstractLayer$Interactor_2_classLit = createForClass(495), Lplayn_core_AbstractLayer$Flag_2_classLit = createForEnum(494, values_21), _3Lplayn_core_AbstractLayer$Flag_2_classLit = createForArray(675, Lplayn_core_AbstractLayer$Flag_2_classLit), Lplayn_core_AbstractLayer$1_2_classLit = createForClass(493), Lplayn_core_MouseImpl_2_classLit = createForClass(517), Lplayn_html_HtmlMouse_2_classLit = createForClass(618), Lplayn_html_HtmlMouse$1_2_classLit = createForClass(619), Lplayn_html_HtmlMouse$1XYEventHandler_2_classLit = createForClass(621), Lplayn_html_HtmlMouse$1MoveEventHandler_2_classLit = createForClass(620), Lplayn_html_HtmlMouse$2_2_classLit = createForClass(622), Lplayn_html_HtmlMouse$3_2_classLit = createForClass(623), Lplayn_html_HtmlMouse$4_2_classLit = createForClass(624), Lplayn_html_HtmlMouse$5_2_classLit = createForClass(625), Lplayn_html_HtmlMouse$6_2_classLit = createForClass(626), Lplayn_core_Mouse$LayerListener_2_classLit = createForInterface(), Lplayn_core_MouseImpl$1_2_classLit = createForClass(518), Lplayn_core_MouseImpl$2_2_classLit = createForClass(519), Lplayn_core_MouseImpl$3_2_classLit = createForClass(520), Lplayn_core_MouseImpl$4_2_classLit = createForClass(521), Lplayn_core_MouseImpl$5_2_classLit = createForClass(522), Lplayn_core_MouseImpl$6_2_classLit = createForClass(523), Lplayn_core_MouseImpl$7_2_classLit = createForClass(524), Lplayn_core_Mouse$ButtonEvent$Impl_2_classLit = createForClass(514), Lplayn_core_Mouse$MotionEvent$Impl_2_classLit = createForClass(515), Lplayn_core_Mouse$WheelEvent$Impl_2_classLit = createForClass(516), Lplayn_core_TouchImpl_2_classLit = createForClass(541), Lplayn_html_HtmlTouch_2_classLit = createForClass(645), _3Lplayn_core_Touch$Event$Impl_2_classLit = createForArray(676, Lplayn_core_Touch$Event$Impl_2_classLit), Lplayn_html_HtmlTouch$1_2_classLit = createForClass(646), Lplayn_html_HtmlTouch$2_2_classLit = createForClass(647), Lplayn_html_HtmlTouch$3_2_classLit = createForClass(648), Lplayn_core_Touch$LayerListener_2_classLit = createForInterface(), Lplayn_core_TouchImpl$1_2_classLit = createForClass(542), Lplayn_core_TouchImpl$2_2_classLit = createForClass(543), Lplayn_core_TouchImpl$3_2_classLit = createForClass(544), Lplayn_html_HtmlAnalytics_2_classLit = createForClass(588), Lplayn_html_HtmlAudio_2_classLit = createForClass(592), Lplayn_html_HtmlKeyboard_2_classLit = createForClass(613), Lplayn_html_HtmlKeyboard$1_2_classLit = createForClass(614), Lplayn_html_HtmlKeyboard$2_2_classLit = createForClass(615), Lplayn_html_HtmlKeyboard$3_2_classLit = createForClass(616), Lbomberman_core_ui_StartScreen_2_classLit = createForClass(76), Lbomberman_core_ui_GameScreen_2_classLit = createForClass(64), Lbomberman_core_ui_PauseScreen_2_classLit = createForClass(75), Lbomberman_core_ui_WinScreen_2_classLit = createForClass(78), Lbomberman_core_ui_LoseScreen_2_classLit = createForClass(74), _3F_classLit = createForArray(677, F_classLit), Lbomberman_core_ui_InstructionsScreen_2_classLit = createForClass(65), Lbomberman_core_ui_InstructionsScreen$RescaleAndPlaceImageCallback_2_classLit = createForClass(70), Lbomberman_core_ui_InstructionsScreen$1_2_classLit = createForClass(66), Lbomberman_core_ui_InstructionsScreen$2_2_classLit = createForClass(67), Lbomberman_core_ui_InstructionsScreen$3_2_classLit = createForClass(68), Lbomberman_core_ui_InstructionsScreen$4_2_classLit = createForClass(69), Lbomberman_core_ui_LoadScreen_2_classLit = createForClass(71), Lplayn_core_AssetWatcher$Listener_2_classLit = createForClass(73), Lbomberman_core_ui_LoadScreen$1_2_classLit = createForClass(72), Lplayn_core_AssetWatcher_2_classLit = createForClass(498), Lplayn_core_AssetWatcher$1_2_classLit = createForClass(499), Lbomberman_core_PropertiesManager_2_classLit = createForClass(7), Lbomberman_core_PropertiesManager$1_2_classLit = createForClass(8), Lbomberman_core_graphics_LayerManager_2_classLit = createForClass(23), _3Ljava_lang_Object_2_classLit = createForArray(665, Ljava_lang_Object_2_classLit), Ljava_util_AbstractCollection_2_classLit = createForClass(116), Ljava_util_AbstractList_2_classLit = createForClass(115), Ljava_util_ArrayList_2_classLit = createForClass(114), Ljava_util_AbstractList$IteratorImpl_2_classLit = createForClass(365), Ljava_util_AbstractList$ListIteratorImpl_2_classLit = createForClass(366), Lcom_allen_1sauer_gwt_log_shared_WrappedClientThrowable_2_classLit = createForClass(98), Lplayn_core_util_RunQueue_2_classLit = createForClass(586), Lplayn_html_HtmlStorage_2_classLit = createForClass(641), Lplayn_html_HtmlGraphicsCanvas_2_classLit = createForClass(605), Lplayn_core_AbstractCanvas_2_classLit = createForClass(490), Lplayn_core_gl_AbstractCanvasGL_2_classLit = createForClass(550), Lplayn_html_AbstractHtmlCanvas_2_classLit = createForClass(587), Lplayn_html_HtmlGraphicsCanvas$1_2_classLit = createForClass(606), Lplayn_html_HtmlGraphicsGL_2_classLit = createForClass(607), Lplayn_html_HtmlInput$1_2_classLit = createForClass(611), Lcom_allen_1sauer_gwt_voices_client_SoundController_2_classLit = createForClass(107), Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit = createForEnum(109, values_4), _3Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit = createForArray(678, Lcom_allen_1sauer_gwt_voices_client_SoundType_2_classLit), Lcom_allen_1sauer_gwt_voices_client_SoundController$MimeTypeSupport_2_classLit = createForEnum(108, values_3), _3Lcom_allen_1sauer_gwt_voices_client_SoundController$MimeTypeSupport_2_classLit = createForArray(679, Lcom_allen_1sauer_gwt_voices_client_SoundController$MimeTypeSupport_2_classLit), Lbomberman_core_ui_TextGuiComponent_2_classLit = createForClass(77), Lbomberman_core_logic_LogicWorld_2_classLit = createForClass(19), Lbomberman_core_graphics_DecoratedWorld_2_classLit = createForClass(18), Lbomberman_core_logic_Block_2_classLit = createForClass(35), _3Lbomberman_core_logic_Block_2_classLit = createForArray(680, Lbomberman_core_logic_Block_2_classLit), _3_3Lbomberman_core_logic_Block_2_classLit = createForArray(681, _3Lbomberman_core_logic_Block_2_classLit), Lbomberman_core_logic_LogicWorld$Coordinate_2_classLit = createForClass(43), Ljava_util_AbstractMap_2_classLit = createForClass(275), Ljava_util_AbstractHashMap_2_classLit = createForClass(359), Ljava_util_HashMap_2_classLit = createForClass(377), Ljava_util_AbstractSet_2_classLit = createForClass(279), Ljava_util_AbstractHashMap$EntrySet_2_classLit = createForClass(360), Ljava_util_AbstractHashMap$EntrySetIterator_2_classLit = createForClass(361), Ljava_util_AbstractMapEntry_2_classLit = createForClass(363), Ljava_util_AbstractHashMap$MapEntryNull_2_classLit = createForClass(362), Ljava_util_AbstractHashMap$MapEntryString_2_classLit = createForClass(364), Ljava_util_AbstractMap$1_2_classLit = createForClass(367), Ljava_util_AbstractMap$1$1_2_classLit = createForClass(368), Lcom_allen_1sauer_gwt_log_client_LogMessageFormatterImpl_2_classLit = createForClass(86), Lcom_google_gwt_storage_client_Storage_2_classLit = createForClass(270), Lcom_google_gwt_storage_client_Storage$StorageSupportDetector_2_classLit = createForClass(271), Lcom_google_gwt_storage_client_StorageMap_2_classLit = createForClass(274), Lcom_google_gwt_storage_client_StorageMap$StorageEntry_2_classLit = createForClass(276), Lcom_google_gwt_storage_client_StorageMap$StorageEntryIterator_2_classLit = createForClass(277), Lcom_google_gwt_storage_client_StorageMap$StorageEntrySet_2_classLit = createForClass(278), Lplayn_core_gl_Scale_2_classLit = createForClass(581), Lplayn_core_canvas_LayerCanvas_2_classLit = createForClass(547), Lplayn_core_canvas_GroupLayerCanvas_2_classLit = createForClass(546), Lcom_google_gwt_canvas_dom_client_Context2d$LineCap_2_classLit = createForEnum(135, values_5), _3Lcom_google_gwt_canvas_dom_client_Context2d$LineCap_2_classLit = createForArray(682, Lcom_google_gwt_canvas_dom_client_Context2d$LineCap_2_classLit), Lcom_google_gwt_canvas_dom_client_Context2d$LineJoin_2_classLit = createForEnum(136, values_6), _3Lcom_google_gwt_canvas_dom_client_Context2d$LineJoin_2_classLit = createForArray(683, Lcom_google_gwt_canvas_dom_client_Context2d$LineJoin_2_classLit), Lcom_google_gwt_canvas_dom_client_Context2d$Repetition_2_classLit = createForEnum(137, values_7), _3Lcom_google_gwt_canvas_dom_client_Context2d$Repetition_2_classLit = createForArray(684, Lcom_google_gwt_canvas_dom_client_Context2d$Repetition_2_classLit), Lcom_google_gwt_canvas_dom_client_Context2d$TextBaseline_2_classLit = createForEnum(138, values_8), _3Lcom_google_gwt_canvas_dom_client_Context2d$TextBaseline_2_classLit = createForArray(685, Lcom_google_gwt_canvas_dom_client_Context2d$TextBaseline_2_classLit), Lplayn_core_gl_GLContext_2_classLit = createForClass(558), Lplayn_core_gl_GL20Context_2_classLit = createForClass(557), Lplayn_html_HtmlGLContext_2_classLit = createForClass(601), Lplayn_core_gl_GLContext$Stats_2_classLit = createForClass(564), Lplayn_core_gl_LayerGL_2_classLit = createForClass(571), Lplayn_core_gl_GroupLayerGL_2_classLit = createForClass(570), Lpythagoras_f_AbstractPoint_2_classLit = createForClass(653), Lpythagoras_f_Point_2_classLit = createForClass(656), Ljava_lang_NumberFormatException_2_classLit = createForClass(346), Lbomberman_core_graphics_DecoratedEntityEngine_2_classLit = createForClass(17), Lbomberman_core_graphics_SpritePlayer_2_classLit = createForClass(34), Lbomberman_core_ui_Button_2_classLit = createForClass(62), Lbomberman_core_ui_Button$1_2_classLit = createForClass(63), Lcom_google_gwt_dom_client_Style$Unit_2_classLit = createForEnum(202, values_13), _3Lcom_google_gwt_dom_client_Style$Unit_2_classLit = createForArray(686, Lcom_google_gwt_dom_client_Style$Unit_2_classLit), Lcom_google_gwt_dom_client_Style$FontStyle_2_classLit = createForEnum(183, values_9), _3Lcom_google_gwt_dom_client_Style$FontStyle_2_classLit = createForArray(687, Lcom_google_gwt_dom_client_Style$FontStyle_2_classLit), Lcom_google_gwt_dom_client_Style$FontWeight_2_classLit = createForEnum(187, values_10), _3Lcom_google_gwt_dom_client_Style$FontWeight_2_classLit = createForArray(688, Lcom_google_gwt_dom_client_Style$FontWeight_2_classLit), Lcom_google_gwt_dom_client_Style$Overflow_2_classLit = createForEnum(192, values_11), _3Lcom_google_gwt_dom_client_Style$Overflow_2_classLit = createForArray(689, Lcom_google_gwt_dom_client_Style$Overflow_2_classLit), Lcom_google_gwt_dom_client_Style$Position_2_classLit = createForEnum(197, values_12), _3Lcom_google_gwt_dom_client_Style$Position_2_classLit = createForArray(690, Lcom_google_gwt_dom_client_Style$Position_2_classLit), Lcom_google_gwt_dom_client_Style$Visibility_2_classLit = createForEnum(212, values_14), _3Lcom_google_gwt_dom_client_Style$Visibility_2_classLit = createForArray(691, Lcom_google_gwt_dom_client_Style$Visibility_2_classLit), Lcom_google_gwt_dom_client_Style$Unit$1_2_classLit = createForEnum(203, null), Lcom_google_gwt_dom_client_Style$Unit$2_2_classLit = createForEnum(204, null), Lcom_google_gwt_dom_client_Style$Unit$3_2_classLit = createForEnum(205, null), Lcom_google_gwt_dom_client_Style$Unit$4_2_classLit = createForEnum(206, null), Lcom_google_gwt_dom_client_Style$Unit$5_2_classLit = createForEnum(207, null), Lcom_google_gwt_dom_client_Style$Unit$6_2_classLit = createForEnum(208, null), Lcom_google_gwt_dom_client_Style$Unit$7_2_classLit = createForEnum(209, null), Lcom_google_gwt_dom_client_Style$Unit$8_2_classLit = createForEnum(210, null), Lcom_google_gwt_dom_client_Style$Unit$9_2_classLit = createForEnum(211, null), Lcom_google_gwt_dom_client_Style$FontStyle$1_2_classLit = createForEnum(184, null), Lcom_google_gwt_dom_client_Style$FontStyle$2_2_classLit = createForEnum(185, null), Lcom_google_gwt_dom_client_Style$FontStyle$3_2_classLit = createForEnum(186, null), Lcom_google_gwt_dom_client_Style$FontWeight$1_2_classLit = createForEnum(188, null), Lcom_google_gwt_dom_client_Style$FontWeight$2_2_classLit = createForEnum(189, null), Lcom_google_gwt_dom_client_Style$FontWeight$3_2_classLit = createForEnum(190, null), Lcom_google_gwt_dom_client_Style$FontWeight$4_2_classLit = createForEnum(191, null), Lcom_google_gwt_dom_client_Style$Overflow$1_2_classLit = createForEnum(193, null), Lcom_google_gwt_dom_client_Style$Overflow$2_2_classLit = createForEnum(194, null), Lcom_google_gwt_dom_client_Style$Overflow$3_2_classLit = createForEnum(195, null), Lcom_google_gwt_dom_client_Style$Overflow$4_2_classLit = createForEnum(196, null), Lcom_google_gwt_dom_client_Style$Position$1_2_classLit = createForEnum(198, null), Lcom_google_gwt_dom_client_Style$Position$2_2_classLit = createForEnum(199, null), Lcom_google_gwt_dom_client_Style$Position$3_2_classLit = createForEnum(200, null), Lcom_google_gwt_dom_client_Style$Position$4_2_classLit = createForEnum(201, null), Lcom_google_gwt_dom_client_Style$Visibility$1_2_classLit = createForEnum(213, null), Lcom_google_gwt_dom_client_Style$Visibility$2_2_classLit = createForEnum(214, null), Lpythagoras_f_AbstractTransform_2_classLit = createForClass(533), Lplayn_html_HtmlInternalTransform_2_classLit = createForClass(612), Lpythagoras_f_AffineTransform_2_classLit = createForClass(532), Lplayn_core_StockInternalTransform_2_classLit = createForClass(531), Lplayn_core_canvas_ImmediateLayerCanvas_2_classLit = createForClass(549), Lplayn_html_HtmlGL20$VertexAttribArrayState_2_classLit = createForClass(599), _3Lplayn_html_HtmlGL20$VertexAttribArrayState_2_classLit = createForArray(692, Lplayn_html_HtmlGL20$VertexAttribArrayState_2_classLit), Lplayn_html_HtmlGL20_2_classLit = createForClass(598), Lplayn_html_HtmlGL20$WebGLObjectType_2_classLit = createForEnum(600, values_25), _3Lplayn_html_HtmlGL20$WebGLObjectType_2_classLit = createForArray(693, Lplayn_html_HtmlGL20$WebGLObjectType_2_classLit), Lplayn_core_gl_ImmediateLayerGL_2_classLit = createForClass(574), Lplayn_core_gl_AbstractSurfaceGL_2_classLit = createForClass(553), Lplayn_core_gl_ImmediateLayerGL$ImmediateSurfaceGL_2_classLit = createForClass(576), Lplayn_core_gl_ImmediateLayerGL$1_2_classLit = createForClass(575), Lplayn_core_Dispatcher$CaptureState_2_classLit = createForClass(502), Lplayn_core_Key_2_classLit = createForEnum(509, values_23), _3Lplayn_core_Key_2_classLit = createForArray(694, Lplayn_core_Key_2_classLit), Lplayn_core_gl_ImageLayerGL_2_classLit = createForClass(573), Lbomberman_core_logic_ScoreManager_2_classLit = createForClass(44), Lplayn_core_gl_AbstractImageGL_2_classLit = createForClass(551), Lplayn_core_gl_ImageGL_2_classLit = createForClass(572), Lplayn_html_HtmlImage_2_classLit = createForClass(595), Lplayn_html_HtmlCanvasImage_2_classLit = createForClass(594), Lplayn_html_HtmlImage$1_2_classLit = createForClass(608), Lplayn_html_HtmlImage$2_2_classLit = createForClass(609), Lplayn_core_gl_AbstractImageGL$1_2_classLit = createForClass(552), Lplayn_html_HtmlCanvas_2_classLit = createForClass(593), Lplayn_core_Font$Style_2_classLit = createForEnum(507, values_22), _3Lplayn_core_Font$Style_2_classLit = createForArray(695, Lplayn_core_Font$Style_2_classLit), Lplayn_core_TextFormat_2_classLit = createForClass(534), Lplayn_core_TextFormat$Alignment_2_classLit = createForEnum(535, values_24), _3Lplayn_core_TextFormat$Alignment_2_classLit = createForArray(696, Lplayn_core_TextFormat$Alignment_2_classLit), Lplayn_core_TextFormat$Alignment$1_2_classLit = createForEnum(536, null), Lplayn_core_TextFormat$Alignment$2_2_classLit = createForEnum(537, null), Lplayn_core_TextFormat$Alignment$3_2_classLit = createForEnum(538, null), Ljava_lang_IllegalStateException_2_classLit = createForClass(338), Ljava_lang_UnsupportedOperationException_2_classLit = createForClass(352), Ljava_util_NoSuchElementException_2_classLit = createForClass(383), Lcom_allen_1sauer_gwt_log_shared_UnwrappedClientThrowable_2_classLit = createForClass(96), Lplayn_core_GroupLayerImpl_2_classLit = createForClass(508), _3Lplayn_core_AbstractLayer_2_classLit = createForArray(697, Lplayn_core_AbstractLayer_2_classLit), Lplayn_core_gl_GLShader_2_classLit = createForClass(565), Lplayn_core_gl_GLShader$Core_2_classLit = createForClass(566), Lplayn_core_gl_GLShader$Extras_2_classLit = createForClass(567), Lplayn_core_gl_GLShader$TextureExtras_2_classLit = createForClass(568), Lplayn_core_gl_IndexedTrisShader_2_classLit = createForClass(577), Lplayn_core_gl_IndexedTrisShader$ITCore_2_classLit = createForClass(578), Lbomberman_core_logic_Entity_2_classLit = createForClass(13), Lbomberman_core_logic_DynamicPhysicsEntity_2_classLit = createForClass(12), Lbomberman_core_logic_Bomber_2_classLit = createForClass(16), Lbomberman_core_graphics_BomberDecorator_2_classLit = createForClass(15), Lplayn_core_canvas_ImageLayerCanvas_2_classLit = createForClass(548), Lbomberman_core_logic_EntityEngine_2_classLit = createForClass(40), Lbomberman_core_logic_WallBlock_2_classLit = createForClass(47), Lbomberman_core_util_Vector2_2_classLit = createForClass(81), Lplayn_core_AbstractFont_2_classLit = createForClass(491), Lplayn_html_HtmlFont_2_classLit = createForClass(596), Lplayn_html_HtmlTextLayout_2_classLit = createForClass(643), Lplayn_html_HtmlTextLayout$Line_2_classLit = createForClass(644), Lbomberman_core_logic_powerUp_PowerUpEnum_2_classLit = createForEnum(55, values_1), _3Lbomberman_core_logic_powerUp_PowerUpEnum_2_classLit = createForArray(698, Lbomberman_core_logic_powerUp_PowerUpEnum_2_classLit), Lbomberman_core_graphics_Sprite_2_classLit = createForClass(33), Ljava_util_MapEntryImpl_2_classLit = createForClass(382), Ljava_util_Date_2_classLit = createForClass(374), Lcom_google_gwt_user_client_ui_AbsolutePanel_2_classLit = createForClass(301), Lcom_google_gwt_user_client_ui_RootPanel_2_classLit = createForClass(308), Lcom_google_gwt_user_client_ui_RootPanel$DefaultRootPanel_2_classLit = createForClass(311), Lcom_google_gwt_user_client_ui_RootPanel$1_2_classLit = createForClass(309), Lcom_google_gwt_user_client_ui_RootPanel$2_2_classLit = createForClass(310), Lpythagoras_f_AbstractVector_2_classLit = createForClass(654), Lpythagoras_f_Vector_2_classLit = createForClass(659), Lplayn_core_canvas_CanvasSurface_2_classLit = createForClass(545), Lplayn_core_gl_QuadShader_2_classLit = createForClass(579), Lplayn_core_gl_QuadShader$QuadCore_2_classLit = createForClass(580), Lpythagoras_util_NoninvertibleTransformException_2_classLit = createForClass(661), Lbomberman_core_util_Timer_2_classLit = createForClass(80), Lbomberman_core_logic_Bomb_2_classLit = createForClass(36), Ljava_util_Vector_2_classLit = createForClass(386), Ljava_util_Stack_2_classLit = createForClass(385), Lbomberman_core_logic_Direction_2_classLit = createForEnum(38, values_0), _3Lbomberman_core_logic_Direction_2_classLit = createForArray(699, Lbomberman_core_logic_Direction_2_classLit), Ljava_util_AbstractSequentialList_2_classLit = createForClass(369), Ljava_util_LinkedList_2_classLit = createForClass(379), Ljava_util_LinkedList$ListIteratorImpl_2_classLit = createForClass(380), Ljava_util_LinkedList$Node_2_classLit = createForClass(381), Lplayn_html_HtmlSurfaceImageCanvas_2_classLit = createForClass(642), Lplayn_core_gl_SurfaceImageGL_2_classLit = createForClass(583), Lplayn_core_gl_SurfaceGL_2_classLit = createForClass(582), Lplayn_html_HtmlFontMetrics_2_classLit = createForClass(597), Ljava_lang_IndexOutOfBoundsException_2_classLit = createForClass(339), Lcom_google_gwt_i18n_client_LocaleInfo_2_classLit = createForClass(244), Lcom_google_gwt_i18n_shared_DateTimeFormat_2_classLit = createForClass(241), Lcom_google_gwt_i18n_shared_DateTimeFormat$PatternPart_2_classLit = createForClass(247), Lcom_google_gwt_i18n_client_DateTimeFormat_2_classLit = createForClass(240), Ljava_util_HashSet_2_classLit = createForClass(378), Lcom_google_gwt_event_shared_LegacyHandlerWrapper_2_classLit = createForClass(234), Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit = createForClass(460), _3Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit = createForArray(700, Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit), _3_3Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit = createForArray(701, _3Lorg_jbox2d_dynamics_contacts_ContactRegister_2_classLit), Lorg_jbox2d_dynamics_Body_2_classLit = createForClass(441), _3Lorg_jbox2d_dynamics_Body_2_classLit = createForArray(702, Lorg_jbox2d_dynamics_Body_2_classLit), Lorg_jbox2d_dynamics_World_2_classLit = createForClass(452), Lorg_jbox2d_dynamics_WorldRayCastWrapper_2_classLit = createForClass(453), Ljava_util_Random_2_classLit = createForClass(384), Lorg_jbox2d_common_Vec2_2_classLit = createForClass(439), Lcom_google_gwt_event_logical_shared_CloseEvent_2_classLit = createForClass(229), Ljava_util_EmptyStackException_2_classLit = createForClass(376), Lorg_jbox2d_common_Timer_2_classLit = createForClass(437), Lorg_jbox2d_dynamics_ContactManager_2_classLit = createForClass(444), Lorg_jbox2d_dynamics_TimeStep_2_classLit = createForClass(451), Lorg_jbox2d_dynamics_Profile_2_classLit = createForClass(450), Lorg_jbox2d_dynamics_contacts_Contact_2_classLit = createForClass(455), Lorg_jbox2d_dynamics_Fixture_2_classLit = createForClass(446), Lorg_jbox2d_dynamics_FixtureProxy_2_classLit = createForClass(448), _3Lorg_jbox2d_dynamics_FixtureProxy_2_classLit = createForArray(703, Lorg_jbox2d_dynamics_FixtureProxy_2_classLit), Lbomberman_core_logic_FreeBlock_2_classLit = createForClass(42), Lbomberman_core_graphics_BombDecorator_2_classLit = createForClass(14), Lbomberman_core_logic_enemy_Enemy_2_classLit = createForClass(11), Lbomberman_core_logic_enemy_EnemyBarom_2_classLit = createForClass(10), Lbomberman_core_graphics_BaromDecorator_2_classLit = createForClass(9), Lbomberman_core_logic_enemy_EnemyMaron_2_classLit = createForClass(25), Lbomberman_core_graphics_MaronDecorator_2_classLit = createForClass(24), Lbomberman_core_logic_enemy_EnemyOnil_2_classLit = createForClass(29), Lbomberman_core_graphics_OnilDecorator_2_classLit = createForClass(28), Lbomberman_core_logic_enemy_EnemyPontan_2_classLit = createForClass(31), Lbomberman_core_graphics_PontanDecorator_2_classLit = createForClass(30), Lbomberman_core_logic_enemy_EnemyMinvo_2_classLit = createForClass(27), Lbomberman_core_graphics_MinvoDecorator_2_classLit = createForClass(26), Lplayn_html_HtmlPattern_2_classLit = createForClass(627), Lorg_jbox2d_pooling_normal_DefaultWorldPool_2_classLit = createForClass(473), Lorg_jbox2d_pooling_normal_MutableStack_2_classLit = createForClass(475), Lorg_jbox2d_pooling_normal_DefaultWorldPool$1_2_classLit = createForClass(474), Lorg_jbox2d_pooling_normal_DefaultWorldPool$2_2_classLit = createForClass(481), Lorg_jbox2d_pooling_normal_DefaultWorldPool$3_2_classLit = createForClass(482), Lorg_jbox2d_pooling_normal_DefaultWorldPool$4_2_classLit = createForClass(483), Lorg_jbox2d_pooling_normal_DefaultWorldPool$5_2_classLit = createForClass(484), Lorg_jbox2d_pooling_normal_DefaultWorldPool$6_2_classLit = createForClass(485), Lorg_jbox2d_pooling_normal_DefaultWorldPool$7_2_classLit = createForClass(486), Lorg_jbox2d_pooling_normal_OrderedStack_2_classLit = createForClass(477), Lorg_jbox2d_pooling_normal_DefaultWorldPool$8_2_classLit = createForClass(487), Lorg_jbox2d_pooling_normal_DefaultWorldPool$9_2_classLit = createForClass(488), Lorg_jbox2d_pooling_normal_DefaultWorldPool$10_2_classLit = createForClass(476), Lorg_jbox2d_pooling_normal_DefaultWorldPool$11_2_classLit = createForClass(478), Lorg_jbox2d_pooling_normal_DefaultWorldPool$12_2_classLit = createForClass(479), Lorg_jbox2d_pooling_normal_DefaultWorldPool$13_2_classLit = createForClass(480), Lorg_jbox2d_dynamics_BodyType_2_classLit = createForEnum(443, values_20), _3Lorg_jbox2d_dynamics_BodyType_2_classLit = createForArray(704, Lorg_jbox2d_dynamics_BodyType_2_classLit), Lorg_jbox2d_dynamics_contacts_ContactEdge_2_classLit = createForClass(458), Lorg_jbox2d_collision_broadphase_BroadPhase_2_classLit = createForClass(419), Lorg_jbox2d_collision_broadphase_Pair_2_classLit = createForClass(423), _3Lorg_jbox2d_collision_broadphase_Pair_2_classLit = createForArray(705, Lorg_jbox2d_collision_broadphase_Pair_2_classLit), Lorg_jbox2d_callbacks_ContactFilter_2_classLit = createForClass(388), Lorg_jbox2d_dynamics_Island_2_classLit = createForClass(449), Lorg_jbox2d_dynamics_joints_Joint_2_classLit = createForClass(null), _3Lorg_jbox2d_dynamics_joints_Joint_2_classLit = createForArray(706, Lorg_jbox2d_dynamics_joints_Joint_2_classLit), _3Lorg_jbox2d_dynamics_contacts_Contact_2_classLit = createForArray(707, Lorg_jbox2d_dynamics_contacts_Contact_2_classLit), Lorg_jbox2d_dynamics_contacts_Velocity_2_classLit = createForClass(471), _3Lorg_jbox2d_dynamics_contacts_Velocity_2_classLit = createForArray(708, Lorg_jbox2d_dynamics_contacts_Velocity_2_classLit), Lorg_jbox2d_dynamics_contacts_Position_2_classLit = createForClass(469), _3Lorg_jbox2d_dynamics_contacts_Position_2_classLit = createForArray(709, Lorg_jbox2d_dynamics_contacts_Position_2_classLit), Lorg_jbox2d_collision_TimeOfImpact_2_classLit = createForClass(413), Lorg_jbox2d_collision_TimeOfImpact$TOIInput_2_classLit = createForClass(414), Lorg_jbox2d_collision_TimeOfImpact$TOIOutputState_2_classLit = createForEnum(416, values_17), _3Lorg_jbox2d_collision_TimeOfImpact$TOIOutputState_2_classLit = createForArray(710, Lorg_jbox2d_collision_TimeOfImpact$TOIOutputState_2_classLit), Lorg_jbox2d_collision_TimeOfImpact$TOIOutput_2_classLit = createForClass(415), Lorg_jbox2d_collision_Type_2_classLit = createForEnum(417, values_18), _3Lorg_jbox2d_collision_Type_2_classLit = createForArray(711, Lorg_jbox2d_collision_Type_2_classLit), Lorg_jbox2d_collision_SeparationFunction_2_classLit = createForClass(412), Lorg_jbox2d_common_Sweep_2_classLit = createForClass(436), Lorg_jbox2d_collision_Distance_2_classLit = createForClass(400), Lorg_jbox2d_collision_Distance$SimplexVertex_2_classLit = createForClass(404), Lorg_jbox2d_collision_Distance$SimplexCache_2_classLit = createForClass(403), _3Lorg_jbox2d_collision_Distance$SimplexVertex_2_classLit = createForArray(712, Lorg_jbox2d_collision_Distance$SimplexVertex_2_classLit), Lorg_jbox2d_collision_Distance$Simplex_2_classLit = createForClass(402), Lorg_jbox2d_collision_Distance$DistanceProxy_2_classLit = createForClass(401), _3Lorg_jbox2d_common_Vec2_2_classLit = createForArray(713, Lorg_jbox2d_common_Vec2_2_classLit), Lorg_jbox2d_collision_shapes_Shape_2_classLit = createForClass(425), Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit = createForClass(392), _3Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit = createForArray(714, Lorg_jbox2d_collision_Collision$ClipVertex_2_classLit), Lorg_jbox2d_collision_Collision_2_classLit = createForClass(391), Lorg_jbox2d_collision_Collision$EdgeResults_2_classLit = createForClass(396), Lorg_jbox2d_collision_Collision$EPAxis_2_classLit = createForClass(393), Lorg_jbox2d_collision_Collision$EPAxis$Type_2_classLit = createForEnum(394, values_15), _3Lorg_jbox2d_collision_Collision$EPAxis$Type_2_classLit = createForArray(715, Lorg_jbox2d_collision_Collision$EPAxis$Type_2_classLit), Lorg_jbox2d_collision_Collision$TempPolygon_2_classLit = createForClass(398), Lorg_jbox2d_collision_Collision$ReferenceFace_2_classLit = createForClass(397), Lorg_jbox2d_collision_Collision$EPCollider_2_classLit = createForClass(395), Lorg_jbox2d_collision_broadphase_DynamicTree_2_classLit = createForClass(420), Lorg_jbox2d_collision_broadphase_DynamicTreeNode_2_classLit = createForClass(422), _3Lorg_jbox2d_collision_broadphase_DynamicTreeNode_2_classLit = createForArray(716, Lorg_jbox2d_collision_broadphase_DynamicTreeNode_2_classLit), Lorg_jbox2d_collision_broadphase_DynamicTree$TreeNodeStack_2_classLit = createForClass(421), Ljava_nio_Buffer_2_classLit = createForClass(353), Ljava_nio_ByteBuffer_2_classLit = createForClass(355), Lcom_google_gwt_i18n_shared_DefaultDateTimeFormatInfo_2_classLit = createForClass(243), Lcom_google_gwt_i18n_client_DefaultDateTimeFormatInfo_2_classLit = createForClass(242), Lcom_google_gwt_i18n_client_impl_cldr_DateTimeFormatInfoImpl_2_classLit = createForClass(246), Lcom_google_gwt_i18n_client_TimeZone_2_classLit = createForClass(245), Lplayn_core_gl_GL20Buffer_2_classLit = createForClass(554), Lplayn_core_gl_GL20Buffer$FloatImpl_2_classLit = createForClass(555), Lplayn_core_gl_GL20Buffer$ShortImpl_2_classLit = createForClass(556), _3S_classLit = createForArray(717, S_classLit), Lorg_jbox2d_collision_AABB_2_classLit = createForClass(390), Lorg_jbox2d_dynamics_Filter_2_classLit = createForClass(445), Lorg_jbox2d_common_Transform_2_classLit = createForClass(438), Lorg_jbox2d_collision_ManifoldPoint_2_classLit = createForClass(409), Lorg_jbox2d_collision_ContactID_2_classLit = createForClass(399), Lorg_jbox2d_collision_Manifold_2_classLit = createForClass(407), _3Lorg_jbox2d_collision_ManifoldPoint_2_classLit = createForArray(718, Lorg_jbox2d_collision_ManifoldPoint_2_classLit), Lorg_jbox2d_collision_Manifold$ManifoldType_2_classLit = createForEnum(408, values_16), _3Lorg_jbox2d_collision_Manifold$ManifoldType_2_classLit = createForArray(719, Lorg_jbox2d_collision_Manifold$ManifoldType_2_classLit), Lorg_jbox2d_dynamics_contacts_ContactSolver_2_classLit = createForClass(461), Lorg_jbox2d_dynamics_contacts_ContactPositionConstraint_2_classLit = createForClass(459), _3Lorg_jbox2d_dynamics_contacts_ContactPositionConstraint_2_classLit = createForArray(720, Lorg_jbox2d_dynamics_contacts_ContactPositionConstraint_2_classLit), Lorg_jbox2d_dynamics_contacts_ContactVelocityConstraint_2_classLit = createForClass(463), _3Lorg_jbox2d_dynamics_contacts_ContactVelocityConstraint_2_classLit = createForArray(721, Lorg_jbox2d_dynamics_contacts_ContactVelocityConstraint_2_classLit), Lorg_jbox2d_dynamics_contacts_ContactSolver$ContactSolverDef_2_classLit = createForClass(462), Lorg_jbox2d_dynamics_contacts_PositionSolverManifold_2_classLit = createForClass(470), Lorg_jbox2d_dynamics_contacts_ContactVelocityConstraint$VelocityConstraintPoint_2_classLit = createForClass(464), _3Lorg_jbox2d_dynamics_contacts_ContactVelocityConstraint$VelocityConstraintPoint_2_classLit = createForArray(722, Lorg_jbox2d_dynamics_contacts_ContactVelocityConstraint$VelocityConstraintPoint_2_classLit), Lorg_jbox2d_common_Rot_2_classLit = createForClass(434), Lorg_jbox2d_collision_shapes_CircleShape_2_classLit = createForClass(424), Lorg_jbox2d_collision_shapes_PolygonShape_2_classLit = createForClass(428), Lorg_jbox2d_collision_shapes_EdgeShape_2_classLit = createForClass(426), Lorg_jbox2d_collision_shapes_ShapeType_2_classLit = createForEnum(429, values_19), _3Lorg_jbox2d_collision_shapes_ShapeType_2_classLit = createForArray(723, Lorg_jbox2d_collision_shapes_ShapeType_2_classLit), Lorg_jbox2d_collision_DistanceInput_2_classLit = createForClass(405), Lorg_jbox2d_collision_DistanceOutput_2_classLit = createForClass(406), Lbomberman_core_logic_FireEntity_2_classLit = createForClass(41), Lbomberman_core_logic_BrickBlock_2_classLit = createForClass(37), Lbomberman_core_graphics_DynamicBlockDecorator_2_classLit = createForClass(20), Lbomberman_core_logic_powerUp_PowerUp_2_classLit = createForClass(49), Lbomberman_core_logic_Strategy2_2_classLit = createForClass(46), Lbomberman_core_logic_Strategy1_2_classLit = createForClass(45), Lplayn_core_gl_GL20Program_2_classLit = createForClass(559), Lplayn_core_gl_GL20Program$2_2_classLit = createForClass(561), Lplayn_core_gl_GL20Program$5_2_classLit = createForClass(562), Lplayn_core_gl_GL20Program$8_2_classLit = createForClass(563), Lplayn_core_gl_GL20Program$10_2_classLit = createForClass(560), Lorg_jbox2d_common_Mat22_2_classLit = createForClass(430), Lorg_jbox2d_collision_WorldManifold_2_classLit = createForClass(418), Lorg_jbox2d_callbacks_ContactImpulse_2_classLit = createForClass(389), Lorg_jbox2d_collision_shapes_MassData_2_classLit = createForClass(427), Lorg_jbox2d_dynamics_BodyDef_2_classLit = createForClass(442), Lorg_jbox2d_dynamics_FixtureDef_2_classLit = createForClass(447), Lbomberman_core_graphics_FireDecorator_2_classLit = createForClass(21), Lbomberman_core_graphics_FireDecorator$1_2_classLit = createForClass(22), Lbomberman_core_graphics_PowerUpDecorator_2_classLit = createForClass(32), Lorg_jbox2d_collision_RayCastInput_2_classLit = createForClass(410), Lorg_jbox2d_pooling_arrays_Vec2Array_2_classLit = createForClass(472), Lplayn_core_AbstractSound_2_classLit = createForClass(497), Lplayn_html_HtmlSound_2_classLit = createForClass(639), Lplayn_html_HtmlSound$1_2_classLit = createForClass(640), Ljava_nio_ByteOrder_2_classLit = createForClass(356), Ljava_nio_FloatBuffer_2_classLit = createForClass(357), Ljava_nio_ShortBuffer_2_classLit = createForClass(358), Lbomberman_core_logic_powerUp_Door_2_classLit = createForClass(48), Lbomberman_core_logic_powerUp_PowerUpBomb_2_classLit = createForClass(50), Lbomberman_core_logic_powerUp_PowerUpBombKick_2_classLit = createForClass(51), Lbomberman_core_logic_powerUp_PowerUpBombPass_2_classLit = createForClass(52), Lbomberman_core_logic_powerUp_PowerUpBombRangeDown_2_classLit = createForClass(53), Lbomberman_core_logic_powerUp_PowerUpBombRangeUp_2_classLit = createForClass(54), Lbomberman_core_logic_powerUp_PowerUpLife_2_classLit = createForClass(56), Lbomberman_core_logic_powerUp_PowerUpSkull_2_classLit = createForClass(57), Lbomberman_core_logic_powerUp_PowerUpSpeedUp_2_classLit = createForClass(59), Lbomberman_core_logic_powerUp_PowerUpSpeedDown_2_classLit = createForClass(58), Lbomberman_core_logic_powerUp_PowerUpTimeDown_2_classLit = createForClass(60), Lbomberman_core_logic_powerUp_PowerUpTimeUp_2_classLit = createForClass(61), Lorg_jbox2d_common_Vec3_2_classLit = createForClass(440), Lorg_jbox2d_common_Mat33_2_classLit = createForClass(431), Lcom_allen_1sauer_gwt_voices_client_Sound$LoadState_2_classLit = createForEnum(106, values_2), _3Lcom_allen_1sauer_gwt_voices_client_Sound$LoadState_2_classLit = createForArray(724, Lcom_allen_1sauer_gwt_voices_client_Sound$LoadState_2_classLit), Ljava_nio_BufferOverflowException_2_classLit = createForClass(354), Lorg_jbox2d_dynamics_contacts_CircleContact_2_classLit = createForClass(457), Lorg_jbox2d_dynamics_contacts_PolygonAndCircleContact_2_classLit = createForClass(467), Lorg_jbox2d_dynamics_contacts_EdgeAndCircleContact_2_classLit = createForClass(465), Lorg_jbox2d_dynamics_contacts_EdgeAndPolygonContact_2_classLit = createForClass(466), Lorg_jbox2d_dynamics_contacts_ChainAndCircleContact_2_classLit = createForClass(454), Lorg_jbox2d_dynamics_contacts_ChainAndPolygonContact_2_classLit = createForClass(456), Lorg_jbox2d_dynamics_contacts_PolygonContact_2_classLit = createForClass(468), Lorg_jbox2d_collision_RayCastOutput_2_classLit = createForClass(411), Ljava_util_Collections$EmptyList_2_classLit = createForClass(372), Lcom_allen_1sauer_gwt_voices_client_AbstractSound_2_classLit = createForClass(99), Lcom_allen_1sauer_gwt_voices_client_FlashSound_2_classLit = createForClass(100), Lcom_allen_1sauer_gwt_voices_client_FlashSound$1_2_classLit = createForClass(101), Lcom_allen_1sauer_gwt_voices_client_FlashSound$2_2_classLit = createForClass(102), Lcom_allen_1sauer_gwt_voices_client_NativeSound_2_classLit = createForClass(105), Lcom_allen_1sauer_gwt_voices_client_Html5Sound_2_classLit = createForClass(103), Lcom_allen_1sauer_gwt_voices_client_Html5Sound$1_2_classLit = createForClass(104), Lcom_allen_1sauer_gwt_voices_client_ui_FlashMovie_2_classLit = createForClass(118), Lcom_allen_1sauer_gwt_voices_client_ui_VoicesMovie_2_classLit = createForClass(119), Lcom_allen_1sauer_gwt_voices_client_ui_VoicesMovie$1_2_classLit = createForClass(120), Lcom_allen_1sauer_gwt_voices_client_WebAudioSound_2_classLit = createForClass(110), Lcom_google_gwt_user_client_ui_FocusWidget_2_classLit = createForClass(263), Lcom_google_gwt_media_client_MediaBase_2_classLit = createForClass(262), Lcom_google_gwt_media_client_Audio_2_classLit = createForClass(261), Lcom_google_gwt_media_client_Audio$AudioElementSupportDetector_2_classLit = createForClass(267), Lcom_google_gwt_media_client_Audio$AudioElementSupportDetectedMaybe_2_classLit = createForClass(266), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImpl_2_classLit = createForClass(121), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImplPlayN_2_classLit = createForClass(123), Lcom_allen_1sauer_gwt_voices_client_handler_SoundHandlerCollection_2_classLit = createForClass(113), Ljava_util_EventObject_2_classLit = createForClass(112), Lcom_allen_1sauer_gwt_voices_client_handler_SoundLoadStateChangeEvent_2_classLit = createForClass(117), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImplIE6_2_classLit = createForClass(122), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImplStandard_2_classLit = createForClass(125), Lcom_allen_1sauer_gwt_voices_client_ui_impl_FlashMovieImplSafari_2_classLit = createForClass(124), Lcom_google_gwt_event_dom_client_DomEvent_2_classLit = createForClass(220), Lcom_google_gwt_event_dom_client_EndedEvent_2_classLit = createForClass(226), Lcom_google_gwt_event_dom_client_DomEvent$Type_2_classLit = createForClass(223), Lcom_google_gwt_user_client_ui_WidgetCollection_2_classLit = createForClass(312), _3Lcom_google_gwt_user_client_ui_Widget_2_classLit = createForArray(725, Lcom_google_gwt_user_client_ui_Widget_2_classLit), Lcom_google_gwt_user_client_ui_WidgetCollection$WidgetIterator_2_classLit = createForClass(313), Lcom_allen_1sauer_gwt_voices_client_handler_PlaybackCompleteEvent_2_classLit = createForClass(111), Lcom_google_gwt_event_dom_client_PrivateMap_2_classLit = createForClass(227);
$stats && $stats({moduleName:'bomberman',sessionId:$sessionId,subSystem:'startup',evtGroup:'moduleStartup',millis:(new Date()).getTime(),type:'moduleEvalEnd'});
if ($wnd.bomberman) $wnd.bomberman.onScriptLoad();
--></script></body></html>
